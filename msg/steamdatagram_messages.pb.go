// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: steamdatagram_messages.proto

/*
	Package steamdatagram_messages is a generated protocol buffer package.

	It is generated from these files:
		steamdatagram_messages.proto

	It has these top-level messages:
		CMsgSteamDatagramRouterPingReply
		CMsgSteamDatagramGameserverPing
		CMsgSteamDatagramGameServerAuthTicket
		CMsgSteamDatagramGameserverSessionRequest
		CMsgSteamDatagramGameserverSessionEstablished
		CMsgSteamDatagramNoSession
		CMsgSteamDatagramDiagnostic
		CMsgSteamDatagramDataCenterState
		CMsgSteamDatagramLinkInstantaneousStats
		CMsgSteamDatagramLinkLifetimeStats
		CMsgSteamDatagramConnectionQuality
		CMsgSteamDatagramConnectionStatsClientToRouter
		CMsgSteamDatagramConnectionStatsRouterToClient
		CMsgSteamDatagramConnectionStatsRouterToServer
		CMsgSteamDatagramConnectionStatsServerToRouter
		CMsgSteamDatagramClientPingSampleRequest
		CMsgSteamDatagramClientPingSampleReply
		CMsgSteamDatagramClientSwitchedPrimary
*/
package steamdatagram_messages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ESteamDatagramMsgID int32

const (
	ESteamDatagramMsgID_k_ESteamDatagramMsg_RouterPingRequest             ESteamDatagramMsgID = 1
	ESteamDatagramMsgID_k_ESteamDatagramMsg_RouterPingReply               ESteamDatagramMsgID = 2
	ESteamDatagramMsgID_k_ESteamDatagramMsg_GameserverPingRequest         ESteamDatagramMsgID = 3
	ESteamDatagramMsgID_k_ESteamDatagramMsg_GameserverPingReply           ESteamDatagramMsgID = 4
	ESteamDatagramMsgID_k_ESteamDatagramMsg_GameserverSessionRequest      ESteamDatagramMsgID = 5
	ESteamDatagramMsgID_k_ESteamDatagramMsg_GameserverSessionEstablished  ESteamDatagramMsgID = 6
	ESteamDatagramMsgID_k_ESteamDatagramMsg_NoSession                     ESteamDatagramMsgID = 7
	ESteamDatagramMsgID_k_ESteamDatagramMsg_Diagnostic                    ESteamDatagramMsgID = 8
	ESteamDatagramMsgID_k_ESteamDatagramMsg_DataClientToRouter            ESteamDatagramMsgID = 9
	ESteamDatagramMsgID_k_ESteamDatagramMsg_DataRouterToServer            ESteamDatagramMsgID = 10
	ESteamDatagramMsgID_k_ESteamDatagramMsg_DataServerToRouter            ESteamDatagramMsgID = 11
	ESteamDatagramMsgID_k_ESteamDatagramMsg_DataRouterToClient            ESteamDatagramMsgID = 12
	ESteamDatagramMsgID_k_ESteamDatagramMsg_Stats                         ESteamDatagramMsgID = 13
	ESteamDatagramMsgID_k_ESteamDatagramMsg_ClientPingSampleRequest       ESteamDatagramMsgID = 14
	ESteamDatagramMsgID_k_ESteamDatagramMsg_ClientPingSampleReply         ESteamDatagramMsgID = 15
	ESteamDatagramMsgID_k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary ESteamDatagramMsgID = 16
)

var ESteamDatagramMsgID_name = map[int32]string{
	1:  "k_ESteamDatagramMsg_RouterPingRequest",
	2:  "k_ESteamDatagramMsg_RouterPingReply",
	3:  "k_ESteamDatagramMsg_GameserverPingRequest",
	4:  "k_ESteamDatagramMsg_GameserverPingReply",
	5:  "k_ESteamDatagramMsg_GameserverSessionRequest",
	6:  "k_ESteamDatagramMsg_GameserverSessionEstablished",
	7:  "k_ESteamDatagramMsg_NoSession",
	8:  "k_ESteamDatagramMsg_Diagnostic",
	9:  "k_ESteamDatagramMsg_DataClientToRouter",
	10: "k_ESteamDatagramMsg_DataRouterToServer",
	11: "k_ESteamDatagramMsg_DataServerToRouter",
	12: "k_ESteamDatagramMsg_DataRouterToClient",
	13: "k_ESteamDatagramMsg_Stats",
	14: "k_ESteamDatagramMsg_ClientPingSampleRequest",
	15: "k_ESteamDatagramMsg_ClientPingSampleReply",
	16: "k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary",
}
var ESteamDatagramMsgID_value = map[string]int32{
	"k_ESteamDatagramMsg_RouterPingRequest":             1,
	"k_ESteamDatagramMsg_RouterPingReply":               2,
	"k_ESteamDatagramMsg_GameserverPingRequest":         3,
	"k_ESteamDatagramMsg_GameserverPingReply":           4,
	"k_ESteamDatagramMsg_GameserverSessionRequest":      5,
	"k_ESteamDatagramMsg_GameserverSessionEstablished":  6,
	"k_ESteamDatagramMsg_NoSession":                     7,
	"k_ESteamDatagramMsg_Diagnostic":                    8,
	"k_ESteamDatagramMsg_DataClientToRouter":            9,
	"k_ESteamDatagramMsg_DataRouterToServer":            10,
	"k_ESteamDatagramMsg_DataServerToRouter":            11,
	"k_ESteamDatagramMsg_DataRouterToClient":            12,
	"k_ESteamDatagramMsg_Stats":                         13,
	"k_ESteamDatagramMsg_ClientPingSampleRequest":       14,
	"k_ESteamDatagramMsg_ClientPingSampleReply":         15,
	"k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary": 16,
}

func (x ESteamDatagramMsgID) Enum() *ESteamDatagramMsgID {
	p := new(ESteamDatagramMsgID)
	*p = x
	return p
}
func (x ESteamDatagramMsgID) String() string {
	return proto.EnumName(ESteamDatagramMsgID_name, int32(x))
}
func (x *ESteamDatagramMsgID) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ESteamDatagramMsgID_value, data, "ESteamDatagramMsgID")
	if err != nil {
		return err
	}
	*x = ESteamDatagramMsgID(value)
	return nil
}
func (ESteamDatagramMsgID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{0}
}

type CMsgSteamDatagramRouterPingReply struct {
	ClientTimestamp      uint32   `protobuf:"fixed32,1,opt,name=client_timestamp,json=clientTimestamp" json:"client_timestamp"`
	LatencyDatacenterIds []uint32 `protobuf:"fixed32,2,rep,packed,name=latency_datacenter_ids,json=latencyDatacenterIds" json:"latency_datacenter_ids,omitempty"`
	LatencyPingMs        []uint32 `protobuf:"varint,3,rep,packed,name=latency_ping_ms,json=latencyPingMs" json:"latency_ping_ms,omitempty"`
	YourPublicIp         uint32   `protobuf:"fixed32,4,opt,name=your_public_ip,json=yourPublicIp" json:"your_public_ip"`
	ServerTime           uint32   `protobuf:"fixed32,5,opt,name=server_time,json=serverTime" json:"server_time"`
	Challenge            uint64   `protobuf:"fixed64,6,opt,name=challenge" json:"challenge"`
	SecondsUntilShutdown uint32   `protobuf:"varint,7,opt,name=seconds_until_shutdown,json=secondsUntilShutdown" json:"seconds_until_shutdown"`
	ClientCookie         uint32   `protobuf:"fixed32,8,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
}

func (m *CMsgSteamDatagramRouterPingReply) Reset()         { *m = CMsgSteamDatagramRouterPingReply{} }
func (m *CMsgSteamDatagramRouterPingReply) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramRouterPingReply) ProtoMessage()    {}
func (*CMsgSteamDatagramRouterPingReply) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{0}
}

func (m *CMsgSteamDatagramRouterPingReply) GetClientTimestamp() uint32 {
	if m != nil {
		return m.ClientTimestamp
	}
	return 0
}

func (m *CMsgSteamDatagramRouterPingReply) GetLatencyDatacenterIds() []uint32 {
	if m != nil {
		return m.LatencyDatacenterIds
	}
	return nil
}

func (m *CMsgSteamDatagramRouterPingReply) GetLatencyPingMs() []uint32 {
	if m != nil {
		return m.LatencyPingMs
	}
	return nil
}

func (m *CMsgSteamDatagramRouterPingReply) GetYourPublicIp() uint32 {
	if m != nil {
		return m.YourPublicIp
	}
	return 0
}

func (m *CMsgSteamDatagramRouterPingReply) GetServerTime() uint32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *CMsgSteamDatagramRouterPingReply) GetChallenge() uint64 {
	if m != nil {
		return m.Challenge
	}
	return 0
}

func (m *CMsgSteamDatagramRouterPingReply) GetSecondsUntilShutdown() uint32 {
	if m != nil {
		return m.SecondsUntilShutdown
	}
	return 0
}

func (m *CMsgSteamDatagramRouterPingReply) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

type CMsgSteamDatagramGameserverPing struct {
	ClientSession           uint32 `protobuf:"varint,1,opt,name=client_session,json=clientSession" json:"client_session"`
	ClientSteamId           uint64 `protobuf:"fixed64,2,opt,name=client_steam_id,json=clientSteamId" json:"client_steam_id"`
	ClientTimestamp         uint32 `protobuf:"fixed32,3,opt,name=client_timestamp,json=clientTimestamp" json:"client_timestamp"`
	RouterTimestamp         uint32 `protobuf:"fixed32,4,opt,name=router_timestamp,json=routerTimestamp" json:"router_timestamp"`
	RouterGameserverLatency uint32 `protobuf:"varint,5,opt,name=router_gameserver_latency,json=routerGameserverLatency" json:"router_gameserver_latency"`
	SeqNumberRouter         uint32 `protobuf:"varint,6,opt,name=seq_number_router,json=seqNumberRouter" json:"seq_number_router"`
	SeqNumberE2E            uint32 `protobuf:"varint,7,opt,name=seq_number_e2e,json=seqNumberE2e" json:"seq_number_e2e"`
}

func (m *CMsgSteamDatagramGameserverPing) Reset()         { *m = CMsgSteamDatagramGameserverPing{} }
func (m *CMsgSteamDatagramGameserverPing) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramGameserverPing) ProtoMessage()    {}
func (*CMsgSteamDatagramGameserverPing) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{1}
}

func (m *CMsgSteamDatagramGameserverPing) GetClientSession() uint32 {
	if m != nil {
		return m.ClientSession
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverPing) GetClientSteamId() uint64 {
	if m != nil {
		return m.ClientSteamId
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverPing) GetClientTimestamp() uint32 {
	if m != nil {
		return m.ClientTimestamp
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverPing) GetRouterTimestamp() uint32 {
	if m != nil {
		return m.RouterTimestamp
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverPing) GetRouterGameserverLatency() uint32 {
	if m != nil {
		return m.RouterGameserverLatency
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverPing) GetSeqNumberRouter() uint32 {
	if m != nil {
		return m.SeqNumberRouter
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverPing) GetSeqNumberE2E() uint32 {
	if m != nil {
		return m.SeqNumberE2E
	}
	return 0
}

type CMsgSteamDatagramGameServerAuthTicket struct {
	TimeExpiry         uint32                                              `protobuf:"fixed32,1,opt,name=time_expiry,json=timeExpiry" json:"time_expiry"`
	AuthorizedSteamId  uint64                                              `protobuf:"fixed64,2,opt,name=authorized_steam_id,json=authorizedSteamId" json:"authorized_steam_id"`
	AuthorizedPublicIp uint32                                              `protobuf:"fixed32,3,opt,name=authorized_public_ip,json=authorizedPublicIp" json:"authorized_public_ip"`
	GameserverSteamId  uint64                                              `protobuf:"fixed64,4,opt,name=gameserver_steam_id,json=gameserverSteamId" json:"gameserver_steam_id"`
	GameserverNetId    uint64                                              `protobuf:"fixed64,5,opt,name=gameserver_net_id,json=gameserverNetId" json:"gameserver_net_id"`
	Signature          []byte                                              `protobuf:"bytes,6,opt,name=signature" json:"signature"`
	AppId              uint32                                              `protobuf:"varint,7,opt,name=app_id,json=appId" json:"app_id"`
	ExtraFields        []*CMsgSteamDatagramGameServerAuthTicket_ExtraField `protobuf:"bytes,8,rep,name=extra_fields,json=extraFields" json:"extra_fields,omitempty"`
}

func (m *CMsgSteamDatagramGameServerAuthTicket) Reset()         { *m = CMsgSteamDatagramGameServerAuthTicket{} }
func (m *CMsgSteamDatagramGameServerAuthTicket) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramGameServerAuthTicket) ProtoMessage()    {}
func (*CMsgSteamDatagramGameServerAuthTicket) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{2}
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetTimeExpiry() uint32 {
	if m != nil {
		return m.TimeExpiry
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetAuthorizedSteamId() uint64 {
	if m != nil {
		return m.AuthorizedSteamId
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetAuthorizedPublicIp() uint32 {
	if m != nil {
		return m.AuthorizedPublicIp
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetGameserverSteamId() uint64 {
	if m != nil {
		return m.GameserverSteamId
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetGameserverNetId() uint64 {
	if m != nil {
		return m.GameserverNetId
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket) GetExtraFields() []*CMsgSteamDatagramGameServerAuthTicket_ExtraField {
	if m != nil {
		return m.ExtraFields
	}
	return nil
}

type CMsgSteamDatagramGameServerAuthTicket_ExtraField struct {
	Name         string `protobuf:"bytes,1,opt,name=name" json:"name"`
	StringValue  string `protobuf:"bytes,2,opt,name=string_value,json=stringValue" json:"string_value"`
	Int32Value   int32  `protobuf:"zigzag32,3,opt,name=int32_value,json=int32Value" json:"int32_value"`
	Fixed32Value uint32 `protobuf:"fixed32,4,opt,name=fixed32_value,json=fixed32Value" json:"fixed32_value"`
	Fixed64Value uint64 `protobuf:"fixed64,5,opt,name=fixed64_value,json=fixed64Value" json:"fixed64_value"`
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) Reset() {
	*m = CMsgSteamDatagramGameServerAuthTicket_ExtraField{}
}
func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramGameServerAuthTicket_ExtraField) ProtoMessage() {}
func (*CMsgSteamDatagramGameServerAuthTicket_ExtraField) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{2, 0}
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) GetInt32Value() int32 {
	if m != nil {
		return m.Int32Value
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) GetFixed32Value() uint32 {
	if m != nil {
		return m.Fixed32Value
	}
	return 0
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) GetFixed64Value() uint64 {
	if m != nil {
		return m.Fixed64Value
	}
	return 0
}

type CMsgSteamDatagramGameserverSessionRequest struct {
	Ticket        *CMsgSteamDatagramGameServerAuthTicket `protobuf:"bytes,1,opt,name=ticket" json:"ticket,omitempty"`
	ChallengeTime uint32                                 `protobuf:"fixed32,3,opt,name=challenge_time,json=challengeTime" json:"challenge_time"`
	Challenge     uint64                                 `protobuf:"fixed64,4,opt,name=challenge" json:"challenge"`
	ClientCookie  uint32                                 `protobuf:"fixed32,5,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
}

func (m *CMsgSteamDatagramGameserverSessionRequest) Reset() {
	*m = CMsgSteamDatagramGameserverSessionRequest{}
}
func (m *CMsgSteamDatagramGameserverSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramGameserverSessionRequest) ProtoMessage()    {}
func (*CMsgSteamDatagramGameserverSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{3}
}

func (m *CMsgSteamDatagramGameserverSessionRequest) GetTicket() *CMsgSteamDatagramGameServerAuthTicket {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *CMsgSteamDatagramGameserverSessionRequest) GetChallengeTime() uint32 {
	if m != nil {
		return m.ChallengeTime
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverSessionRequest) GetChallenge() uint64 {
	if m != nil {
		return m.Challenge
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverSessionRequest) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

type CMsgSteamDatagramGameserverSessionEstablished struct {
	ClientCookie         uint32 `protobuf:"fixed32,1,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
	GameserverSteamId    uint64 `protobuf:"fixed64,3,opt,name=gameserver_steam_id,json=gameserverSteamId" json:"gameserver_steam_id"`
	SecondsUntilShutdown uint32 `protobuf:"varint,4,opt,name=seconds_until_shutdown,json=secondsUntilShutdown" json:"seconds_until_shutdown"`
}

func (m *CMsgSteamDatagramGameserverSessionEstablished) Reset() {
	*m = CMsgSteamDatagramGameserverSessionEstablished{}
}
func (m *CMsgSteamDatagramGameserverSessionEstablished) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramGameserverSessionEstablished) ProtoMessage() {}
func (*CMsgSteamDatagramGameserverSessionEstablished) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{4}
}

func (m *CMsgSteamDatagramGameserverSessionEstablished) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverSessionEstablished) GetGameserverSteamId() uint64 {
	if m != nil {
		return m.GameserverSteamId
	}
	return 0
}

func (m *CMsgSteamDatagramGameserverSessionEstablished) GetSecondsUntilShutdown() uint32 {
	if m != nil {
		return m.SecondsUntilShutdown
	}
	return 0
}

type CMsgSteamDatagramNoSession struct {
	ClientCookie         uint32 `protobuf:"fixed32,7,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
	YourPublicIp         uint32 `protobuf:"fixed32,2,opt,name=your_public_ip,json=yourPublicIp" json:"your_public_ip"`
	ServerTime           uint32 `protobuf:"fixed32,3,opt,name=server_time,json=serverTime" json:"server_time"`
	Challenge            uint64 `protobuf:"fixed64,4,opt,name=challenge" json:"challenge"`
	SecondsUntilShutdown uint32 `protobuf:"varint,5,opt,name=seconds_until_shutdown,json=secondsUntilShutdown" json:"seconds_until_shutdown"`
}

func (m *CMsgSteamDatagramNoSession) Reset()         { *m = CMsgSteamDatagramNoSession{} }
func (m *CMsgSteamDatagramNoSession) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramNoSession) ProtoMessage()    {}
func (*CMsgSteamDatagramNoSession) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{5}
}

func (m *CMsgSteamDatagramNoSession) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

func (m *CMsgSteamDatagramNoSession) GetYourPublicIp() uint32 {
	if m != nil {
		return m.YourPublicIp
	}
	return 0
}

func (m *CMsgSteamDatagramNoSession) GetServerTime() uint32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func (m *CMsgSteamDatagramNoSession) GetChallenge() uint64 {
	if m != nil {
		return m.Challenge
	}
	return 0
}

func (m *CMsgSteamDatagramNoSession) GetSecondsUntilShutdown() uint32 {
	if m != nil {
		return m.SecondsUntilShutdown
	}
	return 0
}

type CMsgSteamDatagramDiagnostic struct {
	Severity uint32 `protobuf:"varint,1,opt,name=severity" json:"severity"`
	Text     string `protobuf:"bytes,2,opt,name=text" json:"text"`
}

func (m *CMsgSteamDatagramDiagnostic) Reset()         { *m = CMsgSteamDatagramDiagnostic{} }
func (m *CMsgSteamDatagramDiagnostic) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramDiagnostic) ProtoMessage()    {}
func (*CMsgSteamDatagramDiagnostic) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{6}
}

func (m *CMsgSteamDatagramDiagnostic) GetSeverity() uint32 {
	if m != nil {
		return m.Severity
	}
	return 0
}

func (m *CMsgSteamDatagramDiagnostic) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type CMsgSteamDatagramDataCenterState struct {
	DataCenters []*CMsgSteamDatagramDataCenterState_DataCenter `protobuf:"bytes,1,rep,name=data_centers,json=dataCenters" json:"data_centers,omitempty"`
}

func (m *CMsgSteamDatagramDataCenterState) Reset()         { *m = CMsgSteamDatagramDataCenterState{} }
func (m *CMsgSteamDatagramDataCenterState) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramDataCenterState) ProtoMessage()    {}
func (*CMsgSteamDatagramDataCenterState) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{7}
}

func (m *CMsgSteamDatagramDataCenterState) GetDataCenters() []*CMsgSteamDatagramDataCenterState_DataCenter {
	if m != nil {
		return m.DataCenters
	}
	return nil
}

type CMsgSteamDatagramDataCenterState_Server struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address"`
	PingMs  uint32 `protobuf:"varint,2,opt,name=ping_ms,json=pingMs" json:"ping_ms"`
}

func (m *CMsgSteamDatagramDataCenterState_Server) Reset() {
	*m = CMsgSteamDatagramDataCenterState_Server{}
}
func (m *CMsgSteamDatagramDataCenterState_Server) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramDataCenterState_Server) ProtoMessage()    {}
func (*CMsgSteamDatagramDataCenterState_Server) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{7, 0}
}

func (m *CMsgSteamDatagramDataCenterState_Server) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CMsgSteamDatagramDataCenterState_Server) GetPingMs() uint32 {
	if m != nil {
		return m.PingMs
	}
	return 0
}

type CMsgSteamDatagramDataCenterState_DataCenter struct {
	Code         string                                     `protobuf:"bytes,1,opt,name=code" json:"code"`
	ServerSample []*CMsgSteamDatagramDataCenterState_Server `protobuf:"bytes,2,rep,name=server_sample,json=serverSample" json:"server_sample,omitempty"`
}

func (m *CMsgSteamDatagramDataCenterState_DataCenter) Reset() {
	*m = CMsgSteamDatagramDataCenterState_DataCenter{}
}
func (m *CMsgSteamDatagramDataCenterState_DataCenter) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramDataCenterState_DataCenter) ProtoMessage() {}
func (*CMsgSteamDatagramDataCenterState_DataCenter) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{7, 1}
}

func (m *CMsgSteamDatagramDataCenterState_DataCenter) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *CMsgSteamDatagramDataCenterState_DataCenter) GetServerSample() []*CMsgSteamDatagramDataCenterState_Server {
	if m != nil {
		return m.ServerSample
	}
	return nil
}

type CMsgSteamDatagramLinkInstantaneousStats struct {
	OutPacketsPerSecX10     uint32 `protobuf:"varint,1,opt,name=out_packets_per_sec_x10,json=outPacketsPerSecX10" json:"out_packets_per_sec_x10"`
	OutBytesPerSec          uint32 `protobuf:"varint,2,opt,name=out_bytes_per_sec,json=outBytesPerSec" json:"out_bytes_per_sec"`
	InPacketsPerSecX10      uint32 `protobuf:"varint,3,opt,name=in_packets_per_sec_x10,json=inPacketsPerSecX10" json:"in_packets_per_sec_x10"`
	InBytesPerSec           uint32 `protobuf:"varint,4,opt,name=in_bytes_per_sec,json=inBytesPerSec" json:"in_bytes_per_sec"`
	PingMs                  uint32 `protobuf:"varint,5,opt,name=ping_ms,json=pingMs" json:"ping_ms"`
	PacketsDroppedPct       uint32 `protobuf:"varint,6,opt,name=packets_dropped_pct,json=packetsDroppedPct" json:"packets_dropped_pct"`
	PacketsWeirdSequencePct uint32 `protobuf:"varint,7,opt,name=packets_weird_sequence_pct,json=packetsWeirdSequencePct" json:"packets_weird_sequence_pct"`
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) Reset() {
	*m = CMsgSteamDatagramLinkInstantaneousStats{}
}
func (m *CMsgSteamDatagramLinkInstantaneousStats) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramLinkInstantaneousStats) ProtoMessage()    {}
func (*CMsgSteamDatagramLinkInstantaneousStats) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{8}
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) GetOutPacketsPerSecX10() uint32 {
	if m != nil {
		return m.OutPacketsPerSecX10
	}
	return 0
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) GetOutBytesPerSec() uint32 {
	if m != nil {
		return m.OutBytesPerSec
	}
	return 0
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) GetInPacketsPerSecX10() uint32 {
	if m != nil {
		return m.InPacketsPerSecX10
	}
	return 0
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) GetInBytesPerSec() uint32 {
	if m != nil {
		return m.InBytesPerSec
	}
	return 0
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) GetPingMs() uint32 {
	if m != nil {
		return m.PingMs
	}
	return 0
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) GetPacketsDroppedPct() uint32 {
	if m != nil {
		return m.PacketsDroppedPct
	}
	return 0
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) GetPacketsWeirdSequencePct() uint32 {
	if m != nil {
		return m.PacketsWeirdSequencePct
	}
	return 0
}

type CMsgSteamDatagramLinkLifetimeStats struct {
	PacketsSent           uint64 `protobuf:"varint,3,opt,name=packets_sent,json=packetsSent" json:"packets_sent"`
	KbSent                uint64 `protobuf:"varint,4,opt,name=kb_sent,json=kbSent" json:"kb_sent"`
	PacketsRecv           uint64 `protobuf:"varint,5,opt,name=packets_recv,json=packetsRecv" json:"packets_recv"`
	KbRecv                uint64 `protobuf:"varint,6,opt,name=kb_recv,json=kbRecv" json:"kb_recv"`
	PacketsRecvSequenced  uint64 `protobuf:"varint,7,opt,name=packets_recv_sequenced,json=packetsRecvSequenced" json:"packets_recv_sequenced"`
	PacketsRecvDropped    uint64 `protobuf:"varint,8,opt,name=packets_recv_dropped,json=packetsRecvDropped" json:"packets_recv_dropped"`
	PacketsRecvOutOfOrder uint64 `protobuf:"varint,9,opt,name=packets_recv_out_of_order,json=packetsRecvOutOfOrder" json:"packets_recv_out_of_order"`
	PacketsRecvDuplicate  uint64 `protobuf:"varint,10,opt,name=packets_recv_duplicate,json=packetsRecvDuplicate" json:"packets_recv_duplicate"`
	PacketsRecvLurch      uint64 `protobuf:"varint,11,opt,name=packets_recv_lurch,json=packetsRecvLurch" json:"packets_recv_lurch"`
}

func (m *CMsgSteamDatagramLinkLifetimeStats) Reset()         { *m = CMsgSteamDatagramLinkLifetimeStats{} }
func (m *CMsgSteamDatagramLinkLifetimeStats) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramLinkLifetimeStats) ProtoMessage()    {}
func (*CMsgSteamDatagramLinkLifetimeStats) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{9}
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetPacketsSent() uint64 {
	if m != nil {
		return m.PacketsSent
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetKbSent() uint64 {
	if m != nil {
		return m.KbSent
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetPacketsRecv() uint64 {
	if m != nil {
		return m.PacketsRecv
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetKbRecv() uint64 {
	if m != nil {
		return m.KbRecv
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetPacketsRecvSequenced() uint64 {
	if m != nil {
		return m.PacketsRecvSequenced
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetPacketsRecvDropped() uint64 {
	if m != nil {
		return m.PacketsRecvDropped
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetPacketsRecvOutOfOrder() uint64 {
	if m != nil {
		return m.PacketsRecvOutOfOrder
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetPacketsRecvDuplicate() uint64 {
	if m != nil {
		return m.PacketsRecvDuplicate
	}
	return 0
}

func (m *CMsgSteamDatagramLinkLifetimeStats) GetPacketsRecvLurch() uint64 {
	if m != nil {
		return m.PacketsRecvLurch
	}
	return 0
}

type CMsgSteamDatagramConnectionQuality struct {
	Instantaneous *CMsgSteamDatagramLinkInstantaneousStats `protobuf:"bytes,1,opt,name=instantaneous" json:"instantaneous,omitempty"`
	Lifetime      *CMsgSteamDatagramLinkLifetimeStats      `protobuf:"bytes,2,opt,name=lifetime" json:"lifetime,omitempty"`
}

func (m *CMsgSteamDatagramConnectionQuality) Reset()         { *m = CMsgSteamDatagramConnectionQuality{} }
func (m *CMsgSteamDatagramConnectionQuality) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramConnectionQuality) ProtoMessage()    {}
func (*CMsgSteamDatagramConnectionQuality) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{10}
}

func (m *CMsgSteamDatagramConnectionQuality) GetInstantaneous() *CMsgSteamDatagramLinkInstantaneousStats {
	if m != nil {
		return m.Instantaneous
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionQuality) GetLifetime() *CMsgSteamDatagramLinkLifetimeStats {
	if m != nil {
		return m.Lifetime
	}
	return nil
}

type CMsgSteamDatagramConnectionStatsClientToRouter struct {
	C2R             *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,1,opt,name=c2r" json:"c2r,omitempty"`
	C2S             *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,2,opt,name=c2s" json:"c2s,omitempty"`
	ClientTimestamp uint32                              `protobuf:"fixed32,3,opt,name=client_timestamp,json=clientTimestamp" json:"client_timestamp"`
	ClientCookie    uint32                              `protobuf:"fixed32,8,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
	SeqNumC2R       uint32                              `protobuf:"varint,9,opt,name=seq_num_c2r,json=seqNumC2r" json:"seq_num_c2r"`
	SeqNumC2S       uint32                              `protobuf:"varint,10,opt,name=seq_num_c2s,json=seqNumC2s" json:"seq_num_c2s"`
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) Reset() {
	*m = CMsgSteamDatagramConnectionStatsClientToRouter{}
}
func (m *CMsgSteamDatagramConnectionStatsClientToRouter) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramConnectionStatsClientToRouter) ProtoMessage() {}
func (*CMsgSteamDatagramConnectionStatsClientToRouter) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{11}
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) GetC2R() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.C2R
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) GetC2S() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.C2S
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) GetClientTimestamp() uint32 {
	if m != nil {
		return m.ClientTimestamp
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) GetSeqNumC2R() uint32 {
	if m != nil {
		return m.SeqNumC2R
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) GetSeqNumC2S() uint32 {
	if m != nil {
		return m.SeqNumC2S
	}
	return 0
}

type CMsgSteamDatagramConnectionStatsRouterToClient struct {
	R2C                       *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,1,opt,name=r2c" json:"r2c,omitempty"`
	S2C                       *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,2,opt,name=s2c" json:"s2c,omitempty"`
	ClientTimestampFromRouter uint32                              `protobuf:"fixed32,3,opt,name=client_timestamp_from_router,json=clientTimestampFromRouter" json:"client_timestamp_from_router"`
	ClientTimestampFromServer uint32                              `protobuf:"fixed32,4,opt,name=client_timestamp_from_server,json=clientTimestampFromServer" json:"client_timestamp_from_server"`
	RouterGameserverLatency   uint32                              `protobuf:"varint,5,opt,name=router_gameserver_latency,json=routerGameserverLatency" json:"router_gameserver_latency"`
	SecondsUntilShutdown      uint32                              `protobuf:"varint,6,opt,name=seconds_until_shutdown,json=secondsUntilShutdown" json:"seconds_until_shutdown"`
	ClientCookie              uint32                              `protobuf:"fixed32,7,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
	SeqNumR2C                 uint32                              `protobuf:"varint,8,opt,name=seq_num_r2c,json=seqNumR2c" json:"seq_num_r2c"`
	SeqNumS2C                 uint32                              `protobuf:"varint,9,opt,name=seq_num_s2c,json=seqNumS2c" json:"seq_num_s2c"`
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) Reset() {
	*m = CMsgSteamDatagramConnectionStatsRouterToClient{}
}
func (m *CMsgSteamDatagramConnectionStatsRouterToClient) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramConnectionStatsRouterToClient) ProtoMessage() {}
func (*CMsgSteamDatagramConnectionStatsRouterToClient) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{12}
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetR2C() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.R2C
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetS2C() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.S2C
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetClientTimestampFromRouter() uint32 {
	if m != nil {
		return m.ClientTimestampFromRouter
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetClientTimestampFromServer() uint32 {
	if m != nil {
		return m.ClientTimestampFromServer
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetRouterGameserverLatency() uint32 {
	if m != nil {
		return m.RouterGameserverLatency
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetSecondsUntilShutdown() uint32 {
	if m != nil {
		return m.SecondsUntilShutdown
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetSeqNumR2C() uint32 {
	if m != nil {
		return m.SeqNumR2C
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) GetSeqNumS2C() uint32 {
	if m != nil {
		return m.SeqNumS2C
	}
	return 0
}

type CMsgSteamDatagramConnectionStatsRouterToServer struct {
	R2S             *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,1,opt,name=r2s" json:"r2s,omitempty"`
	C2S             *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,2,opt,name=c2s" json:"c2s,omitempty"`
	ClientTimestamp uint32                              `protobuf:"fixed32,3,opt,name=client_timestamp,json=clientTimestamp" json:"client_timestamp"`
	RouterTimestamp uint32                              `protobuf:"fixed32,4,opt,name=router_timestamp,json=routerTimestamp" json:"router_timestamp"`
	SeqNumR2S       uint32                              `protobuf:"varint,5,opt,name=seq_num_r2s,json=seqNumR2s" json:"seq_num_r2s"`
	SeqNumC2S       uint32                              `protobuf:"varint,6,opt,name=seq_num_c2s,json=seqNumC2s" json:"seq_num_c2s"`
	ClientSteamId   uint64                              `protobuf:"fixed64,7,opt,name=client_steam_id,json=clientSteamId" json:"client_steam_id"`
	ClientSessionId uint32                              `protobuf:"varint,8,opt,name=client_session_id,json=clientSessionId" json:"client_session_id"`
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) Reset() {
	*m = CMsgSteamDatagramConnectionStatsRouterToServer{}
}
func (m *CMsgSteamDatagramConnectionStatsRouterToServer) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramConnectionStatsRouterToServer) ProtoMessage() {}
func (*CMsgSteamDatagramConnectionStatsRouterToServer) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{13}
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetR2S() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.R2S
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetC2S() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.C2S
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetClientTimestamp() uint32 {
	if m != nil {
		return m.ClientTimestamp
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetRouterTimestamp() uint32 {
	if m != nil {
		return m.RouterTimestamp
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetSeqNumR2S() uint32 {
	if m != nil {
		return m.SeqNumR2S
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetSeqNumC2S() uint32 {
	if m != nil {
		return m.SeqNumC2S
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetClientSteamId() uint64 {
	if m != nil {
		return m.ClientSteamId
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) GetClientSessionId() uint32 {
	if m != nil {
		return m.ClientSessionId
	}
	return 0
}

type CMsgSteamDatagramConnectionStatsServerToRouter struct {
	S2R             *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,1,opt,name=s2r" json:"s2r,omitempty"`
	S2C             *CMsgSteamDatagramConnectionQuality `protobuf:"bytes,2,opt,name=s2c" json:"s2c,omitempty"`
	SeqNumS2R       uint32                              `protobuf:"varint,3,opt,name=seq_num_s2r,json=seqNumS2r" json:"seq_num_s2r"`
	SeqNumS2C       uint32                              `protobuf:"varint,4,opt,name=seq_num_s2c,json=seqNumS2c" json:"seq_num_s2c"`
	ClientSteamId   uint64                              `protobuf:"fixed64,5,opt,name=client_steam_id,json=clientSteamId" json:"client_steam_id"`
	ClientSessionId uint32                              `protobuf:"varint,6,opt,name=client_session_id,json=clientSessionId" json:"client_session_id"`
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) Reset() {
	*m = CMsgSteamDatagramConnectionStatsServerToRouter{}
}
func (m *CMsgSteamDatagramConnectionStatsServerToRouter) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramConnectionStatsServerToRouter) ProtoMessage() {}
func (*CMsgSteamDatagramConnectionStatsServerToRouter) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{14}
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) GetS2R() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.S2R
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) GetS2C() *CMsgSteamDatagramConnectionQuality {
	if m != nil {
		return m.S2C
	}
	return nil
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) GetSeqNumS2R() uint32 {
	if m != nil {
		return m.SeqNumS2R
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) GetSeqNumS2C() uint32 {
	if m != nil {
		return m.SeqNumS2C
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) GetClientSteamId() uint64 {
	if m != nil {
		return m.ClientSteamId
	}
	return 0
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) GetClientSessionId() uint32 {
	if m != nil {
		return m.ClientSessionId
	}
	return 0
}

type CMsgSteamDatagramClientPingSampleRequest struct {
	ClientCookie uint32 `protobuf:"fixed32,1,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
}

func (m *CMsgSteamDatagramClientPingSampleRequest) Reset() {
	*m = CMsgSteamDatagramClientPingSampleRequest{}
}
func (m *CMsgSteamDatagramClientPingSampleRequest) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramClientPingSampleRequest) ProtoMessage()    {}
func (*CMsgSteamDatagramClientPingSampleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{15}
}

func (m *CMsgSteamDatagramClientPingSampleRequest) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

type CMsgSteamDatagramClientPingSampleReply struct {
	ClientCookie    uint32                                                   `protobuf:"fixed32,1,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
	RoutingClusters []*CMsgSteamDatagramClientPingSampleReply_RoutingCluster `protobuf:"bytes,2,rep,name=routing_clusters,json=routingClusters" json:"routing_clusters,omitempty"`
}

func (m *CMsgSteamDatagramClientPingSampleReply) Reset() {
	*m = CMsgSteamDatagramClientPingSampleReply{}
}
func (m *CMsgSteamDatagramClientPingSampleReply) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramClientPingSampleReply) ProtoMessage()    {}
func (*CMsgSteamDatagramClientPingSampleReply) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{16}
}

func (m *CMsgSteamDatagramClientPingSampleReply) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

func (m *CMsgSteamDatagramClientPingSampleReply) GetRoutingClusters() []*CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
	if m != nil {
		return m.RoutingClusters
	}
	return nil
}

type CMsgSteamDatagramClientPingSampleReply_RoutingCluster struct {
	Id          uint32 `protobuf:"fixed32,1,opt,name=id" json:"id"`
	FrontPingMs uint32 `protobuf:"varint,2,opt,name=front_ping_ms,json=frontPingMs" json:"front_ping_ms"`
	E2EPingMs   uint32 `protobuf:"varint,3,opt,name=e2e_ping_ms,json=e2ePingMs" json:"e2e_ping_ms"`
}

func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) Reset() {
	*m = CMsgSteamDatagramClientPingSampleReply_RoutingCluster{}
}
func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramClientPingSampleReply_RoutingCluster) ProtoMessage() {}
func (*CMsgSteamDatagramClientPingSampleReply_RoutingCluster) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{16, 0}
}

func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) GetFrontPingMs() uint32 {
	if m != nil {
		return m.FrontPingMs
	}
	return 0
}

func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) GetE2EPingMs() uint32 {
	if m != nil {
		return m.E2EPingMs
	}
	return 0
}

type CMsgSteamDatagramClientSwitchedPrimary struct {
	ClientCookie          uint32                                                `protobuf:"fixed32,1,opt,name=client_cookie,json=clientCookie" json:"client_cookie"`
	FromIp                uint32                                                `protobuf:"fixed32,2,opt,name=from_ip,json=fromIp" json:"from_ip"`
	FromPort              uint32                                                `protobuf:"varint,3,opt,name=from_port,json=fromPort" json:"from_port"`
	FromRouterCluster     uint32                                                `protobuf:"fixed32,4,opt,name=from_router_cluster,json=fromRouterCluster" json:"from_router_cluster"`
	FromActiveTime        uint32                                                `protobuf:"varint,5,opt,name=from_active_time,json=fromActiveTime" json:"from_active_time"`
	FromActivePacketsRecv uint32                                                `protobuf:"varint,6,opt,name=from_active_packets_recv,json=fromActivePacketsRecv" json:"from_active_packets_recv"`
	FromDroppedReason     string                                                `protobuf:"bytes,7,opt,name=from_dropped_reason,json=fromDroppedReason" json:"from_dropped_reason"`
	GapMs                 uint32                                                `protobuf:"varint,8,opt,name=gap_ms,json=gapMs" json:"gap_ms"`
	FromQualityNow        *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality `protobuf:"bytes,9,opt,name=from_quality_now,json=fromQualityNow" json:"from_quality_now,omitempty"`
	ToQualityNow          *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality `protobuf:"bytes,10,opt,name=to_quality_now,json=toQualityNow" json:"to_quality_now,omitempty"`
	FromQualityThen       *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality `protobuf:"bytes,11,opt,name=from_quality_then,json=fromQualityThen" json:"from_quality_then,omitempty"`
	ToQualityThen         *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality `protobuf:"bytes,12,opt,name=to_quality_then,json=toQualityThen" json:"to_quality_then,omitempty"`
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) Reset() {
	*m = CMsgSteamDatagramClientSwitchedPrimary{}
}
func (m *CMsgSteamDatagramClientSwitchedPrimary) String() string { return proto.CompactTextString(m) }
func (*CMsgSteamDatagramClientSwitchedPrimary) ProtoMessage()    {}
func (*CMsgSteamDatagramClientSwitchedPrimary) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{17}
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetClientCookie() uint32 {
	if m != nil {
		return m.ClientCookie
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromIp() uint32 {
	if m != nil {
		return m.FromIp
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromPort() uint32 {
	if m != nil {
		return m.FromPort
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromRouterCluster() uint32 {
	if m != nil {
		return m.FromRouterCluster
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromActiveTime() uint32 {
	if m != nil {
		return m.FromActiveTime
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromActivePacketsRecv() uint32 {
	if m != nil {
		return m.FromActivePacketsRecv
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromDroppedReason() string {
	if m != nil {
		return m.FromDroppedReason
	}
	return ""
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetGapMs() uint32 {
	if m != nil {
		return m.GapMs
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromQualityNow() *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	if m != nil {
		return m.FromQualityNow
	}
	return nil
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetToQualityNow() *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	if m != nil {
		return m.ToQualityNow
	}
	return nil
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetFromQualityThen() *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	if m != nil {
		return m.FromQualityThen
	}
	return nil
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) GetToQualityThen() *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	if m != nil {
		return m.ToQualityThen
	}
	return nil
}

type CMsgSteamDatagramClientSwitchedPrimary_RouterQuality struct {
	Score            uint32 `protobuf:"varint,1,opt,name=score" json:"score"`
	FrontPing        uint32 `protobuf:"varint,2,opt,name=front_ping,json=frontPing" json:"front_ping"`
	BackPing         uint32 `protobuf:"varint,3,opt,name=back_ping,json=backPing" json:"back_ping"`
	SecondsUntilDown uint32 `protobuf:"varint,4,opt,name=seconds_until_down,json=secondsUntilDown" json:"seconds_until_down"`
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) Reset() {
	*m = CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
}
func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) ProtoMessage() {}
func (*CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) Descriptor() ([]byte, []int) {
	return fileDescriptorSteamdatagramMessages, []int{17, 0}
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) GetFrontPing() uint32 {
	if m != nil {
		return m.FrontPing
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) GetBackPing() uint32 {
	if m != nil {
		return m.BackPing
	}
	return 0
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) GetSecondsUntilDown() uint32 {
	if m != nil {
		return m.SecondsUntilDown
	}
	return 0
}

func init() {
	proto.RegisterType((*CMsgSteamDatagramRouterPingReply)(nil), "CMsgSteamDatagramRouterPingReply")
	proto.RegisterType((*CMsgSteamDatagramGameserverPing)(nil), "CMsgSteamDatagramGameserverPing")
	proto.RegisterType((*CMsgSteamDatagramGameServerAuthTicket)(nil), "CMsgSteamDatagramGameServerAuthTicket")
	proto.RegisterType((*CMsgSteamDatagramGameServerAuthTicket_ExtraField)(nil), "CMsgSteamDatagramGameServerAuthTicket.ExtraField")
	proto.RegisterType((*CMsgSteamDatagramGameserverSessionRequest)(nil), "CMsgSteamDatagramGameserverSessionRequest")
	proto.RegisterType((*CMsgSteamDatagramGameserverSessionEstablished)(nil), "CMsgSteamDatagramGameserverSessionEstablished")
	proto.RegisterType((*CMsgSteamDatagramNoSession)(nil), "CMsgSteamDatagramNoSession")
	proto.RegisterType((*CMsgSteamDatagramDiagnostic)(nil), "CMsgSteamDatagramDiagnostic")
	proto.RegisterType((*CMsgSteamDatagramDataCenterState)(nil), "CMsgSteamDatagramDataCenterState")
	proto.RegisterType((*CMsgSteamDatagramDataCenterState_Server)(nil), "CMsgSteamDatagramDataCenterState.Server")
	proto.RegisterType((*CMsgSteamDatagramDataCenterState_DataCenter)(nil), "CMsgSteamDatagramDataCenterState.DataCenter")
	proto.RegisterType((*CMsgSteamDatagramLinkInstantaneousStats)(nil), "CMsgSteamDatagramLinkInstantaneousStats")
	proto.RegisterType((*CMsgSteamDatagramLinkLifetimeStats)(nil), "CMsgSteamDatagramLinkLifetimeStats")
	proto.RegisterType((*CMsgSteamDatagramConnectionQuality)(nil), "CMsgSteamDatagramConnectionQuality")
	proto.RegisterType((*CMsgSteamDatagramConnectionStatsClientToRouter)(nil), "CMsgSteamDatagramConnectionStatsClientToRouter")
	proto.RegisterType((*CMsgSteamDatagramConnectionStatsRouterToClient)(nil), "CMsgSteamDatagramConnectionStatsRouterToClient")
	proto.RegisterType((*CMsgSteamDatagramConnectionStatsRouterToServer)(nil), "CMsgSteamDatagramConnectionStatsRouterToServer")
	proto.RegisterType((*CMsgSteamDatagramConnectionStatsServerToRouter)(nil), "CMsgSteamDatagramConnectionStatsServerToRouter")
	proto.RegisterType((*CMsgSteamDatagramClientPingSampleRequest)(nil), "CMsgSteamDatagramClientPingSampleRequest")
	proto.RegisterType((*CMsgSteamDatagramClientPingSampleReply)(nil), "CMsgSteamDatagramClientPingSampleReply")
	proto.RegisterType((*CMsgSteamDatagramClientPingSampleReply_RoutingCluster)(nil), "CMsgSteamDatagramClientPingSampleReply.RoutingCluster")
	proto.RegisterType((*CMsgSteamDatagramClientSwitchedPrimary)(nil), "CMsgSteamDatagramClientSwitchedPrimary")
	proto.RegisterType((*CMsgSteamDatagramClientSwitchedPrimary_RouterQuality)(nil), "CMsgSteamDatagramClientSwitchedPrimary.RouterQuality")
	proto.RegisterEnum("ESteamDatagramMsgID", ESteamDatagramMsgID_name, ESteamDatagramMsgID_value)
}
func (m *CMsgSteamDatagramRouterPingReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramRouterPingReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientTimestamp))
	if len(m.LatencyDatacenterIds) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.LatencyDatacenterIds)*4))
		for _, num := range m.LatencyDatacenterIds {
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
		}
	}
	if len(m.LatencyPingMs) > 0 {
		dAtA2 := make([]byte, len(m.LatencyPingMs)*10)
		var j1 int
		for _, num := range m.LatencyPingMs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	dAtA[i] = 0x25
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.YourPublicIp))
	dAtA[i] = 0x2d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ServerTime))
	dAtA[i] = 0x31
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.Challenge))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SecondsUntilShutdown))
	dAtA[i] = 0x45
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	return i, nil
}

func (m *CMsgSteamDatagramGameserverPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramGameserverPing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.ClientSession))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.ClientSteamId))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientTimestamp))
	dAtA[i] = 0x25
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.RouterTimestamp))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.RouterGameserverLatency))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumberRouter))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumberE2E))
	return i, nil
}

func (m *CMsgSteamDatagramGameServerAuthTicket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramGameServerAuthTicket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.TimeExpiry))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.AuthorizedSteamId))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.AuthorizedPublicIp))
	dAtA[i] = 0x21
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.GameserverSteamId))
	dAtA[i] = 0x29
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.GameserverNetId))
	if m.Signature != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.AppId))
	if len(m.ExtraFields) > 0 {
		for _, msg := range m.ExtraFields {
			dAtA[i] = 0x42
			i++
			i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.StringValue)))
	i += copy(dAtA[i:], m.StringValue)
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64((uint32(m.Int32Value)<<1)^uint32((m.Int32Value>>31))))
	dAtA[i] = 0x25
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.Fixed32Value))
	dAtA[i] = 0x29
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.Fixed64Value))
	return i, nil
}

func (m *CMsgSteamDatagramGameserverSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramGameserverSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ticket != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.Ticket.Size()))
		n3, err := m.Ticket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ChallengeTime))
	dAtA[i] = 0x21
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.Challenge))
	dAtA[i] = 0x2d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	return i, nil
}

func (m *CMsgSteamDatagramGameserverSessionEstablished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramGameserverSessionEstablished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	dAtA[i] = 0x19
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.GameserverSteamId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SecondsUntilShutdown))
	return i, nil
}

func (m *CMsgSteamDatagramNoSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramNoSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x15
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.YourPublicIp))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ServerTime))
	dAtA[i] = 0x21
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.Challenge))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SecondsUntilShutdown))
	dAtA[i] = 0x3d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	return i, nil
}

func (m *CMsgSteamDatagramDiagnostic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramDiagnostic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.Severity))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}

func (m *CMsgSteamDatagramDataCenterState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramDataCenterState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataCenters) > 0 {
		for _, msg := range m.DataCenters {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgSteamDatagramDataCenterState_Server) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramDataCenterState_Server) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PingMs))
	return i, nil
}

func (m *CMsgSteamDatagramDataCenterState_DataCenter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramDataCenterState_DataCenter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.Code)))
	i += copy(dAtA[i:], m.Code)
	if len(m.ServerSample) > 0 {
		for _, msg := range m.ServerSample {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.OutPacketsPerSecX10))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.OutBytesPerSec))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.InPacketsPerSecX10))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.InBytesPerSec))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PingMs))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsDroppedPct))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsWeirdSequencePct))
	return i, nil
}

func (m *CMsgSteamDatagramLinkLifetimeStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramLinkLifetimeStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsSent))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.KbSent))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsRecv))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.KbRecv))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsRecvSequenced))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsRecvDropped))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsRecvOutOfOrder))
	dAtA[i] = 0x50
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsRecvDuplicate))
	dAtA[i] = 0x58
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.PacketsRecvLurch))
	return i, nil
}

func (m *CMsgSteamDatagramConnectionQuality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramConnectionQuality) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Instantaneous != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.Instantaneous.Size()))
		n4, err := m.Instantaneous.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Lifetime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.Lifetime.Size()))
		n5, err := m.Lifetime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.C2R != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.C2R.Size()))
		n6, err := m.C2R.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.C2S != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.C2S.Size()))
		n7, err := m.C2S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientTimestamp))
	dAtA[i] = 0x45
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumC2R))
	dAtA[i] = 0x50
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumC2S))
	return i, nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.R2C != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.R2C.Size()))
		n8, err := m.R2C.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.S2C != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.S2C.Size()))
		n9, err := m.S2C.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientTimestampFromRouter))
	dAtA[i] = 0x25
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientTimestampFromServer))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.RouterGameserverLatency))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SecondsUntilShutdown))
	dAtA[i] = 0x3d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumR2C))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumS2C))
	return i, nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.R2S != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.R2S.Size()))
		n10, err := m.R2S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.C2S != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.C2S.Size()))
		n11, err := m.C2S.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientTimestamp))
	dAtA[i] = 0x25
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.RouterTimestamp))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumR2S))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumC2S))
	dAtA[i] = 0x39
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.ClientSteamId))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.ClientSessionId))
	return i, nil
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.S2R != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.S2R.Size()))
		n12, err := m.S2R.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.S2C != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.S2C.Size()))
		n13, err := m.S2C.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumS2R))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SeqNumS2C))
	dAtA[i] = 0x29
	i++
	i = encodeFixed64SteamdatagramMessages(dAtA, i, uint64(m.ClientSteamId))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.ClientSessionId))
	return i, nil
}

func (m *CMsgSteamDatagramClientPingSampleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramClientPingSampleRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	return i, nil
}

func (m *CMsgSteamDatagramClientPingSampleReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramClientPingSampleReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	if len(m.RoutingClusters) > 0 {
		for _, msg := range m.RoutingClusters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.FrontPingMs))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.E2EPingMs))
	return i, nil
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.ClientCookie))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.FromIp))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.FromPort))
	dAtA[i] = 0x25
	i++
	i = encodeFixed32SteamdatagramMessages(dAtA, i, uint32(m.FromRouterCluster))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.FromActiveTime))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.FromActivePacketsRecv))
	dAtA[i] = 0x3a
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(len(m.FromDroppedReason)))
	i += copy(dAtA[i:], m.FromDroppedReason)
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.GapMs))
	if m.FromQualityNow != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.FromQualityNow.Size()))
		n14, err := m.FromQualityNow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.ToQualityNow != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.ToQualityNow.Size()))
		n15, err := m.ToQualityNow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.FromQualityThen != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.FromQualityThen.Size()))
		n16, err := m.FromQualityThen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.ToQualityThen != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.ToQualityThen.Size()))
		n17, err := m.ToQualityThen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.Score))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.FrontPing))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.BackPing))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteamdatagramMessages(dAtA, i, uint64(m.SecondsUntilDown))
	return i, nil
}

func encodeFixed64SteamdatagramMessages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32SteamdatagramMessages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSteamdatagramMessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CMsgSteamDatagramRouterPingReply) Size() (n int) {
	var l int
	_ = l
	n += 5
	if len(m.LatencyDatacenterIds) > 0 {
		n += 1 + sovSteamdatagramMessages(uint64(len(m.LatencyDatacenterIds)*4)) + len(m.LatencyDatacenterIds)*4
	}
	if len(m.LatencyPingMs) > 0 {
		l = 0
		for _, e := range m.LatencyPingMs {
			l += sovSteamdatagramMessages(uint64(e))
		}
		n += 1 + sovSteamdatagramMessages(uint64(l)) + l
	}
	n += 5
	n += 5
	n += 9
	n += 1 + sovSteamdatagramMessages(uint64(m.SecondsUntilShutdown))
	n += 5
	return n
}

func (m *CMsgSteamDatagramGameserverPing) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteamdatagramMessages(uint64(m.ClientSession))
	n += 9
	n += 5
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.RouterGameserverLatency))
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumberRouter))
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumberE2E))
	return n
}

func (m *CMsgSteamDatagramGameServerAuthTicket) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 9
	n += 5
	n += 9
	n += 9
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	n += 1 + sovSteamdatagramMessages(uint64(m.AppId))
	if len(m.ExtraFields) > 0 {
		for _, e := range m.ExtraFields {
			l = e.Size()
			n += 1 + l + sovSteamdatagramMessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteamdatagramMessages(uint64(l))
	l = len(m.StringValue)
	n += 1 + l + sovSteamdatagramMessages(uint64(l))
	n += 1 + sozSteamdatagramMessages(uint64(m.Int32Value))
	n += 5
	n += 9
	return n
}

func (m *CMsgSteamDatagramGameserverSessionRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ticket != nil {
		l = m.Ticket.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	n += 5
	n += 9
	n += 5
	return n
}

func (m *CMsgSteamDatagramGameserverSessionEstablished) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 9
	n += 1 + sovSteamdatagramMessages(uint64(m.SecondsUntilShutdown))
	return n
}

func (m *CMsgSteamDatagramNoSession) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 9
	n += 1 + sovSteamdatagramMessages(uint64(m.SecondsUntilShutdown))
	n += 5
	return n
}

func (m *CMsgSteamDatagramDiagnostic) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteamdatagramMessages(uint64(m.Severity))
	l = len(m.Text)
	n += 1 + l + sovSteamdatagramMessages(uint64(l))
	return n
}

func (m *CMsgSteamDatagramDataCenterState) Size() (n int) {
	var l int
	_ = l
	if len(m.DataCenters) > 0 {
		for _, e := range m.DataCenters {
			l = e.Size()
			n += 1 + l + sovSteamdatagramMessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgSteamDatagramDataCenterState_Server) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovSteamdatagramMessages(uint64(l))
	n += 1 + sovSteamdatagramMessages(uint64(m.PingMs))
	return n
}

func (m *CMsgSteamDatagramDataCenterState_DataCenter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Code)
	n += 1 + l + sovSteamdatagramMessages(uint64(l))
	if len(m.ServerSample) > 0 {
		for _, e := range m.ServerSample {
			l = e.Size()
			n += 1 + l + sovSteamdatagramMessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgSteamDatagramLinkInstantaneousStats) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteamdatagramMessages(uint64(m.OutPacketsPerSecX10))
	n += 1 + sovSteamdatagramMessages(uint64(m.OutBytesPerSec))
	n += 1 + sovSteamdatagramMessages(uint64(m.InPacketsPerSecX10))
	n += 1 + sovSteamdatagramMessages(uint64(m.InBytesPerSec))
	n += 1 + sovSteamdatagramMessages(uint64(m.PingMs))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsDroppedPct))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsWeirdSequencePct))
	return n
}

func (m *CMsgSteamDatagramLinkLifetimeStats) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsSent))
	n += 1 + sovSteamdatagramMessages(uint64(m.KbSent))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsRecv))
	n += 1 + sovSteamdatagramMessages(uint64(m.KbRecv))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsRecvSequenced))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsRecvDropped))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsRecvOutOfOrder))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsRecvDuplicate))
	n += 1 + sovSteamdatagramMessages(uint64(m.PacketsRecvLurch))
	return n
}

func (m *CMsgSteamDatagramConnectionQuality) Size() (n int) {
	var l int
	_ = l
	if m.Instantaneous != nil {
		l = m.Instantaneous.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.Lifetime != nil {
		l = m.Lifetime.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	return n
}

func (m *CMsgSteamDatagramConnectionStatsClientToRouter) Size() (n int) {
	var l int
	_ = l
	if m.C2R != nil {
		l = m.C2R.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.C2S != nil {
		l = m.C2S.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	n += 5
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumC2R))
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumC2S))
	return n
}

func (m *CMsgSteamDatagramConnectionStatsRouterToClient) Size() (n int) {
	var l int
	_ = l
	if m.R2C != nil {
		l = m.R2C.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.S2C != nil {
		l = m.S2C.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	n += 5
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.RouterGameserverLatency))
	n += 1 + sovSteamdatagramMessages(uint64(m.SecondsUntilShutdown))
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumR2C))
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumS2C))
	return n
}

func (m *CMsgSteamDatagramConnectionStatsRouterToServer) Size() (n int) {
	var l int
	_ = l
	if m.R2S != nil {
		l = m.R2S.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.C2S != nil {
		l = m.C2S.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	n += 5
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumR2S))
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumC2S))
	n += 9
	n += 1 + sovSteamdatagramMessages(uint64(m.ClientSessionId))
	return n
}

func (m *CMsgSteamDatagramConnectionStatsServerToRouter) Size() (n int) {
	var l int
	_ = l
	if m.S2R != nil {
		l = m.S2R.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.S2C != nil {
		l = m.S2C.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumS2R))
	n += 1 + sovSteamdatagramMessages(uint64(m.SeqNumS2C))
	n += 9
	n += 1 + sovSteamdatagramMessages(uint64(m.ClientSessionId))
	return n
}

func (m *CMsgSteamDatagramClientPingSampleRequest) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}

func (m *CMsgSteamDatagramClientPingSampleReply) Size() (n int) {
	var l int
	_ = l
	n += 5
	if len(m.RoutingClusters) > 0 {
		for _, e := range m.RoutingClusters {
			l = e.Size()
			n += 1 + l + sovSteamdatagramMessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.FrontPingMs))
	n += 1 + sovSteamdatagramMessages(uint64(m.E2EPingMs))
	return n
}

func (m *CMsgSteamDatagramClientSwitchedPrimary) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.FromPort))
	n += 5
	n += 1 + sovSteamdatagramMessages(uint64(m.FromActiveTime))
	n += 1 + sovSteamdatagramMessages(uint64(m.FromActivePacketsRecv))
	l = len(m.FromDroppedReason)
	n += 1 + l + sovSteamdatagramMessages(uint64(l))
	n += 1 + sovSteamdatagramMessages(uint64(m.GapMs))
	if m.FromQualityNow != nil {
		l = m.FromQualityNow.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.ToQualityNow != nil {
		l = m.ToQualityNow.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.FromQualityThen != nil {
		l = m.FromQualityThen.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	if m.ToQualityThen != nil {
		l = m.ToQualityThen.Size()
		n += 1 + l + sovSteamdatagramMessages(uint64(l))
	}
	return n
}

func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteamdatagramMessages(uint64(m.Score))
	n += 1 + sovSteamdatagramMessages(uint64(m.FrontPing))
	n += 1 + sovSteamdatagramMessages(uint64(m.BackPing))
	n += 1 + sovSteamdatagramMessages(uint64(m.SecondsUntilDown))
	return n
}

func sovSteamdatagramMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSteamdatagramMessages(x uint64) (n int) {
	return sovSteamdatagramMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CMsgSteamDatagramRouterPingReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramRouterPingReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramRouterPingReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimestamp", wireType)
			}
			m.ClientTimestamp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientTimestamp = uint32(dAtA[iNdEx-4])
			m.ClientTimestamp |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientTimestamp |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientTimestamp |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				m.LatencyDatacenterIds = append(m.LatencyDatacenterIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteamdatagramMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteamdatagramMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					m.LatencyDatacenterIds = append(m.LatencyDatacenterIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyDatacenterIds", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteamdatagramMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LatencyPingMs = append(m.LatencyPingMs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteamdatagramMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteamdatagramMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteamdatagramMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LatencyPingMs = append(m.LatencyPingMs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyPingMs", wireType)
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourPublicIp", wireType)
			}
			m.YourPublicIp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.YourPublicIp = uint32(dAtA[iNdEx-4])
			m.YourPublicIp |= uint32(dAtA[iNdEx-3]) << 8
			m.YourPublicIp |= uint32(dAtA[iNdEx-2]) << 16
			m.YourPublicIp |= uint32(dAtA[iNdEx-1]) << 24
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ServerTime = uint32(dAtA[iNdEx-4])
			m.ServerTime |= uint32(dAtA[iNdEx-3]) << 8
			m.ServerTime |= uint32(dAtA[iNdEx-2]) << 16
			m.ServerTime |= uint32(dAtA[iNdEx-1]) << 24
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			m.Challenge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Challenge = uint64(dAtA[iNdEx-8])
			m.Challenge |= uint64(dAtA[iNdEx-7]) << 8
			m.Challenge |= uint64(dAtA[iNdEx-6]) << 16
			m.Challenge |= uint64(dAtA[iNdEx-5]) << 24
			m.Challenge |= uint64(dAtA[iNdEx-4]) << 32
			m.Challenge |= uint64(dAtA[iNdEx-3]) << 40
			m.Challenge |= uint64(dAtA[iNdEx-2]) << 48
			m.Challenge |= uint64(dAtA[iNdEx-1]) << 56
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsUntilShutdown", wireType)
			}
			m.SecondsUntilShutdown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondsUntilShutdown |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramGameserverPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameserverPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameserverPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSession", wireType)
			}
			m.ClientSession = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSession |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSteamId", wireType)
			}
			m.ClientSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ClientSteamId = uint64(dAtA[iNdEx-8])
			m.ClientSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.ClientSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.ClientSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.ClientSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.ClientSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.ClientSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.ClientSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimestamp", wireType)
			}
			m.ClientTimestamp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientTimestamp = uint32(dAtA[iNdEx-4])
			m.ClientTimestamp |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientTimestamp |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientTimestamp |= uint32(dAtA[iNdEx-1]) << 24
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterTimestamp", wireType)
			}
			m.RouterTimestamp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.RouterTimestamp = uint32(dAtA[iNdEx-4])
			m.RouterTimestamp |= uint32(dAtA[iNdEx-3]) << 8
			m.RouterTimestamp |= uint32(dAtA[iNdEx-2]) << 16
			m.RouterTimestamp |= uint32(dAtA[iNdEx-1]) << 24
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterGameserverLatency", wireType)
			}
			m.RouterGameserverLatency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterGameserverLatency |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumberRouter", wireType)
			}
			m.SeqNumberRouter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumberRouter |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumberE2E", wireType)
			}
			m.SeqNumberE2E = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumberE2E |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramGameServerAuthTicket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameServerAuthTicket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameServerAuthTicket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeExpiry", wireType)
			}
			m.TimeExpiry = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.TimeExpiry = uint32(dAtA[iNdEx-4])
			m.TimeExpiry |= uint32(dAtA[iNdEx-3]) << 8
			m.TimeExpiry |= uint32(dAtA[iNdEx-2]) << 16
			m.TimeExpiry |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedSteamId", wireType)
			}
			m.AuthorizedSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.AuthorizedSteamId = uint64(dAtA[iNdEx-8])
			m.AuthorizedSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.AuthorizedSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.AuthorizedSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.AuthorizedSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.AuthorizedSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.AuthorizedSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.AuthorizedSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedPublicIp", wireType)
			}
			m.AuthorizedPublicIp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.AuthorizedPublicIp = uint32(dAtA[iNdEx-4])
			m.AuthorizedPublicIp |= uint32(dAtA[iNdEx-3]) << 8
			m.AuthorizedPublicIp |= uint32(dAtA[iNdEx-2]) << 16
			m.AuthorizedPublicIp |= uint32(dAtA[iNdEx-1]) << 24
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameserverSteamId", wireType)
			}
			m.GameserverSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.GameserverSteamId = uint64(dAtA[iNdEx-8])
			m.GameserverSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.GameserverSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.GameserverSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.GameserverSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.GameserverSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.GameserverSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.GameserverSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameserverNetId", wireType)
			}
			m.GameserverNetId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.GameserverNetId = uint64(dAtA[iNdEx-8])
			m.GameserverNetId |= uint64(dAtA[iNdEx-7]) << 8
			m.GameserverNetId |= uint64(dAtA[iNdEx-6]) << 16
			m.GameserverNetId |= uint64(dAtA[iNdEx-5]) << 24
			m.GameserverNetId |= uint64(dAtA[iNdEx-4]) << 32
			m.GameserverNetId |= uint64(dAtA[iNdEx-3]) << 40
			m.GameserverNetId |= uint64(dAtA[iNdEx-2]) << 48
			m.GameserverNetId |= uint64(dAtA[iNdEx-1]) << 56
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraFields = append(m.ExtraFields, &CMsgSteamDatagramGameServerAuthTicket_ExtraField{})
			if err := m.ExtraFields[len(m.ExtraFields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramGameServerAuthTicket_ExtraField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Value", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Int32Value = v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32Value", wireType)
			}
			m.Fixed32Value = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Fixed32Value = uint32(dAtA[iNdEx-4])
			m.Fixed32Value |= uint32(dAtA[iNdEx-3]) << 8
			m.Fixed32Value |= uint32(dAtA[iNdEx-2]) << 16
			m.Fixed32Value |= uint32(dAtA[iNdEx-1]) << 24
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64Value", wireType)
			}
			m.Fixed64Value = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Fixed64Value = uint64(dAtA[iNdEx-8])
			m.Fixed64Value |= uint64(dAtA[iNdEx-7]) << 8
			m.Fixed64Value |= uint64(dAtA[iNdEx-6]) << 16
			m.Fixed64Value |= uint64(dAtA[iNdEx-5]) << 24
			m.Fixed64Value |= uint64(dAtA[iNdEx-4]) << 32
			m.Fixed64Value |= uint64(dAtA[iNdEx-3]) << 40
			m.Fixed64Value |= uint64(dAtA[iNdEx-2]) << 48
			m.Fixed64Value |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramGameserverSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameserverSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameserverSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ticket == nil {
				m.Ticket = &CMsgSteamDatagramGameServerAuthTicket{}
			}
			if err := m.Ticket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTime", wireType)
			}
			m.ChallengeTime = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ChallengeTime = uint32(dAtA[iNdEx-4])
			m.ChallengeTime |= uint32(dAtA[iNdEx-3]) << 8
			m.ChallengeTime |= uint32(dAtA[iNdEx-2]) << 16
			m.ChallengeTime |= uint32(dAtA[iNdEx-1]) << 24
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			m.Challenge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Challenge = uint64(dAtA[iNdEx-8])
			m.Challenge |= uint64(dAtA[iNdEx-7]) << 8
			m.Challenge |= uint64(dAtA[iNdEx-6]) << 16
			m.Challenge |= uint64(dAtA[iNdEx-5]) << 24
			m.Challenge |= uint64(dAtA[iNdEx-4]) << 32
			m.Challenge |= uint64(dAtA[iNdEx-3]) << 40
			m.Challenge |= uint64(dAtA[iNdEx-2]) << 48
			m.Challenge |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramGameserverSessionEstablished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameserverSessionEstablished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramGameserverSessionEstablished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameserverSteamId", wireType)
			}
			m.GameserverSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.GameserverSteamId = uint64(dAtA[iNdEx-8])
			m.GameserverSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.GameserverSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.GameserverSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.GameserverSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.GameserverSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.GameserverSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.GameserverSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsUntilShutdown", wireType)
			}
			m.SecondsUntilShutdown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondsUntilShutdown |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramNoSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramNoSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramNoSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourPublicIp", wireType)
			}
			m.YourPublicIp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.YourPublicIp = uint32(dAtA[iNdEx-4])
			m.YourPublicIp |= uint32(dAtA[iNdEx-3]) << 8
			m.YourPublicIp |= uint32(dAtA[iNdEx-2]) << 16
			m.YourPublicIp |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ServerTime = uint32(dAtA[iNdEx-4])
			m.ServerTime |= uint32(dAtA[iNdEx-3]) << 8
			m.ServerTime |= uint32(dAtA[iNdEx-2]) << 16
			m.ServerTime |= uint32(dAtA[iNdEx-1]) << 24
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			m.Challenge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Challenge = uint64(dAtA[iNdEx-8])
			m.Challenge |= uint64(dAtA[iNdEx-7]) << 8
			m.Challenge |= uint64(dAtA[iNdEx-6]) << 16
			m.Challenge |= uint64(dAtA[iNdEx-5]) << 24
			m.Challenge |= uint64(dAtA[iNdEx-4]) << 32
			m.Challenge |= uint64(dAtA[iNdEx-3]) << 40
			m.Challenge |= uint64(dAtA[iNdEx-2]) << 48
			m.Challenge |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsUntilShutdown", wireType)
			}
			m.SecondsUntilShutdown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondsUntilShutdown |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramDiagnostic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramDiagnostic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramDiagnostic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramDataCenterState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramDataCenterState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramDataCenterState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCenters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataCenters = append(m.DataCenters, &CMsgSteamDatagramDataCenterState_DataCenter{})
			if err := m.DataCenters[len(m.DataCenters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramDataCenterState_Server) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingMs", wireType)
			}
			m.PingMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramDataCenterState_DataCenter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataCenter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataCenter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSample", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerSample = append(m.ServerSample, &CMsgSteamDatagramDataCenterState_Server{})
			if err := m.ServerSample[len(m.ServerSample)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramLinkInstantaneousStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramLinkInstantaneousStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramLinkInstantaneousStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPacketsPerSecX10", wireType)
			}
			m.OutPacketsPerSecX10 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPacketsPerSecX10 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutBytesPerSec", wireType)
			}
			m.OutBytesPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutBytesPerSec |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPacketsPerSecX10", wireType)
			}
			m.InPacketsPerSecX10 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPacketsPerSecX10 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InBytesPerSec", wireType)
			}
			m.InBytesPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InBytesPerSec |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingMs", wireType)
			}
			m.PingMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsDroppedPct", wireType)
			}
			m.PacketsDroppedPct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsDroppedPct |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsWeirdSequencePct", wireType)
			}
			m.PacketsWeirdSequencePct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsWeirdSequencePct |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramLinkLifetimeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramLinkLifetimeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramLinkLifetimeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsSent", wireType)
			}
			m.PacketsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbSent", wireType)
			}
			m.KbSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KbSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRecv", wireType)
			}
			m.PacketsRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRecv |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbRecv", wireType)
			}
			m.KbRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KbRecv |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRecvSequenced", wireType)
			}
			m.PacketsRecvSequenced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRecvSequenced |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRecvDropped", wireType)
			}
			m.PacketsRecvDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRecvDropped |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRecvOutOfOrder", wireType)
			}
			m.PacketsRecvOutOfOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRecvOutOfOrder |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRecvDuplicate", wireType)
			}
			m.PacketsRecvDuplicate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRecvDuplicate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsRecvLurch", wireType)
			}
			m.PacketsRecvLurch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsRecvLurch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramConnectionQuality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionQuality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionQuality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instantaneous", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instantaneous == nil {
				m.Instantaneous = &CMsgSteamDatagramLinkInstantaneousStats{}
			}
			if err := m.Instantaneous.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lifetime == nil {
				m.Lifetime = &CMsgSteamDatagramLinkLifetimeStats{}
			}
			if err := m.Lifetime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramConnectionStatsClientToRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsClientToRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsClientToRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2R", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C2R == nil {
				m.C2R = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.C2R.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C2S == nil {
				m.C2S = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.C2S.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimestamp", wireType)
			}
			m.ClientTimestamp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientTimestamp = uint32(dAtA[iNdEx-4])
			m.ClientTimestamp |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientTimestamp |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientTimestamp |= uint32(dAtA[iNdEx-1]) << 24
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumC2R", wireType)
			}
			m.SeqNumC2R = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumC2R |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumC2S", wireType)
			}
			m.SeqNumC2S = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumC2S |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramConnectionStatsRouterToClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsRouterToClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsRouterToClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R2C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R2C == nil {
				m.R2C = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.R2C.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S2C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S2C == nil {
				m.S2C = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.S2C.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimestampFromRouter", wireType)
			}
			m.ClientTimestampFromRouter = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientTimestampFromRouter = uint32(dAtA[iNdEx-4])
			m.ClientTimestampFromRouter |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientTimestampFromRouter |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientTimestampFromRouter |= uint32(dAtA[iNdEx-1]) << 24
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimestampFromServer", wireType)
			}
			m.ClientTimestampFromServer = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientTimestampFromServer = uint32(dAtA[iNdEx-4])
			m.ClientTimestampFromServer |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientTimestampFromServer |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientTimestampFromServer |= uint32(dAtA[iNdEx-1]) << 24
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterGameserverLatency", wireType)
			}
			m.RouterGameserverLatency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouterGameserverLatency |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsUntilShutdown", wireType)
			}
			m.SecondsUntilShutdown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondsUntilShutdown |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumR2C", wireType)
			}
			m.SeqNumR2C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumR2C |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumS2C", wireType)
			}
			m.SeqNumS2C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumS2C |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramConnectionStatsRouterToServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsRouterToServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsRouterToServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R2S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R2S == nil {
				m.R2S = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.R2S.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C2S == nil {
				m.C2S = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.C2S.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimestamp", wireType)
			}
			m.ClientTimestamp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientTimestamp = uint32(dAtA[iNdEx-4])
			m.ClientTimestamp |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientTimestamp |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientTimestamp |= uint32(dAtA[iNdEx-1]) << 24
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterTimestamp", wireType)
			}
			m.RouterTimestamp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.RouterTimestamp = uint32(dAtA[iNdEx-4])
			m.RouterTimestamp |= uint32(dAtA[iNdEx-3]) << 8
			m.RouterTimestamp |= uint32(dAtA[iNdEx-2]) << 16
			m.RouterTimestamp |= uint32(dAtA[iNdEx-1]) << 24
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumR2S", wireType)
			}
			m.SeqNumR2S = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumR2S |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumC2S", wireType)
			}
			m.SeqNumC2S = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumC2S |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSteamId", wireType)
			}
			m.ClientSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ClientSteamId = uint64(dAtA[iNdEx-8])
			m.ClientSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.ClientSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.ClientSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.ClientSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.ClientSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.ClientSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.ClientSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSessionId", wireType)
			}
			m.ClientSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSessionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramConnectionStatsServerToRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsServerToRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramConnectionStatsServerToRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S2R", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S2R == nil {
				m.S2R = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.S2R.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S2C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S2C == nil {
				m.S2C = &CMsgSteamDatagramConnectionQuality{}
			}
			if err := m.S2C.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumS2R", wireType)
			}
			m.SeqNumS2R = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumS2R |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumS2C", wireType)
			}
			m.SeqNumS2C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumS2C |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSteamId", wireType)
			}
			m.ClientSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ClientSteamId = uint64(dAtA[iNdEx-8])
			m.ClientSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.ClientSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.ClientSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.ClientSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.ClientSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.ClientSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.ClientSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSessionId", wireType)
			}
			m.ClientSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSessionId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramClientPingSampleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramClientPingSampleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramClientPingSampleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramClientPingSampleReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramClientPingSampleReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramClientPingSampleReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingClusters = append(m.RoutingClusters, &CMsgSteamDatagramClientPingSampleReply_RoutingCluster{})
			if err := m.RoutingClusters[len(m.RoutingClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramClientPingSampleReply_RoutingCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutingCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutingCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Id = uint32(dAtA[iNdEx-4])
			m.Id |= uint32(dAtA[iNdEx-3]) << 8
			m.Id |= uint32(dAtA[iNdEx-2]) << 16
			m.Id |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontPingMs", wireType)
			}
			m.FrontPingMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontPingMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2EPingMs", wireType)
			}
			m.E2EPingMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.E2EPingMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramClientSwitchedPrimary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSteamDatagramClientSwitchedPrimary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSteamDatagramClientSwitchedPrimary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCookie", wireType)
			}
			m.ClientCookie = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ClientCookie = uint32(dAtA[iNdEx-4])
			m.ClientCookie |= uint32(dAtA[iNdEx-3]) << 8
			m.ClientCookie |= uint32(dAtA[iNdEx-2]) << 16
			m.ClientCookie |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromIp", wireType)
			}
			m.FromIp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.FromIp = uint32(dAtA[iNdEx-4])
			m.FromIp |= uint32(dAtA[iNdEx-3]) << 8
			m.FromIp |= uint32(dAtA[iNdEx-2]) << 16
			m.FromIp |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPort", wireType)
			}
			m.FromPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromRouterCluster", wireType)
			}
			m.FromRouterCluster = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.FromRouterCluster = uint32(dAtA[iNdEx-4])
			m.FromRouterCluster |= uint32(dAtA[iNdEx-3]) << 8
			m.FromRouterCluster |= uint32(dAtA[iNdEx-2]) << 16
			m.FromRouterCluster |= uint32(dAtA[iNdEx-1]) << 24
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromActiveTime", wireType)
			}
			m.FromActiveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromActiveTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromActivePacketsRecv", wireType)
			}
			m.FromActivePacketsRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromActivePacketsRecv |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromDroppedReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromDroppedReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GapMs", wireType)
			}
			m.GapMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GapMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromQualityNow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromQualityNow == nil {
				m.FromQualityNow = &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
			}
			if err := m.FromQualityNow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToQualityNow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToQualityNow == nil {
				m.ToQualityNow = &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
			}
			if err := m.ToQualityNow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromQualityThen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromQualityThen == nil {
				m.FromQualityThen = &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
			}
			if err := m.FromQualityThen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToQualityThen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToQualityThen == nil {
				m.ToQualityThen = &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
			}
			if err := m.ToQualityThen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouterQuality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouterQuality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontPing", wireType)
			}
			m.FrontPing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontPing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackPing", wireType)
			}
			m.BackPing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackPing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsUntilDown", wireType)
			}
			m.SecondsUntilDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondsUntilDown |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteamdatagramMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteamdatagramMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSteamdatagramMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSteamdatagramMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSteamdatagramMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSteamdatagramMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSteamdatagramMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSteamdatagramMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSteamdatagramMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSteamdatagramMessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("steamdatagram_messages.proto", fileDescriptorSteamdatagramMessages) }

var fileDescriptorSteamdatagramMessages = []byte{
	// 2179 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0xdf, 0xf9, 0xb6, 0xdf, 0xcc, 0x78, 0xda, 0x15, 0x6f, 0x32, 0x71, 0x36, 0x5e, 0xef, 0x64,
	0x13, 0xdb, 0xf9, 0x98, 0x38, 0x4d, 0x12, 0xa1, 0x48, 0x2c, 0x24, 0xb6, 0x77, 0x65, 0x29, 0x76,
	0x86, 0xb1, 0x97, 0x0f, 0x21, 0xd4, 0x6a, 0x77, 0x97, 0xc7, 0x2d, 0xcf, 0x74, 0x77, 0xaa, 0xaa,
	0xfd, 0xc1, 0x89, 0x33, 0x27, 0x6e, 0x9c, 0x39, 0x71, 0x41, 0x5c, 0x10, 0xe2, 0x3f, 0x40, 0x2b,
	0xb4, 0x07, 0x8e, 0x88, 0x03, 0x42, 0xe1, 0xc0, 0xff, 0xc0, 0x01, 0xa1, 0xaa, 0xea, 0xee, 0xa9,
	0xf2, 0xf4, 0xd8, 0x33, 0x1b, 0xc4, 0x29, 0x99, 0x7e, 0xbf, 0xf7, 0xea, 0x7d, 0xbf, 0x57, 0x65,
	0xf8, 0x88, 0x32, 0x6c, 0x0f, 0x5c, 0x9b, 0xd9, 0x3d, 0x62, 0x0f, 0xac, 0x01, 0xa6, 0xd4, 0xee,
	0x61, 0xda, 0x0e, 0x49, 0xc0, 0x82, 0xd6, 0xaf, 0x0a, 0xb0, 0xbc, 0xb1, 0x43, 0x7b, 0x7b, 0x1c,
	0xb4, 0x19, 0x83, 0xba, 0x41, 0xc4, 0x30, 0xe9, 0x78, 0x7e, 0xaf, 0x8b, 0xc3, 0xfe, 0x39, 0x7a,
	0x0c, 0x86, 0xd3, 0xf7, 0xb0, 0xcf, 0x2c, 0xe6, 0x0d, 0x30, 0x65, 0xf6, 0x20, 0x6c, 0xe6, 0x96,
	0x73, 0xab, 0x95, 0x57, 0xc5, 0xaf, 0xfe, 0xfe, 0xf1, 0x07, 0xdd, 0x86, 0xa4, 0xee, 0x27, 0x44,
	0xf4, 0x6d, 0xb8, 0xde, 0xb7, 0x19, 0xf6, 0x9d, 0x73, 0x8b, 0x1f, 0xec, 0x60, 0x9f, 0x61, 0x62,
	0x79, 0x2e, 0x6d, 0xe6, 0x97, 0x0b, 0xab, 0x95, 0x57, 0x79, 0x23, 0xd7, 0x5d, 0x88, 0x11, 0x9b,
	0x29, 0x60, 0xdb, 0xa5, 0xe8, 0x3e, 0x34, 0x12, 0xce, 0xd0, 0xf3, 0x7b, 0xd6, 0x80, 0x36, 0x0b,
	0xcb, 0x85, 0xd5, 0xba, 0x60, 0xa9, 0xc7, 0x24, 0xae, 0xd9, 0x0e, 0xc7, 0xce, 0x9d, 0x07, 0x11,
	0xb1, 0xc2, 0xe8, 0xa0, 0xef, 0x39, 0x96, 0x17, 0x36, 0x8b, 0x8a, 0x52, 0x35, 0x4e, 0xeb, 0x08,
	0xd2, 0x76, 0x88, 0xee, 0x42, 0x95, 0x62, 0x72, 0x82, 0x89, 0x30, 0xa1, 0x59, 0x52, 0x80, 0x20,
	0x09, 0x5c, 0x7b, 0xd4, 0x82, 0x59, 0xe7, 0xc8, 0xee, 0xf7, 0xb1, 0xdf, 0xc3, 0xcd, 0xf2, 0x72,
	0x6e, 0xb5, 0x1c, 0x83, 0x86, 0x9f, 0xd1, 0x0b, 0xb8, 0x4e, 0xb1, 0x13, 0xf8, 0x2e, 0xb5, 0x22,
	0x9f, 0x79, 0x7d, 0x8b, 0x1e, 0x45, 0xcc, 0x0d, 0x4e, 0xfd, 0x66, 0x65, 0x39, 0xb7, 0x5a, 0x8f,
	0x19, 0x16, 0x62, 0xcc, 0x97, 0x1c, 0xb2, 0x17, 0x23, 0xd0, 0x1a, 0xd4, 0x63, 0x4f, 0x3a, 0x41,
	0x70, 0xec, 0xe1, 0xe6, 0x8c, 0xaa, 0xb1, 0x24, 0x6d, 0x08, 0x4a, 0xeb, 0x3f, 0x79, 0xf8, 0x78,
	0x24, 0x32, 0x5f, 0xd8, 0x03, 0x2c, 0xd5, 0xe5, 0x3e, 0x40, 0x0f, 0x60, 0x2e, 0x16, 0x47, 0x31,
	0xa5, 0x5e, 0xe0, 0x8b, 0xb0, 0x24, 0x2a, 0xc4, 0x47, 0xed, 0x49, 0x12, 0x7a, 0x08, 0x8d, 0x04,
	0xcc, 0x45, 0x5a, 0x9e, 0xdb, 0xcc, 0x2b, 0x16, 0x26, 0x68, 0x4e, 0xdb, 0x76, 0x33, 0x63, 0x5e,
	0xb8, 0x2c, 0xe6, 0x8f, 0xc1, 0x20, 0x22, 0x6f, 0x14, 0x06, 0x35, 0x1e, 0x0d, 0x49, 0x1d, 0x32,
	0x7c, 0x0f, 0x6e, 0xc6, 0x0c, 0xbd, 0xd4, 0x2a, 0x2b, 0x8e, 0xb0, 0x08, 0x50, 0x62, 0xc7, 0x0d,
	0x09, 0x1b, 0xda, 0xfe, 0x5a, 0x82, 0xd0, 0x3a, 0xcc, 0x53, 0xfc, 0xd6, 0xf2, 0xa3, 0xc1, 0x01,
	0x26, 0x96, 0x44, 0x89, 0xa8, 0x25, 0x9c, 0x0d, 0x8a, 0xdf, 0xee, 0x0a, 0xaa, 0x4c, 0x69, 0x9e,
	0x32, 0x0a, 0x07, 0x36, 0xb1, 0x16, 0xb3, 0x5a, 0x0a, 0xdf, 0x32, 0x71, 0xeb, 0x17, 0x25, 0xb8,
	0x9b, 0x19, 0x80, 0x3d, 0xa1, 0xc4, 0xcb, 0x88, 0x1d, 0xed, 0x7b, 0xce, 0x31, 0x66, 0x3c, 0xb9,
	0xb8, 0xcd, 0x16, 0x3e, 0x0b, 0x3d, 0x72, 0xae, 0x95, 0x06, 0x70, 0xc2, 0x96, 0xf8, 0x8e, 0x9e,
	0xc2, 0x35, 0x3b, 0x62, 0x47, 0x01, 0xf1, 0x7e, 0x86, 0xdd, 0xec, 0x20, 0xcc, 0x0f, 0x01, 0x49,
	0x20, 0x9e, 0xc3, 0x82, 0xc2, 0x35, 0xcc, 0x75, 0x35, 0x18, 0x68, 0x88, 0x48, 0x33, 0xfe, 0x29,
	0x5c, 0x53, 0xfc, 0x9a, 0x9e, 0x56, 0x54, 0x4f, 0x1b, 0x02, 0x92, 0xd3, 0xd6, 0x41, 0xf9, 0x68,
	0xf9, 0x98, 0x71, 0x9e, 0x92, 0xc2, 0xd3, 0x18, 0x92, 0x77, 0x31, 0xdb, 0x76, 0x79, 0xc9, 0x50,
	0xaf, 0xe7, 0xdb, 0x2c, 0x22, 0xb2, 0x64, 0x6a, 0x49, 0xc9, 0xa4, 0x9f, 0xd1, 0x2d, 0x28, 0xdb,
	0x61, 0xc8, 0x45, 0xa9, 0xee, 0x2e, 0xd9, 0x61, 0xb8, 0xed, 0xa2, 0x7d, 0xa8, 0xe1, 0x33, 0x46,
	0x6c, 0xeb, 0xd0, 0xc3, 0x7d, 0x97, 0x36, 0x67, 0x96, 0x0b, 0xab, 0x55, 0xf3, 0x49, 0x7b, 0x22,
	0xdf, 0xb7, 0xb7, 0x38, 0xeb, 0xe7, 0x9c, 0xb3, 0x5b, 0xc5, 0xe9, 0xff, 0xe9, 0xe2, 0xd7, 0x39,
	0x80, 0x21, 0x0d, 0x35, 0xa1, 0xe8, 0xdb, 0x03, 0x2c, 0x62, 0x33, 0x1b, 0x9f, 0x2f, 0xbe, 0xa0,
	0x15, 0xa8, 0x51, 0x46, 0x78, 0xaf, 0x39, 0xb1, 0xfb, 0x11, 0x16, 0xe1, 0x48, 0x10, 0x55, 0x49,
	0xf9, 0x01, 0x27, 0xf0, 0x28, 0x7b, 0x3e, 0xfb, 0x96, 0x19, 0xe3, 0xb8, 0xff, 0xe7, 0x93, 0x28,
	0x0b, 0x82, 0x84, 0xad, 0x41, 0xfd, 0xd0, 0x3b, 0xc3, 0x6e, 0x0a, 0xd4, 0x9a, 0x52, 0x4c, 0xd2,
	0xa1, 0xcf, 0x9f, 0xc6, 0x50, 0xd5, 0xd1, 0xb5, 0x98, 0x24, 0xa0, 0xad, 0x7f, 0xe5, 0x60, 0xed,
	0x92, 0x6e, 0x10, 0xd7, 0x78, 0x17, 0xbf, 0x8d, 0x30, 0x65, 0xe8, 0x33, 0x28, 0x33, 0xe1, 0x1e,
	0x61, 0x6f, 0xd5, 0xbc, 0x37, 0x99, 0x33, 0xbb, 0x31, 0x97, 0xe8, 0x2b, 0x49, 0xbf, 0x93, 0x0d,
	0x53, 0xcd, 0xb6, 0x7a, 0x4a, 0x1b, 0xed, 0x99, 0xc5, 0xec, 0x9e, 0x39, 0xd2, 0xf7, 0x4a, 0x63,
	0xfb, 0xde, 0xd7, 0x39, 0x78, 0x74, 0xb5, 0xa5, 0x5b, 0x94, 0xd9, 0x07, 0x7d, 0x8f, 0x1e, 0x61,
	0x77, 0x54, 0x78, 0x6e, 0x9c, 0xf0, 0x71, 0x45, 0x51, 0xb8, 0xbc, 0x28, 0xc6, 0x77, 0xfc, 0xe2,
	0x55, 0x1d, 0xbf, 0xf5, 0xef, 0x1c, 0x2c, 0x8e, 0x98, 0xb3, 0x1b, 0x24, 0x4d, 0x79, 0x74, 0x86,
	0xe5, 0x27, 0x9d, 0x61, 0x85, 0x49, 0x66, 0x58, 0x71, 0xda, 0x19, 0x56, 0x9a, 0x7e, 0x86, 0x55,
	0xc6, 0xc6, 0xf2, 0xc7, 0x70, 0x6b, 0xc4, 0xf6, 0x4d, 0xcf, 0xee, 0xf9, 0x01, 0x65, 0x9e, 0x83,
	0x96, 0x61, 0x86, 0xe2, 0x13, 0x4c, 0x3c, 0x76, 0xae, 0x0d, 0xae, 0xf4, 0x2b, 0x2f, 0x5b, 0x86,
	0xcf, 0x98, 0x56, 0x94, 0xe2, 0x4b, 0xeb, 0xf7, 0xf9, 0x8c, 0xc5, 0x85, 0xff, 0xbb, 0x21, 0x76,
	0x89, 0x3d, 0x66, 0x33, 0x8c, 0xde, 0x40, 0x8d, 0xef, 0x1f, 0x96, 0xdc, 0x2f, 0x68, 0x33, 0x27,
	0x5a, 0xcb, 0xc3, 0xf6, 0x55, 0x8c, 0xed, 0xe1, 0xef, 0x6e, 0xd5, 0x4d, 0xff, 0x4f, 0x17, 0xbf,
	0x80, 0xb2, 0x2c, 0x1a, 0xb4, 0x04, 0x15, 0xdb, 0x75, 0x09, 0xa6, 0x54, 0xeb, 0x29, 0xc9, 0x47,
	0x74, 0x1b, 0x2a, 0xc9, 0x02, 0x93, 0x57, 0x4c, 0x2b, 0x87, 0x62, 0x77, 0x59, 0x8c, 0x00, 0x86,
	0x67, 0x70, 0x33, 0x9d, 0xc0, 0xbd, 0xd0, 0x9d, 0xf8, 0x17, 0xb4, 0x03, 0xf5, 0x24, 0x59, 0xed,
	0x41, 0xd8, 0xc7, 0x62, 0x81, 0xaa, 0x9a, 0xab, 0x57, 0x9b, 0x20, 0xf5, 0xe4, 0x33, 0x4d, 0xa4,
	0xb2, 0xe0, 0xe6, 0xeb, 0xde, 0xca, 0x08, 0xe7, 0x6b, 0xcf, 0x3f, 0xde, 0xf6, 0x29, 0xb3, 0x7d,
	0x66, 0xfb, 0x38, 0x88, 0x28, 0x17, 0x40, 0xd1, 0x0b, 0xb8, 0x11, 0x44, 0xcc, 0x0a, 0x6d, 0xde,
	0x12, 0xa8, 0x15, 0x72, 0x1d, 0xb0, 0x63, 0x9d, 0x3d, 0x59, 0xd7, 0x82, 0x75, 0x2d, 0x88, 0x58,
	0x47, 0x62, 0x3a, 0xbc, 0x3c, 0x9d, 0x1f, 0x3d, 0x59, 0x47, 0x8f, 0x61, 0x9e, 0xf3, 0x1e, 0x9c,
	0x33, 0x9c, 0x72, 0x6a, 0x7e, 0x98, 0x0b, 0x22, 0xf6, 0x8a, 0x53, 0x25, 0x0f, 0xdf, 0x18, 0x3d,
	0x3f, 0xf3, 0xac, 0x82, 0xc2, 0x85, 0x3c, 0x7f, 0xe4, 0xa8, 0x47, 0x60, 0x78, 0xfe, 0x85, 0x93,
	0xd4, 0xb2, 0xac, 0x7b, 0xbe, 0x7a, 0x90, 0x12, 0x97, 0xd2, 0x68, 0x5c, 0x78, 0x83, 0x48, 0x94,
	0x70, 0x49, 0x10, 0x86, 0x7c, 0xe4, 0x3a, 0x4c, 0x5b, 0x2a, 0xe6, 0x63, 0xc0, 0xa6, 0xa4, 0x77,
	0x1c, 0x86, 0x5e, 0xc2, 0x62, 0xc2, 0x75, 0x8a, 0x3d, 0xe2, 0x5a, 0x94, 0x37, 0x62, 0xdf, 0xc1,
	0x82, 0x59, 0x9d, 0x79, 0x37, 0x62, 0xdc, 0x0f, 0x39, 0x6c, 0x2f, 0x46, 0x75, 0x1c, 0xd6, 0xfa,
	0x6b, 0x01, 0x5a, 0x99, 0x91, 0x79, 0xed, 0x1d, 0x62, 0x5e, 0xef, 0x32, 0x28, 0x2b, 0x50, 0x4b,
	0x4e, 0xa2, 0xd8, 0x67, 0xc2, 0x3b, 0xc5, 0x64, 0x5a, 0xc5, 0x94, 0x3d, 0xec, 0x33, 0x6e, 0xe7,
	0xf1, 0x81, 0xc4, 0x14, 0x15, 0x4c, 0xf9, 0xf8, 0x40, 0x90, 0x15, 0x39, 0x04, 0x3b, 0x27, 0xc2,
	0x17, 0x17, 0xe5, 0x74, 0xb1, 0x73, 0x12, 0xcb, 0x11, 0x98, 0xb2, 0x2e, 0x47, 0x90, 0x5f, 0xc0,
	0x75, 0x55, 0x4e, 0x6a, 0xb8, 0x9c, 0xf4, 0x09, 0x7a, 0x41, 0x91, 0x98, 0x18, 0x2d, 0x36, 0x1b,
	0x8d, 0x37, 0x76, 0xb8, 0xd8, 0x89, 0x13, 0x4e, 0xa4, 0x70, 0xc6, 0x0e, 0x47, 0x9f, 0xc1, 0x4d,
	0x8d, 0x8f, 0x67, 0x5a, 0x70, 0x68, 0x05, 0xc4, 0xc5, 0xa4, 0x39, 0xab, 0x30, 0x7f, 0xa8, 0x30,
	0xbf, 0x89, 0xd8, 0x9b, 0xc3, 0x37, 0x1c, 0x32, 0xa2, 0xb3, 0x1b, 0x85, 0x7d, 0xcf, 0xb1, 0x19,
	0x6e, 0xc2, 0x18, 0x9d, 0x37, 0x13, 0x04, 0x32, 0x01, 0x69, 0xbc, 0xfd, 0x88, 0x38, 0x47, 0xcd,
	0xaa, 0xc2, 0x67, 0x28, 0x7c, 0xaf, 0x39, 0xb5, 0xf5, 0x87, 0x5c, 0x46, 0x68, 0x37, 0x02, 0xdf,
	0xc7, 0x0e, 0xf3, 0x02, 0xff, 0xfb, 0x91, 0xdd, 0xe7, 0xbd, 0x6e, 0x17, 0xea, 0x9e, 0x5a, 0x85,
	0xf1, 0xec, 0xce, 0x28, 0xf5, 0xec, 0x82, 0xed, 0xea, 0xec, 0xe8, 0xbb, 0x30, 0xd3, 0x8f, 0x73,
	0x47, 0x94, 0x5e, 0xd5, 0xbc, 0xd3, 0xbe, 0x3a, 0xc3, 0xba, 0x29, 0x53, 0xeb, 0x4f, 0x79, 0x68,
	0x5f, 0xa2, 0xb7, 0x80, 0x6f, 0xc8, 0x5b, 0x40, 0x10, 0xef, 0xd7, 0xcf, 0xa0, 0xe0, 0x98, 0x24,
	0xd6, 0xfc, 0x4e, 0xfb, 0x6a, 0xab, 0xbb, 0x1c, 0x2f, 0xd9, 0xe8, 0x78, 0x2d, 0x33, 0xd9, 0xe8,
	0xf4, 0x77, 0x94, 0xc9, 0xaf, 0x5f, 0xe8, 0x53, 0x3e, 0x6c, 0xc5, 0x4d, 0xc1, 0xe2, 0x16, 0xcd,
	0x2a, 0x35, 0x3c, 0x2b, 0xaf, 0x09, 0x1b, 0x26, 0xd1, 0x51, 0x54, 0xe4, 0xcf, 0x08, 0x8a, 0xb6,
	0x7e, 0x5d, 0xbc, 0xda, 0x91, 0xd2, 0x81, 0xfb, 0x81, 0x74, 0x28, 0xf7, 0x08, 0x31, 0x9d, 0xa9,
	0x1c, 0x49, 0x4c, 0x87, 0xb3, 0x51, 0xd3, 0x99, 0xca, 0x91, 0xd4, 0x74, 0xd0, 0x16, 0x7c, 0x74,
	0xd1, 0x91, 0xd6, 0x21, 0x09, 0x06, 0xc9, 0x9d, 0x4a, 0x75, 0xea, 0xcd, 0x0b, 0x4e, 0xfd, 0x9c,
	0x04, 0xf1, 0x83, 0xc1, 0x78, 0x31, 0x72, 0x06, 0x69, 0x9b, 0x70, 0x96, 0x98, 0x78, 0xb4, 0xbe,
	0xff, 0xc5, 0x70, 0xfc, 0x7a, 0x53, 0xfe, 0x1f, 0xae, 0x37, 0x6a, 0xf4, 0x79, 0xb0, 0x66, 0x46,
	0xa3, 0xdf, 0x35, 0x1d, 0x15, 0xc5, 0x63, 0x93, 0x91, 0x49, 0x7b, 0xa6, 0xd3, 0xfa, 0x6d, 0x61,
	0xf2, 0x1c, 0x89, 0xfd, 0x24, 0x72, 0x84, 0x4e, 0x99, 0x23, 0xf4, 0xff, 0x56, 0x6c, 0x53, 0x3f,
	0x08, 0x68, 0xee, 0xd4, 0xc7, 0x73, 0xea, 0x4e, 0x7a, 0xb1, 0xe4, 0xca, 0x99, 0x25, 0x97, 0xf5,
	0xd8, 0x51, 0x19, 0xff, 0xd8, 0xb1, 0x0e, 0xf3, 0xfa, 0x3b, 0x0a, 0xc7, 0xab, 0xe1, 0x6c, 0x68,
	0x4f, 0x29, 0xdb, 0x6e, 0xeb, 0xcf, 0x13, 0xf4, 0x46, 0x19, 0x26, 0xb5, 0x37, 0xd2, 0x29, 0x7b,
	0x23, 0x35, 0xc9, 0x37, 0x2d, 0x69, 0x2d, 0xeb, 0x88, 0xb6, 0x45, 0xa5, 0x59, 0x47, 0x2e, 0xe6,
	0x66, 0x31, 0x33, 0x37, 0xb3, 0x9c, 0x59, 0x9a, 0xd2, 0x99, 0xe5, 0xcb, 0x9c, 0xf9, 0x25, 0xac,
	0x8e, 0x9a, 0x25, 0x30, 0x1d, 0xcf, 0xef, 0xc9, 0xd5, 0x35, 0xb9, 0xda, 0x4e, 0x7e, 0xd9, 0x6b,
	0xfd, 0x2e, 0x0f, 0xf7, 0x26, 0x90, 0x1b, 0xf6, 0xcf, 0xa7, 0xb9, 0x42, 0xda, 0x32, 0xad, 0xf9,
	0x0e, 0xe9, 0xf4, 0x23, 0x2a, 0xee, 0x15, 0x72, 0x29, 0x7f, 0xde, 0x9e, 0xec, 0xb4, 0x76, 0x57,
	0xf2, 0x6f, 0x48, 0x76, 0x59, 0x08, 0xc3, 0xdf, 0x74, 0xf1, 0x04, 0xe6, 0x74, 0x08, 0x5a, 0x80,
	0xbc, 0xe7, 0x6a, 0x4a, 0xe5, 0x3d, 0x17, 0xad, 0x42, 0xfd, 0x90, 0x04, 0x3e, 0xb3, 0xb2, 0x6e,
	0x1a, 0x55, 0x41, 0x8a, 0x9f, 0x4a, 0x3f, 0x85, 0x2a, 0x36, 0xb1, 0xf2, 0xa4, 0xaa, 0xc4, 0x19,
	0x9b, 0x58, 0xa2, 0x5a, 0x7f, 0xac, 0x8c, 0x75, 0xd8, 0xde, 0xa9, 0xc7, 0x9c, 0x23, 0xec, 0x76,
	0x88, 0x37, 0xb0, 0xc9, 0x54, 0x0e, 0xbb, 0x0d, 0x15, 0x31, 0x04, 0x2e, 0xdc, 0x6d, 0xcb, 0xfc,
	0xe3, 0x76, 0x88, 0x3e, 0x81, 0x59, 0x41, 0x0e, 0x03, 0xc2, 0x34, 0xc5, 0x66, 0xf8, 0xe7, 0x4e,
	0x40, 0x18, 0x5f, 0xca, 0x95, 0x69, 0x94, 0xb8, 0x5d, 0x6b, 0x26, 0xf3, 0x87, 0xe9, 0x18, 0x4a,
	0x7c, 0xd6, 0x06, 0x43, 0x70, 0xd9, 0x0e, 0xf3, 0x4e, 0xf0, 0xf0, 0xdd, 0x37, 0xbd, 0x82, 0x70,
	0xea, 0x4b, 0x41, 0x14, 0xf7, 0xe6, 0xef, 0x40, 0x53, 0xc5, 0x6b, 0xeb, 0xb1, 0x9a, 0xbe, 0x1f,
	0x0e, 0xf9, 0x3a, 0xca, 0xa2, 0x9c, 0x28, 0x99, 0x5c, 0x1b, 0x08, 0xb6, 0x69, 0x20, 0xdf, 0x84,
	0x67, 0x55, 0x25, 0xe3, 0x2d, 0xb6, 0x2b, 0xc8, 0xe8, 0x16, 0x94, 0x7b, 0x76, 0xc8, 0x63, 0xa2,
	0xb6, 0x9b, 0x52, 0xcf, 0x0e, 0x77, 0x28, 0xb2, 0x62, 0x0b, 0xde, 0xca, 0xc2, 0xb6, 0xfc, 0xe0,
	0x54, 0x8c, 0x8f, 0xaa, 0xf9, 0xac, 0x3d, 0x59, 0x9c, 0xda, 0xd2, 0x25, 0x49, 0x67, 0x10, 0x26,
	0xc7, 0x3f, 0x76, 0x83, 0x53, 0xf4, 0x13, 0x98, 0x63, 0x81, 0x26, 0x1e, 0xde, 0x47, 0x7c, 0x8d,
	0x05, 0x8a, 0x70, 0x1b, 0xe6, 0x35, 0xed, 0xd9, 0x11, 0xf6, 0xc5, 0xa6, 0xfc, 0x8d, 0xe5, 0x37,
	0x14, 0xf5, 0xf7, 0x8f, 0xb0, 0x8f, 0x7e, 0x0a, 0x0d, 0x45, 0x7f, 0x71, 0x40, 0xed, 0x7d, 0x0e,
	0xa8, 0xa7, 0x06, 0x70, 0xf1, 0x8b, 0xbf, 0xc9, 0x41, 0x5d, 0x03, 0xa0, 0x45, 0x28, 0x51, 0x27,
	0x20, 0x58, 0xbb, 0x01, 0xcb, 0x4f, 0xe8, 0x0e, 0xc0, 0xb0, 0x1a, 0xb5, 0x52, 0x9c, 0x4d, 0x4b,
	0x91, 0x67, 0xfb, 0x81, 0xed, 0x1c, 0x4b, 0x8c, 0x96, 0xed, 0xfc, 0xb3, 0x80, 0x98, 0x80, 0xf4,
	0xe5, 0x65, 0xe4, 0xa5, 0xc9, 0x50, 0x17, 0x97, 0xcd, 0xe0, 0xd4, 0xbf, 0xff, 0xb7, 0x12, 0x5c,
	0xdb, 0xd2, 0xcc, 0xdd, 0xa1, 0xbd, 0xed, 0x4d, 0xb4, 0x06, 0x77, 0x8f, 0xad, 0x11, 0x82, 0xa5,
	0xfe, 0x81, 0x47, 0xb4, 0x55, 0x23, 0x87, 0x56, 0xe0, 0xce, 0x55, 0xd0, 0xb0, 0x7f, 0x6e, 0xe4,
	0xd1, 0x23, 0x58, 0xcb, 0x02, 0xea, 0x7f, 0x9a, 0x48, 0xe4, 0x16, 0xd0, 0x03, 0x58, 0x99, 0x04,
	0xce, 0x65, 0x17, 0xd1, 0x3a, 0x3c, 0xbc, 0x1c, 0xac, 0x3f, 0x74, 0x1a, 0x25, 0xf4, 0x14, 0xd6,
	0x27, 0xe2, 0x50, 0x1e, 0x0c, 0x8d, 0x32, 0xfa, 0x04, 0x6e, 0x67, 0x71, 0xa5, 0xef, 0x72, 0x46,
	0x05, 0xb5, 0x60, 0x29, 0x0b, 0x32, 0x7c, 0xbe, 0x32, 0x66, 0xd0, 0x7d, 0xb8, 0x97, 0x89, 0xb1,
	0x99, 0xad, 0x5f, 0x8c, 0x8c, 0xd9, 0xcb, 0xb0, 0xfa, 0x5e, 0x67, 0xc0, 0x65, 0x58, 0x7d, 0xa9,
	0x30, 0xaa, 0x93, 0xc8, 0x95, 0xba, 0x18, 0x35, 0x74, 0x1b, 0x6e, 0x66, 0x61, 0xc5, 0xb6, 0x62,
	0xd4, 0xd1, 0x63, 0x78, 0x90, 0x45, 0x1e, 0x33, 0x8a, 0x8d, 0xb9, 0x71, 0xa9, 0x90, 0x39, 0xf5,
	0x8c, 0x06, 0x7a, 0x06, 0x4f, 0xc6, 0xc3, 0x13, 0x93, 0x2e, 0x54, 0xa8, 0x61, 0xbc, 0xba, 0xf6,
	0xd5, 0xbb, 0xa5, 0xdc, 0x5f, 0xde, 0x2d, 0xe5, 0xfe, 0xf1, 0x6e, 0x29, 0xf7, 0xcb, 0x7f, 0x2e,
	0x7d, 0xf0, 0xf3, 0xdc, 0x07, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x44, 0x9f, 0x75, 0xa9, 0xd7,
	0x1c, 0x00, 0x00,
}
