// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: base_gcmessages.proto

/*
	Package base_gcmessages is a generated protocol buffer package.

	It is generated from these files:
		base_gcmessages.proto

	It has these top-level messages:
		CGCStorePurchaseInit_LineItem
		CMsgGCStorePurchaseInit
		CMsgGCStorePurchaseInitResponse
		CSOPartyInvite
		CSOLobbyInvite
		CMsgSystemBroadcast
		CMsgInviteToParty
		CMsgInvitationCreated
		CMsgPartyInviteResponse
		CMsgKickFromParty
		CMsgLeaveParty
		CMsgServerAvailable
		CMsgLANServerAvailable
		CSOEconGameAccountClient
		CSOItemCriteriaCondition
		CSOItemCriteria
		CSOItemRecipe
		CMsgDevNewItemRequest
		CMsgIncrementKillCountAttribute
		CMsgApplySticker
		CMsgApplyStatTrakSwap
		CMsgApplyStrangePart
		CMsgApplyPennantUpgrade
		CMsgApplyEggEssence
		CSOEconItemAttribute
		CSOEconItemEquipped
		CSOEconItem
		CMsgAdjustItemEquippedState
		CMsgSortItems
		CSOEconClaimCode
		CMsgStoreGetUserData
		CMsgStoreGetUserDataResponse
		CMsgUpdateItemSchema
		CMsgGCError
		CMsgRequestInventoryRefresh
		CMsgConVarValue
		CMsgReplicateConVars
		CMsgUseItem
		CMsgReplayUploadedToYouTube
		CMsgConsumableExhausted
		CMsgItemAcknowledged__DEPRECATED
		CMsgSetItemPositions
		CMsgGCReportAbuse
		CMsgGCReportAbuseResponse
		CMsgGCNameItemNotification
		CMsgGCClientDisplayNotification
		CMsgGCShowItemsPickedUp
		CMsgGCIncrementKillCountResponse
		CSOEconItemDropRateBonus
		CSOEconItemLeagueViewPass
		CSOEconItemEventTicket
		CMsgGCItemPreviewItemBoughtNotification
		CMsgGCStorePurchaseCancel
		CMsgGCStorePurchaseCancelResponse
		CMsgGCStorePurchaseFinalize
		CMsgGCStorePurchaseFinalizeResponse
		CMsgGCBannedWordListRequest
		CMsgGCRequestAnnouncements
		CMsgGCRequestAnnouncementsResponse
		CMsgGCBannedWord
		CMsgGCBannedWordListResponse
		CMsgGCToGCBannedWordListBroadcast
		CMsgGCToGCBannedWordListUpdated
		CSOEconDefaultEquippedDefinitionInstanceClient
		CMsgGCToGCDirtySDOCache
		CMsgGCToGCDirtyMultipleSDOCache
		CMsgGCCollectItem
		CMsgSDONoMemcached
		CMsgGCToGCUpdateSQLKeyValue
		CMsgGCToGCIsTrustedServer
		CMsgGCToGCIsTrustedServerResponse
		CMsgGCToGCBroadcastConsoleCommand
		CMsgGCServerVersionUpdated
		CMsgGCClientVersionUpdated
		CMsgGCToGCWebAPIAccountChanged
		CMsgGCToGCRequestPassportItemGrant
		CMsgGameServerInfo
*/
package base_gcmessages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "."

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EGCBaseMsg int32

const (
	EGCBaseMsg_k_EMsgGCSystemMessage            EGCBaseMsg = 4001
	EGCBaseMsg_k_EMsgGCReplicateConVars         EGCBaseMsg = 4002
	EGCBaseMsg_k_EMsgGCConVarUpdated            EGCBaseMsg = 4003
	EGCBaseMsg_k_EMsgGCInQueue                  EGCBaseMsg = 4008
	EGCBaseMsg_k_EMsgGCInviteToParty            EGCBaseMsg = 4501
	EGCBaseMsg_k_EMsgGCInvitationCreated        EGCBaseMsg = 4502
	EGCBaseMsg_k_EMsgGCPartyInviteResponse      EGCBaseMsg = 4503
	EGCBaseMsg_k_EMsgGCKickFromParty            EGCBaseMsg = 4504
	EGCBaseMsg_k_EMsgGCLeaveParty               EGCBaseMsg = 4505
	EGCBaseMsg_k_EMsgGCServerAvailable          EGCBaseMsg = 4506
	EGCBaseMsg_k_EMsgGCClientConnectToServer    EGCBaseMsg = 4507
	EGCBaseMsg_k_EMsgGCGameServerInfo           EGCBaseMsg = 4508
	EGCBaseMsg_k_EMsgGCError                    EGCBaseMsg = 4509
	EGCBaseMsg_k_EMsgGCReplay_UploadedToYouTube EGCBaseMsg = 4510
	EGCBaseMsg_k_EMsgGCLANServerAvailable       EGCBaseMsg = 4511
)

var EGCBaseMsg_name = map[int32]string{
	4001: "k_EMsgGCSystemMessage",
	4002: "k_EMsgGCReplicateConVars",
	4003: "k_EMsgGCConVarUpdated",
	4008: "k_EMsgGCInQueue",
	4501: "k_EMsgGCInviteToParty",
	4502: "k_EMsgGCInvitationCreated",
	4503: "k_EMsgGCPartyInviteResponse",
	4504: "k_EMsgGCKickFromParty",
	4505: "k_EMsgGCLeaveParty",
	4506: "k_EMsgGCServerAvailable",
	4507: "k_EMsgGCClientConnectToServer",
	4508: "k_EMsgGCGameServerInfo",
	4509: "k_EMsgGCError",
	4510: "k_EMsgGCReplay_UploadedToYouTube",
	4511: "k_EMsgGCLANServerAvailable",
}
var EGCBaseMsg_value = map[string]int32{
	"k_EMsgGCSystemMessage":            4001,
	"k_EMsgGCReplicateConVars":         4002,
	"k_EMsgGCConVarUpdated":            4003,
	"k_EMsgGCInQueue":                  4008,
	"k_EMsgGCInviteToParty":            4501,
	"k_EMsgGCInvitationCreated":        4502,
	"k_EMsgGCPartyInviteResponse":      4503,
	"k_EMsgGCKickFromParty":            4504,
	"k_EMsgGCLeaveParty":               4505,
	"k_EMsgGCServerAvailable":          4506,
	"k_EMsgGCClientConnectToServer":    4507,
	"k_EMsgGCGameServerInfo":           4508,
	"k_EMsgGCError":                    4509,
	"k_EMsgGCReplay_UploadedToYouTube": 4510,
	"k_EMsgGCLANServerAvailable":       4511,
}

func (x EGCBaseMsg) Enum() *EGCBaseMsg {
	p := new(EGCBaseMsg)
	*p = x
	return p
}
func (x EGCBaseMsg) String() string {
	return proto.EnumName(EGCBaseMsg_name, int32(x))
}
func (x *EGCBaseMsg) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EGCBaseMsg_value, data, "EGCBaseMsg")
	if err != nil {
		return err
	}
	*x = EGCBaseMsg(value)
	return nil
}
func (EGCBaseMsg) EnumDescriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{0} }

type EGCBaseProtoObjectTypes int32

const (
	EGCBaseProtoObjectTypes_k_EProtoObjectPartyInvite EGCBaseProtoObjectTypes = 1001
	EGCBaseProtoObjectTypes_k_EProtoObjectLobbyInvite EGCBaseProtoObjectTypes = 1002
)

var EGCBaseProtoObjectTypes_name = map[int32]string{
	1001: "k_EProtoObjectPartyInvite",
	1002: "k_EProtoObjectLobbyInvite",
}
var EGCBaseProtoObjectTypes_value = map[string]int32{
	"k_EProtoObjectPartyInvite": 1001,
	"k_EProtoObjectLobbyInvite": 1002,
}

func (x EGCBaseProtoObjectTypes) Enum() *EGCBaseProtoObjectTypes {
	p := new(EGCBaseProtoObjectTypes)
	*p = x
	return p
}
func (x EGCBaseProtoObjectTypes) String() string {
	return proto.EnumName(EGCBaseProtoObjectTypes_name, int32(x))
}
func (x *EGCBaseProtoObjectTypes) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EGCBaseProtoObjectTypes_value, data, "EGCBaseProtoObjectTypes")
	if err != nil {
		return err
	}
	*x = EGCBaseProtoObjectTypes(value)
	return nil
}
func (EGCBaseProtoObjectTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{1}
}

type GC_BannedWordType int32

const (
	GC_BannedWordType_GC_BANNED_WORD_DISABLE_WORD GC_BannedWordType = 0
	GC_BannedWordType_GC_BANNED_WORD_ENABLE_WORD  GC_BannedWordType = 1
)

var GC_BannedWordType_name = map[int32]string{
	0: "GC_BANNED_WORD_DISABLE_WORD",
	1: "GC_BANNED_WORD_ENABLE_WORD",
}
var GC_BannedWordType_value = map[string]int32{
	"GC_BANNED_WORD_DISABLE_WORD": 0,
	"GC_BANNED_WORD_ENABLE_WORD":  1,
}

func (x GC_BannedWordType) Enum() *GC_BannedWordType {
	p := new(GC_BannedWordType)
	*p = x
	return p
}
func (x GC_BannedWordType) String() string {
	return proto.EnumName(GC_BannedWordType_name, int32(x))
}
func (x *GC_BannedWordType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GC_BannedWordType_value, data, "GC_BannedWordType")
	if err != nil {
		return err
	}
	*x = GC_BannedWordType(value)
	return nil
}
func (GC_BannedWordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{2}
}

type CMsgGameServerInfo_ServerType int32

const (
	CMsgGameServerInfo_UNSPECIFIED CMsgGameServerInfo_ServerType = 0
	CMsgGameServerInfo_GAME        CMsgGameServerInfo_ServerType = 1
	CMsgGameServerInfo_PROXY       CMsgGameServerInfo_ServerType = 2
)

var CMsgGameServerInfo_ServerType_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "GAME",
	2: "PROXY",
}
var CMsgGameServerInfo_ServerType_value = map[string]int32{
	"UNSPECIFIED": 0,
	"GAME":        1,
	"PROXY":       2,
}

func (x CMsgGameServerInfo_ServerType) Enum() *CMsgGameServerInfo_ServerType {
	p := new(CMsgGameServerInfo_ServerType)
	*p = x
	return p
}
func (x CMsgGameServerInfo_ServerType) String() string {
	return proto.EnumName(CMsgGameServerInfo_ServerType_name, int32(x))
}
func (x *CMsgGameServerInfo_ServerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMsgGameServerInfo_ServerType_value, data, "CMsgGameServerInfo_ServerType")
	if err != nil {
		return err
	}
	*x = CMsgGameServerInfo_ServerType(value)
	return nil
}
func (CMsgGameServerInfo_ServerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{76, 0}
}

type CGCStorePurchaseInit_LineItem struct {
	ItemDefId           uint32 `protobuf:"varint,1,opt,name=item_def_id,json=itemDefId" json:"item_def_id"`
	Quantity            uint32 `protobuf:"varint,2,opt,name=quantity" json:"quantity"`
	CostInLocalCurrency uint32 `protobuf:"varint,3,opt,name=cost_in_local_currency,json=costInLocalCurrency" json:"cost_in_local_currency"`
	PurchaseType        uint32 `protobuf:"varint,4,opt,name=purchase_type,json=purchaseType" json:"purchase_type"`
}

func (m *CGCStorePurchaseInit_LineItem) Reset()         { *m = CGCStorePurchaseInit_LineItem{} }
func (m *CGCStorePurchaseInit_LineItem) String() string { return proto.CompactTextString(m) }
func (*CGCStorePurchaseInit_LineItem) ProtoMessage()    {}
func (*CGCStorePurchaseInit_LineItem) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{0}
}

func (m *CGCStorePurchaseInit_LineItem) GetItemDefId() uint32 {
	if m != nil {
		return m.ItemDefId
	}
	return 0
}

func (m *CGCStorePurchaseInit_LineItem) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *CGCStorePurchaseInit_LineItem) GetCostInLocalCurrency() uint32 {
	if m != nil {
		return m.CostInLocalCurrency
	}
	return 0
}

func (m *CGCStorePurchaseInit_LineItem) GetPurchaseType() uint32 {
	if m != nil {
		return m.PurchaseType
	}
	return 0
}

type CMsgGCStorePurchaseInit struct {
	Country   string                           `protobuf:"bytes,1,opt,name=country" json:"country"`
	Language  int32                            `protobuf:"varint,2,opt,name=language" json:"language"`
	Currency  int32                            `protobuf:"varint,3,opt,name=currency" json:"currency"`
	LineItems []*CGCStorePurchaseInit_LineItem `protobuf:"bytes,4,rep,name=line_items,json=lineItems" json:"line_items,omitempty"`
}

func (m *CMsgGCStorePurchaseInit) Reset()         { *m = CMsgGCStorePurchaseInit{} }
func (m *CMsgGCStorePurchaseInit) String() string { return proto.CompactTextString(m) }
func (*CMsgGCStorePurchaseInit) ProtoMessage()    {}
func (*CMsgGCStorePurchaseInit) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{1}
}

func (m *CMsgGCStorePurchaseInit) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *CMsgGCStorePurchaseInit) GetLanguage() int32 {
	if m != nil {
		return m.Language
	}
	return 0
}

func (m *CMsgGCStorePurchaseInit) GetCurrency() int32 {
	if m != nil {
		return m.Currency
	}
	return 0
}

func (m *CMsgGCStorePurchaseInit) GetLineItems() []*CGCStorePurchaseInit_LineItem {
	if m != nil {
		return m.LineItems
	}
	return nil
}

type CMsgGCStorePurchaseInitResponse struct {
	Result int32  `protobuf:"varint,1,opt,name=result" json:"result"`
	TxnId  uint64 `protobuf:"varint,2,opt,name=txn_id,json=txnId" json:"txn_id"`
}

func (m *CMsgGCStorePurchaseInitResponse) Reset()         { *m = CMsgGCStorePurchaseInitResponse{} }
func (m *CMsgGCStorePurchaseInitResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCStorePurchaseInitResponse) ProtoMessage()    {}
func (*CMsgGCStorePurchaseInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{2}
}

func (m *CMsgGCStorePurchaseInitResponse) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *CMsgGCStorePurchaseInitResponse) GetTxnId() uint64 {
	if m != nil {
		return m.TxnId
	}
	return 0
}

type CSOPartyInvite struct {
	GroupId    uint64 `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id"`
	SenderId   uint64 `protobuf:"fixed64,2,opt,name=sender_id,json=senderId" json:"sender_id"`
	SenderName string `protobuf:"bytes,3,opt,name=sender_name,json=senderName" json:"sender_name"`
}

func (m *CSOPartyInvite) Reset()                    { *m = CSOPartyInvite{} }
func (m *CSOPartyInvite) String() string            { return proto.CompactTextString(m) }
func (*CSOPartyInvite) ProtoMessage()               {}
func (*CSOPartyInvite) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{3} }

func (m *CSOPartyInvite) GetGroupId() uint64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CSOPartyInvite) GetSenderId() uint64 {
	if m != nil {
		return m.SenderId
	}
	return 0
}

func (m *CSOPartyInvite) GetSenderName() string {
	if m != nil {
		return m.SenderName
	}
	return ""
}

type CSOLobbyInvite struct {
	GroupId    uint64 `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id"`
	SenderId   uint64 `protobuf:"fixed64,2,opt,name=sender_id,json=senderId" json:"sender_id"`
	SenderName string `protobuf:"bytes,3,opt,name=sender_name,json=senderName" json:"sender_name"`
}

func (m *CSOLobbyInvite) Reset()                    { *m = CSOLobbyInvite{} }
func (m *CSOLobbyInvite) String() string            { return proto.CompactTextString(m) }
func (*CSOLobbyInvite) ProtoMessage()               {}
func (*CSOLobbyInvite) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{4} }

func (m *CSOLobbyInvite) GetGroupId() uint64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CSOLobbyInvite) GetSenderId() uint64 {
	if m != nil {
		return m.SenderId
	}
	return 0
}

func (m *CSOLobbyInvite) GetSenderName() string {
	if m != nil {
		return m.SenderName
	}
	return ""
}

type CMsgSystemBroadcast struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message"`
}

func (m *CMsgSystemBroadcast) Reset()         { *m = CMsgSystemBroadcast{} }
func (m *CMsgSystemBroadcast) String() string { return proto.CompactTextString(m) }
func (*CMsgSystemBroadcast) ProtoMessage()    {}
func (*CMsgSystemBroadcast) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{5}
}

func (m *CMsgSystemBroadcast) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type CMsgInviteToParty struct {
	SteamId       uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	ClientVersion uint32 `protobuf:"varint,2,opt,name=client_version,json=clientVersion" json:"client_version"`
	TeamInvite    uint32 `protobuf:"varint,3,opt,name=team_invite,json=teamInvite" json:"team_invite"`
}

func (m *CMsgInviteToParty) Reset()                    { *m = CMsgInviteToParty{} }
func (m *CMsgInviteToParty) String() string            { return proto.CompactTextString(m) }
func (*CMsgInviteToParty) ProtoMessage()               {}
func (*CMsgInviteToParty) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{6} }

func (m *CMsgInviteToParty) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgInviteToParty) GetClientVersion() uint32 {
	if m != nil {
		return m.ClientVersion
	}
	return 0
}

func (m *CMsgInviteToParty) GetTeamInvite() uint32 {
	if m != nil {
		return m.TeamInvite
	}
	return 0
}

type CMsgInvitationCreated struct {
	GroupId uint64 `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id"`
	SteamId uint64 `protobuf:"fixed64,2,opt,name=steam_id,json=steamId" json:"steam_id"`
}

func (m *CMsgInvitationCreated) Reset()         { *m = CMsgInvitationCreated{} }
func (m *CMsgInvitationCreated) String() string { return proto.CompactTextString(m) }
func (*CMsgInvitationCreated) ProtoMessage()    {}
func (*CMsgInvitationCreated) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{7}
}

func (m *CMsgInvitationCreated) GetGroupId() uint64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CMsgInvitationCreated) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

type CMsgPartyInviteResponse struct {
	PartyId       uint64 `protobuf:"varint,1,opt,name=party_id,json=partyId" json:"party_id"`
	Accept        bool   `protobuf:"varint,2,opt,name=accept" json:"accept"`
	ClientVersion uint32 `protobuf:"varint,3,opt,name=client_version,json=clientVersion" json:"client_version"`
	TeamInvite    uint32 `protobuf:"varint,4,opt,name=team_invite,json=teamInvite" json:"team_invite"`
}

func (m *CMsgPartyInviteResponse) Reset()         { *m = CMsgPartyInviteResponse{} }
func (m *CMsgPartyInviteResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgPartyInviteResponse) ProtoMessage()    {}
func (*CMsgPartyInviteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{8}
}

func (m *CMsgPartyInviteResponse) GetPartyId() uint64 {
	if m != nil {
		return m.PartyId
	}
	return 0
}

func (m *CMsgPartyInviteResponse) GetAccept() bool {
	if m != nil {
		return m.Accept
	}
	return false
}

func (m *CMsgPartyInviteResponse) GetClientVersion() uint32 {
	if m != nil {
		return m.ClientVersion
	}
	return 0
}

func (m *CMsgPartyInviteResponse) GetTeamInvite() uint32 {
	if m != nil {
		return m.TeamInvite
	}
	return 0
}

type CMsgKickFromParty struct {
	SteamId uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
}

func (m *CMsgKickFromParty) Reset()                    { *m = CMsgKickFromParty{} }
func (m *CMsgKickFromParty) String() string            { return proto.CompactTextString(m) }
func (*CMsgKickFromParty) ProtoMessage()               {}
func (*CMsgKickFromParty) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{9} }

func (m *CMsgKickFromParty) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

type CMsgLeaveParty struct {
}

func (m *CMsgLeaveParty) Reset()                    { *m = CMsgLeaveParty{} }
func (m *CMsgLeaveParty) String() string            { return proto.CompactTextString(m) }
func (*CMsgLeaveParty) ProtoMessage()               {}
func (*CMsgLeaveParty) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{10} }

type CMsgServerAvailable struct {
}

func (m *CMsgServerAvailable) Reset()         { *m = CMsgServerAvailable{} }
func (m *CMsgServerAvailable) String() string { return proto.CompactTextString(m) }
func (*CMsgServerAvailable) ProtoMessage()    {}
func (*CMsgServerAvailable) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{11}
}

type CMsgLANServerAvailable struct {
	LobbyId uint64 `protobuf:"fixed64,1,opt,name=lobby_id,json=lobbyId" json:"lobby_id"`
}

func (m *CMsgLANServerAvailable) Reset()         { *m = CMsgLANServerAvailable{} }
func (m *CMsgLANServerAvailable) String() string { return proto.CompactTextString(m) }
func (*CMsgLANServerAvailable) ProtoMessage()    {}
func (*CMsgLANServerAvailable) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{12}
}

func (m *CMsgLANServerAvailable) GetLobbyId() uint64 {
	if m != nil {
		return m.LobbyId
	}
	return 0
}

type CSOEconGameAccountClient struct {
	AdditionalBackpackSlots *uint32 `protobuf:"varint,1,opt,name=additional_backpack_slots,json=additionalBackpackSlots,def=0" json:"additional_backpack_slots,omitempty"`
	BonusXpTimestampRefresh uint32  `protobuf:"fixed32,12,opt,name=bonus_xp_timestamp_refresh,json=bonusXpTimestampRefresh" json:"bonus_xp_timestamp_refresh"`
	BonusXpUsedflags        uint32  `protobuf:"varint,13,opt,name=bonus_xp_usedflags,json=bonusXpUsedflags" json:"bonus_xp_usedflags"`
	ElevatedState           uint32  `protobuf:"varint,14,opt,name=elevated_state,json=elevatedState" json:"elevated_state"`
	ElevatedTimestamp       uint32  `protobuf:"varint,15,opt,name=elevated_timestamp,json=elevatedTimestamp" json:"elevated_timestamp"`
}

func (m *CSOEconGameAccountClient) Reset()         { *m = CSOEconGameAccountClient{} }
func (m *CSOEconGameAccountClient) String() string { return proto.CompactTextString(m) }
func (*CSOEconGameAccountClient) ProtoMessage()    {}
func (*CSOEconGameAccountClient) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{13}
}

const Default_CSOEconGameAccountClient_AdditionalBackpackSlots uint32 = 0

func (m *CSOEconGameAccountClient) GetAdditionalBackpackSlots() uint32 {
	if m != nil && m.AdditionalBackpackSlots != nil {
		return *m.AdditionalBackpackSlots
	}
	return Default_CSOEconGameAccountClient_AdditionalBackpackSlots
}

func (m *CSOEconGameAccountClient) GetBonusXpTimestampRefresh() uint32 {
	if m != nil {
		return m.BonusXpTimestampRefresh
	}
	return 0
}

func (m *CSOEconGameAccountClient) GetBonusXpUsedflags() uint32 {
	if m != nil {
		return m.BonusXpUsedflags
	}
	return 0
}

func (m *CSOEconGameAccountClient) GetElevatedState() uint32 {
	if m != nil {
		return m.ElevatedState
	}
	return 0
}

func (m *CSOEconGameAccountClient) GetElevatedTimestamp() uint32 {
	if m != nil {
		return m.ElevatedTimestamp
	}
	return 0
}

type CSOItemCriteriaCondition struct {
	Op          int32   `protobuf:"varint,1,opt,name=op" json:"op"`
	Field       string  `protobuf:"bytes,2,opt,name=field" json:"field"`
	Required    bool    `protobuf:"varint,3,opt,name=required" json:"required"`
	FloatValue  float32 `protobuf:"fixed32,4,opt,name=float_value,json=floatValue" json:"float_value"`
	StringValue string  `protobuf:"bytes,5,opt,name=string_value,json=stringValue" json:"string_value"`
}

func (m *CSOItemCriteriaCondition) Reset()         { *m = CSOItemCriteriaCondition{} }
func (m *CSOItemCriteriaCondition) String() string { return proto.CompactTextString(m) }
func (*CSOItemCriteriaCondition) ProtoMessage()    {}
func (*CSOItemCriteriaCondition) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{14}
}

func (m *CSOItemCriteriaCondition) GetOp() int32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *CSOItemCriteriaCondition) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *CSOItemCriteriaCondition) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *CSOItemCriteriaCondition) GetFloatValue() float32 {
	if m != nil {
		return m.FloatValue
	}
	return 0
}

func (m *CSOItemCriteriaCondition) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

type CSOItemCriteria struct {
	ItemLevel         uint32                      `protobuf:"varint,1,opt,name=item_level,json=itemLevel" json:"item_level"`
	ItemQuality       int32                       `protobuf:"varint,2,opt,name=item_quality,json=itemQuality" json:"item_quality"`
	ItemLevelSet      bool                        `protobuf:"varint,3,opt,name=item_level_set,json=itemLevelSet" json:"item_level_set"`
	ItemQualitySet    bool                        `protobuf:"varint,4,opt,name=item_quality_set,json=itemQualitySet" json:"item_quality_set"`
	InitialInventory  uint32                      `protobuf:"varint,5,opt,name=initial_inventory,json=initialInventory" json:"initial_inventory"`
	InitialQuantity   uint32                      `protobuf:"varint,6,opt,name=initial_quantity,json=initialQuantity" json:"initial_quantity"`
	IgnoreEnabledFlag bool                        `protobuf:"varint,8,opt,name=ignore_enabled_flag,json=ignoreEnabledFlag" json:"ignore_enabled_flag"`
	Conditions        []*CSOItemCriteriaCondition `protobuf:"bytes,9,rep,name=conditions" json:"conditions,omitempty"`
	ItemRarity        int32                       `protobuf:"varint,10,opt,name=item_rarity,json=itemRarity" json:"item_rarity"`
	ItemRaritySet     bool                        `protobuf:"varint,11,opt,name=item_rarity_set,json=itemRaritySet" json:"item_rarity_set"`
	RecentOnly        bool                        `protobuf:"varint,12,opt,name=recent_only,json=recentOnly" json:"recent_only"`
}

func (m *CSOItemCriteria) Reset()                    { *m = CSOItemCriteria{} }
func (m *CSOItemCriteria) String() string            { return proto.CompactTextString(m) }
func (*CSOItemCriteria) ProtoMessage()               {}
func (*CSOItemCriteria) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{15} }

func (m *CSOItemCriteria) GetItemLevel() uint32 {
	if m != nil {
		return m.ItemLevel
	}
	return 0
}

func (m *CSOItemCriteria) GetItemQuality() int32 {
	if m != nil {
		return m.ItemQuality
	}
	return 0
}

func (m *CSOItemCriteria) GetItemLevelSet() bool {
	if m != nil {
		return m.ItemLevelSet
	}
	return false
}

func (m *CSOItemCriteria) GetItemQualitySet() bool {
	if m != nil {
		return m.ItemQualitySet
	}
	return false
}

func (m *CSOItemCriteria) GetInitialInventory() uint32 {
	if m != nil {
		return m.InitialInventory
	}
	return 0
}

func (m *CSOItemCriteria) GetInitialQuantity() uint32 {
	if m != nil {
		return m.InitialQuantity
	}
	return 0
}

func (m *CSOItemCriteria) GetIgnoreEnabledFlag() bool {
	if m != nil {
		return m.IgnoreEnabledFlag
	}
	return false
}

func (m *CSOItemCriteria) GetConditions() []*CSOItemCriteriaCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *CSOItemCriteria) GetItemRarity() int32 {
	if m != nil {
		return m.ItemRarity
	}
	return 0
}

func (m *CSOItemCriteria) GetItemRaritySet() bool {
	if m != nil {
		return m.ItemRaritySet
	}
	return false
}

func (m *CSOItemCriteria) GetRecentOnly() bool {
	if m != nil {
		return m.RecentOnly
	}
	return false
}

type CSOItemRecipe struct {
	DefIndex             uint32             `protobuf:"varint,1,opt,name=def_index,json=defIndex" json:"def_index"`
	Name                 string             `protobuf:"bytes,2,opt,name=name" json:"name"`
	NA                   string             `protobuf:"bytes,3,opt,name=n_a,json=nA" json:"n_a"`
	DescInputs           string             `protobuf:"bytes,4,opt,name=desc_inputs,json=descInputs" json:"desc_inputs"`
	DescOutputs          string             `protobuf:"bytes,5,opt,name=desc_outputs,json=descOutputs" json:"desc_outputs"`
	DiA                  string             `protobuf:"bytes,6,opt,name=di_a,json=diA" json:"di_a"`
	DiB                  string             `protobuf:"bytes,7,opt,name=di_b,json=diB" json:"di_b"`
	DiC                  string             `protobuf:"bytes,8,opt,name=di_c,json=diC" json:"di_c"`
	DoA                  string             `protobuf:"bytes,9,opt,name=do_a,json=doA" json:"do_a"`
	DoB                  string             `protobuf:"bytes,10,opt,name=do_b,json=doB" json:"do_b"`
	DoC                  string             `protobuf:"bytes,11,opt,name=do_c,json=doC" json:"do_c"`
	RequiresAllSameClass bool               `protobuf:"varint,12,opt,name=requires_all_same_class,json=requiresAllSameClass" json:"requires_all_same_class"`
	RequiresAllSameSlot  bool               `protobuf:"varint,13,opt,name=requires_all_same_slot,json=requiresAllSameSlot" json:"requires_all_same_slot"`
	ClassUsageForOutput  int32              `protobuf:"varint,14,opt,name=class_usage_for_output,json=classUsageForOutput" json:"class_usage_for_output"`
	SlotUsageForOutput   int32              `protobuf:"varint,15,opt,name=slot_usage_for_output,json=slotUsageForOutput" json:"slot_usage_for_output"`
	SetForOutput         int32              `protobuf:"varint,16,opt,name=set_for_output,json=setForOutput" json:"set_for_output"`
	InputItemsCriteria   []*CSOItemCriteria `protobuf:"bytes,20,rep,name=input_items_criteria,json=inputItemsCriteria" json:"input_items_criteria,omitempty"`
	OutputItemsCriteria  []*CSOItemCriteria `protobuf:"bytes,21,rep,name=output_items_criteria,json=outputItemsCriteria" json:"output_items_criteria,omitempty"`
	InputItemDupeCounts  []uint32           `protobuf:"varint,22,rep,name=input_item_dupe_counts,json=inputItemDupeCounts" json:"input_item_dupe_counts,omitempty"`
}

func (m *CSOItemRecipe) Reset()                    { *m = CSOItemRecipe{} }
func (m *CSOItemRecipe) String() string            { return proto.CompactTextString(m) }
func (*CSOItemRecipe) ProtoMessage()               {}
func (*CSOItemRecipe) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{16} }

func (m *CSOItemRecipe) GetDefIndex() uint32 {
	if m != nil {
		return m.DefIndex
	}
	return 0
}

func (m *CSOItemRecipe) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CSOItemRecipe) GetNA() string {
	if m != nil {
		return m.NA
	}
	return ""
}

func (m *CSOItemRecipe) GetDescInputs() string {
	if m != nil {
		return m.DescInputs
	}
	return ""
}

func (m *CSOItemRecipe) GetDescOutputs() string {
	if m != nil {
		return m.DescOutputs
	}
	return ""
}

func (m *CSOItemRecipe) GetDiA() string {
	if m != nil {
		return m.DiA
	}
	return ""
}

func (m *CSOItemRecipe) GetDiB() string {
	if m != nil {
		return m.DiB
	}
	return ""
}

func (m *CSOItemRecipe) GetDiC() string {
	if m != nil {
		return m.DiC
	}
	return ""
}

func (m *CSOItemRecipe) GetDoA() string {
	if m != nil {
		return m.DoA
	}
	return ""
}

func (m *CSOItemRecipe) GetDoB() string {
	if m != nil {
		return m.DoB
	}
	return ""
}

func (m *CSOItemRecipe) GetDoC() string {
	if m != nil {
		return m.DoC
	}
	return ""
}

func (m *CSOItemRecipe) GetRequiresAllSameClass() bool {
	if m != nil {
		return m.RequiresAllSameClass
	}
	return false
}

func (m *CSOItemRecipe) GetRequiresAllSameSlot() bool {
	if m != nil {
		return m.RequiresAllSameSlot
	}
	return false
}

func (m *CSOItemRecipe) GetClassUsageForOutput() int32 {
	if m != nil {
		return m.ClassUsageForOutput
	}
	return 0
}

func (m *CSOItemRecipe) GetSlotUsageForOutput() int32 {
	if m != nil {
		return m.SlotUsageForOutput
	}
	return 0
}

func (m *CSOItemRecipe) GetSetForOutput() int32 {
	if m != nil {
		return m.SetForOutput
	}
	return 0
}

func (m *CSOItemRecipe) GetInputItemsCriteria() []*CSOItemCriteria {
	if m != nil {
		return m.InputItemsCriteria
	}
	return nil
}

func (m *CSOItemRecipe) GetOutputItemsCriteria() []*CSOItemCriteria {
	if m != nil {
		return m.OutputItemsCriteria
	}
	return nil
}

func (m *CSOItemRecipe) GetInputItemDupeCounts() []uint32 {
	if m != nil {
		return m.InputItemDupeCounts
	}
	return nil
}

type CMsgDevNewItemRequest struct {
	Receiver uint64           `protobuf:"fixed64,1,opt,name=receiver" json:"receiver"`
	Criteria *CSOItemCriteria `protobuf:"bytes,2,opt,name=criteria" json:"criteria,omitempty"`
}

func (m *CMsgDevNewItemRequest) Reset()         { *m = CMsgDevNewItemRequest{} }
func (m *CMsgDevNewItemRequest) String() string { return proto.CompactTextString(m) }
func (*CMsgDevNewItemRequest) ProtoMessage()    {}
func (*CMsgDevNewItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{17}
}

func (m *CMsgDevNewItemRequest) GetReceiver() uint64 {
	if m != nil {
		return m.Receiver
	}
	return 0
}

func (m *CMsgDevNewItemRequest) GetCriteria() *CSOItemCriteria {
	if m != nil {
		return m.Criteria
	}
	return nil
}

type CMsgIncrementKillCountAttribute struct {
	KillerAccountId uint32 `protobuf:"fixed32,1,opt,name=killer_account_id,json=killerAccountId" json:"killer_account_id"`
	VictimAccountId uint32 `protobuf:"fixed32,2,opt,name=victim_account_id,json=victimAccountId" json:"victim_account_id"`
	ItemId          uint64 `protobuf:"varint,3,opt,name=item_id,json=itemId" json:"item_id"`
	EventType       uint32 `protobuf:"varint,4,opt,name=event_type,json=eventType" json:"event_type"`
	Amount          uint32 `protobuf:"varint,5,opt,name=amount" json:"amount"`
}

func (m *CMsgIncrementKillCountAttribute) Reset()         { *m = CMsgIncrementKillCountAttribute{} }
func (m *CMsgIncrementKillCountAttribute) String() string { return proto.CompactTextString(m) }
func (*CMsgIncrementKillCountAttribute) ProtoMessage()    {}
func (*CMsgIncrementKillCountAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{18}
}

func (m *CMsgIncrementKillCountAttribute) GetKillerAccountId() uint32 {
	if m != nil {
		return m.KillerAccountId
	}
	return 0
}

func (m *CMsgIncrementKillCountAttribute) GetVictimAccountId() uint32 {
	if m != nil {
		return m.VictimAccountId
	}
	return 0
}

func (m *CMsgIncrementKillCountAttribute) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CMsgIncrementKillCountAttribute) GetEventType() uint32 {
	if m != nil {
		return m.EventType
	}
	return 0
}

func (m *CMsgIncrementKillCountAttribute) GetAmount() uint32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type CMsgApplySticker struct {
	StickerItemId  uint64  `protobuf:"varint,1,opt,name=sticker_item_id,json=stickerItemId" json:"sticker_item_id"`
	ItemItemId     uint64  `protobuf:"varint,2,opt,name=item_item_id,json=itemItemId" json:"item_item_id"`
	StickerSlot    uint32  `protobuf:"varint,3,opt,name=sticker_slot,json=stickerSlot" json:"sticker_slot"`
	BaseitemDefidx uint32  `protobuf:"varint,4,opt,name=baseitem_defidx,json=baseitemDefidx" json:"baseitem_defidx"`
	StickerWear    float32 `protobuf:"fixed32,5,opt,name=sticker_wear,json=stickerWear" json:"sticker_wear"`
}

func (m *CMsgApplySticker) Reset()                    { *m = CMsgApplySticker{} }
func (m *CMsgApplySticker) String() string            { return proto.CompactTextString(m) }
func (*CMsgApplySticker) ProtoMessage()               {}
func (*CMsgApplySticker) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{19} }

func (m *CMsgApplySticker) GetStickerItemId() uint64 {
	if m != nil {
		return m.StickerItemId
	}
	return 0
}

func (m *CMsgApplySticker) GetItemItemId() uint64 {
	if m != nil {
		return m.ItemItemId
	}
	return 0
}

func (m *CMsgApplySticker) GetStickerSlot() uint32 {
	if m != nil {
		return m.StickerSlot
	}
	return 0
}

func (m *CMsgApplySticker) GetBaseitemDefidx() uint32 {
	if m != nil {
		return m.BaseitemDefidx
	}
	return 0
}

func (m *CMsgApplySticker) GetStickerWear() float32 {
	if m != nil {
		return m.StickerWear
	}
	return 0
}

type CMsgApplyStatTrakSwap struct {
	ToolItemId   uint64 `protobuf:"varint,1,opt,name=tool_item_id,json=toolItemId" json:"tool_item_id"`
	Item_1ItemId uint64 `protobuf:"varint,2,opt,name=item_1_item_id,json=item1ItemId" json:"item_1_item_id"`
	Item_2ItemId uint64 `protobuf:"varint,3,opt,name=item_2_item_id,json=item2ItemId" json:"item_2_item_id"`
}

func (m *CMsgApplyStatTrakSwap) Reset()         { *m = CMsgApplyStatTrakSwap{} }
func (m *CMsgApplyStatTrakSwap) String() string { return proto.CompactTextString(m) }
func (*CMsgApplyStatTrakSwap) ProtoMessage()    {}
func (*CMsgApplyStatTrakSwap) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{20}
}

func (m *CMsgApplyStatTrakSwap) GetToolItemId() uint64 {
	if m != nil {
		return m.ToolItemId
	}
	return 0
}

func (m *CMsgApplyStatTrakSwap) GetItem_1ItemId() uint64 {
	if m != nil {
		return m.Item_1ItemId
	}
	return 0
}

func (m *CMsgApplyStatTrakSwap) GetItem_2ItemId() uint64 {
	if m != nil {
		return m.Item_2ItemId
	}
	return 0
}

type CMsgApplyStrangePart struct {
	StrangePartItemId uint64 `protobuf:"varint,1,opt,name=strange_part_item_id,json=strangePartItemId" json:"strange_part_item_id"`
	ItemItemId        uint64 `protobuf:"varint,2,opt,name=item_item_id,json=itemItemId" json:"item_item_id"`
}

func (m *CMsgApplyStrangePart) Reset()         { *m = CMsgApplyStrangePart{} }
func (m *CMsgApplyStrangePart) String() string { return proto.CompactTextString(m) }
func (*CMsgApplyStrangePart) ProtoMessage()    {}
func (*CMsgApplyStrangePart) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{21}
}

func (m *CMsgApplyStrangePart) GetStrangePartItemId() uint64 {
	if m != nil {
		return m.StrangePartItemId
	}
	return 0
}

func (m *CMsgApplyStrangePart) GetItemItemId() uint64 {
	if m != nil {
		return m.ItemItemId
	}
	return 0
}

type CMsgApplyPennantUpgrade struct {
	UpgradeItemId uint64 `protobuf:"varint,1,opt,name=upgrade_item_id,json=upgradeItemId" json:"upgrade_item_id"`
	PennantItemId uint64 `protobuf:"varint,2,opt,name=pennant_item_id,json=pennantItemId" json:"pennant_item_id"`
}

func (m *CMsgApplyPennantUpgrade) Reset()         { *m = CMsgApplyPennantUpgrade{} }
func (m *CMsgApplyPennantUpgrade) String() string { return proto.CompactTextString(m) }
func (*CMsgApplyPennantUpgrade) ProtoMessage()    {}
func (*CMsgApplyPennantUpgrade) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{22}
}

func (m *CMsgApplyPennantUpgrade) GetUpgradeItemId() uint64 {
	if m != nil {
		return m.UpgradeItemId
	}
	return 0
}

func (m *CMsgApplyPennantUpgrade) GetPennantItemId() uint64 {
	if m != nil {
		return m.PennantItemId
	}
	return 0
}

type CMsgApplyEggEssence struct {
	EssenceItemId uint64 `protobuf:"varint,1,opt,name=essence_item_id,json=essenceItemId" json:"essence_item_id"`
	EggItemId     uint64 `protobuf:"varint,2,opt,name=egg_item_id,json=eggItemId" json:"egg_item_id"`
}

func (m *CMsgApplyEggEssence) Reset()         { *m = CMsgApplyEggEssence{} }
func (m *CMsgApplyEggEssence) String() string { return proto.CompactTextString(m) }
func (*CMsgApplyEggEssence) ProtoMessage()    {}
func (*CMsgApplyEggEssence) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{23}
}

func (m *CMsgApplyEggEssence) GetEssenceItemId() uint64 {
	if m != nil {
		return m.EssenceItemId
	}
	return 0
}

func (m *CMsgApplyEggEssence) GetEggItemId() uint64 {
	if m != nil {
		return m.EggItemId
	}
	return 0
}

type CSOEconItemAttribute struct {
	DefIndex   uint32 `protobuf:"varint,1,opt,name=def_index,json=defIndex" json:"def_index"`
	Value      uint32 `protobuf:"varint,2,opt,name=value" json:"value"`
	ValueBytes []byte `protobuf:"bytes,3,opt,name=value_bytes,json=valueBytes" json:"value_bytes"`
}

func (m *CSOEconItemAttribute) Reset()         { *m = CSOEconItemAttribute{} }
func (m *CSOEconItemAttribute) String() string { return proto.CompactTextString(m) }
func (*CSOEconItemAttribute) ProtoMessage()    {}
func (*CSOEconItemAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{24}
}

func (m *CSOEconItemAttribute) GetDefIndex() uint32 {
	if m != nil {
		return m.DefIndex
	}
	return 0
}

func (m *CSOEconItemAttribute) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *CSOEconItemAttribute) GetValueBytes() []byte {
	if m != nil {
		return m.ValueBytes
	}
	return nil
}

type CSOEconItemEquipped struct {
	NewClass uint32 `protobuf:"varint,1,opt,name=new_class,json=newClass" json:"new_class"`
	NewSlot  uint32 `protobuf:"varint,2,opt,name=new_slot,json=newSlot" json:"new_slot"`
}

func (m *CSOEconItemEquipped) Reset()         { *m = CSOEconItemEquipped{} }
func (m *CSOEconItemEquipped) String() string { return proto.CompactTextString(m) }
func (*CSOEconItemEquipped) ProtoMessage()    {}
func (*CSOEconItemEquipped) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{25}
}

func (m *CSOEconItemEquipped) GetNewClass() uint32 {
	if m != nil {
		return m.NewClass
	}
	return 0
}

func (m *CSOEconItemEquipped) GetNewSlot() uint32 {
	if m != nil {
		return m.NewSlot
	}
	return 0
}

type CSOEconItem struct {
	Id            uint64                  `protobuf:"varint,1,opt,name=id" json:"id"`
	AccountId     uint32                  `protobuf:"varint,2,opt,name=account_id,json=accountId" json:"account_id"`
	Inventory     uint32                  `protobuf:"varint,3,opt,name=inventory" json:"inventory"`
	DefIndex      uint32                  `protobuf:"varint,4,opt,name=def_index,json=defIndex" json:"def_index"`
	Quantity      uint32                  `protobuf:"varint,5,opt,name=quantity" json:"quantity"`
	Level         uint32                  `protobuf:"varint,6,opt,name=level" json:"level"`
	Quality       uint32                  `protobuf:"varint,7,opt,name=quality" json:"quality"`
	Flags         *uint32                 `protobuf:"varint,8,opt,name=flags,def=0" json:"flags,omitempty"`
	Origin        uint32                  `protobuf:"varint,9,opt,name=origin" json:"origin"`
	CustomName    string                  `protobuf:"bytes,10,opt,name=custom_name,json=customName" json:"custom_name"`
	CustomDesc    string                  `protobuf:"bytes,11,opt,name=custom_desc,json=customDesc" json:"custom_desc"`
	Attribute     []*CSOEconItemAttribute `protobuf:"bytes,12,rep,name=attribute" json:"attribute,omitempty"`
	InteriorItem  *CSOEconItem            `protobuf:"bytes,13,opt,name=interior_item,json=interiorItem" json:"interior_item,omitempty"`
	InUse         *bool                   `protobuf:"varint,14,opt,name=in_use,json=inUse,def=0" json:"in_use,omitempty"`
	Style         *uint32                 `protobuf:"varint,15,opt,name=style,def=0" json:"style,omitempty"`
	OriginalId    *uint64                 `protobuf:"varint,16,opt,name=original_id,json=originalId,def=0" json:"original_id,omitempty"`
	EquippedState []*CSOEconItemEquipped  `protobuf:"bytes,18,rep,name=equipped_state,json=equippedState" json:"equipped_state,omitempty"`
	Rarity        uint32                  `protobuf:"varint,19,opt,name=rarity" json:"rarity"`
}

func (m *CSOEconItem) Reset()                    { *m = CSOEconItem{} }
func (m *CSOEconItem) String() string            { return proto.CompactTextString(m) }
func (*CSOEconItem) ProtoMessage()               {}
func (*CSOEconItem) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{26} }

const Default_CSOEconItem_Flags uint32 = 0
const Default_CSOEconItem_InUse bool = false
const Default_CSOEconItem_Style uint32 = 0
const Default_CSOEconItem_OriginalId uint64 = 0

func (m *CSOEconItem) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CSOEconItem) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CSOEconItem) GetInventory() uint32 {
	if m != nil {
		return m.Inventory
	}
	return 0
}

func (m *CSOEconItem) GetDefIndex() uint32 {
	if m != nil {
		return m.DefIndex
	}
	return 0
}

func (m *CSOEconItem) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *CSOEconItem) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *CSOEconItem) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *CSOEconItem) GetFlags() uint32 {
	if m != nil && m.Flags != nil {
		return *m.Flags
	}
	return Default_CSOEconItem_Flags
}

func (m *CSOEconItem) GetOrigin() uint32 {
	if m != nil {
		return m.Origin
	}
	return 0
}

func (m *CSOEconItem) GetCustomName() string {
	if m != nil {
		return m.CustomName
	}
	return ""
}

func (m *CSOEconItem) GetCustomDesc() string {
	if m != nil {
		return m.CustomDesc
	}
	return ""
}

func (m *CSOEconItem) GetAttribute() []*CSOEconItemAttribute {
	if m != nil {
		return m.Attribute
	}
	return nil
}

func (m *CSOEconItem) GetInteriorItem() *CSOEconItem {
	if m != nil {
		return m.InteriorItem
	}
	return nil
}

func (m *CSOEconItem) GetInUse() bool {
	if m != nil && m.InUse != nil {
		return *m.InUse
	}
	return Default_CSOEconItem_InUse
}

func (m *CSOEconItem) GetStyle() uint32 {
	if m != nil && m.Style != nil {
		return *m.Style
	}
	return Default_CSOEconItem_Style
}

func (m *CSOEconItem) GetOriginalId() uint64 {
	if m != nil && m.OriginalId != nil {
		return *m.OriginalId
	}
	return Default_CSOEconItem_OriginalId
}

func (m *CSOEconItem) GetEquippedState() []*CSOEconItemEquipped {
	if m != nil {
		return m.EquippedState
	}
	return nil
}

func (m *CSOEconItem) GetRarity() uint32 {
	if m != nil {
		return m.Rarity
	}
	return 0
}

type CMsgAdjustItemEquippedState struct {
	ItemId   uint64 `protobuf:"varint,1,opt,name=item_id,json=itemId" json:"item_id"`
	NewClass uint32 `protobuf:"varint,2,opt,name=new_class,json=newClass" json:"new_class"`
	NewSlot  uint32 `protobuf:"varint,3,opt,name=new_slot,json=newSlot" json:"new_slot"`
	Swap     bool   `protobuf:"varint,4,opt,name=swap" json:"swap"`
}

func (m *CMsgAdjustItemEquippedState) Reset()         { *m = CMsgAdjustItemEquippedState{} }
func (m *CMsgAdjustItemEquippedState) String() string { return proto.CompactTextString(m) }
func (*CMsgAdjustItemEquippedState) ProtoMessage()    {}
func (*CMsgAdjustItemEquippedState) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{27}
}

func (m *CMsgAdjustItemEquippedState) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CMsgAdjustItemEquippedState) GetNewClass() uint32 {
	if m != nil {
		return m.NewClass
	}
	return 0
}

func (m *CMsgAdjustItemEquippedState) GetNewSlot() uint32 {
	if m != nil {
		return m.NewSlot
	}
	return 0
}

func (m *CMsgAdjustItemEquippedState) GetSwap() bool {
	if m != nil {
		return m.Swap
	}
	return false
}

type CMsgSortItems struct {
	SortType uint32 `protobuf:"varint,1,opt,name=sort_type,json=sortType" json:"sort_type"`
}

func (m *CMsgSortItems) Reset()                    { *m = CMsgSortItems{} }
func (m *CMsgSortItems) String() string            { return proto.CompactTextString(m) }
func (*CMsgSortItems) ProtoMessage()               {}
func (*CMsgSortItems) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{28} }

func (m *CMsgSortItems) GetSortType() uint32 {
	if m != nil {
		return m.SortType
	}
	return 0
}

type CSOEconClaimCode struct {
	AccountId    uint32 `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	CodeType     uint32 `protobuf:"varint,2,opt,name=code_type,json=codeType" json:"code_type"`
	TimeAcquired uint32 `protobuf:"varint,3,opt,name=time_acquired,json=timeAcquired" json:"time_acquired"`
	Code         string `protobuf:"bytes,4,opt,name=code" json:"code"`
}

func (m *CSOEconClaimCode) Reset()                    { *m = CSOEconClaimCode{} }
func (m *CSOEconClaimCode) String() string            { return proto.CompactTextString(m) }
func (*CSOEconClaimCode) ProtoMessage()               {}
func (*CSOEconClaimCode) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{29} }

func (m *CSOEconClaimCode) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CSOEconClaimCode) GetCodeType() uint32 {
	if m != nil {
		return m.CodeType
	}
	return 0
}

func (m *CSOEconClaimCode) GetTimeAcquired() uint32 {
	if m != nil {
		return m.TimeAcquired
	}
	return 0
}

func (m *CSOEconClaimCode) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type CMsgStoreGetUserData struct {
	PriceSheetVersion uint32 `protobuf:"fixed32,1,opt,name=price_sheet_version,json=priceSheetVersion" json:"price_sheet_version"`
	Currency          int32  `protobuf:"varint,2,opt,name=currency" json:"currency"`
}

func (m *CMsgStoreGetUserData) Reset()         { *m = CMsgStoreGetUserData{} }
func (m *CMsgStoreGetUserData) String() string { return proto.CompactTextString(m) }
func (*CMsgStoreGetUserData) ProtoMessage()    {}
func (*CMsgStoreGetUserData) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{30}
}

func (m *CMsgStoreGetUserData) GetPriceSheetVersion() uint32 {
	if m != nil {
		return m.PriceSheetVersion
	}
	return 0
}

func (m *CMsgStoreGetUserData) GetCurrency() int32 {
	if m != nil {
		return m.Currency
	}
	return 0
}

type CMsgStoreGetUserDataResponse struct {
	Result             int32  `protobuf:"varint,1,opt,name=result" json:"result"`
	CurrencyDeprecated int32  `protobuf:"varint,2,opt,name=currency_deprecated,json=currencyDeprecated" json:"currency_deprecated"`
	CountryDeprecated  string `protobuf:"bytes,3,opt,name=country_deprecated,json=countryDeprecated" json:"country_deprecated"`
	PriceSheetVersion  uint32 `protobuf:"fixed32,4,opt,name=price_sheet_version,json=priceSheetVersion" json:"price_sheet_version"`
	PriceSheet         []byte `protobuf:"bytes,8,opt,name=price_sheet,json=priceSheet" json:"price_sheet"`
}

func (m *CMsgStoreGetUserDataResponse) Reset()         { *m = CMsgStoreGetUserDataResponse{} }
func (m *CMsgStoreGetUserDataResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgStoreGetUserDataResponse) ProtoMessage()    {}
func (*CMsgStoreGetUserDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{31}
}

func (m *CMsgStoreGetUserDataResponse) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *CMsgStoreGetUserDataResponse) GetCurrencyDeprecated() int32 {
	if m != nil {
		return m.CurrencyDeprecated
	}
	return 0
}

func (m *CMsgStoreGetUserDataResponse) GetCountryDeprecated() string {
	if m != nil {
		return m.CountryDeprecated
	}
	return ""
}

func (m *CMsgStoreGetUserDataResponse) GetPriceSheetVersion() uint32 {
	if m != nil {
		return m.PriceSheetVersion
	}
	return 0
}

func (m *CMsgStoreGetUserDataResponse) GetPriceSheet() []byte {
	if m != nil {
		return m.PriceSheet
	}
	return nil
}

type CMsgUpdateItemSchema struct {
	ItemsGame                   []byte `protobuf:"bytes,1,opt,name=items_game,json=itemsGame" json:"items_game"`
	ItemSchemaVersion           uint32 `protobuf:"fixed32,2,opt,name=item_schema_version,json=itemSchemaVersion" json:"item_schema_version"`
	ItemsGameUrl_DEPRECATED2013 string `protobuf:"bytes,3,opt,name=items_game_url_DEPRECATED2013,json=itemsGameUrlDEPRECATED2013" json:"items_game_url_DEPRECATED2013"`
	ItemsGameUrl                string `protobuf:"bytes,4,opt,name=items_game_url,json=itemsGameUrl" json:"items_game_url"`
}

func (m *CMsgUpdateItemSchema) Reset()         { *m = CMsgUpdateItemSchema{} }
func (m *CMsgUpdateItemSchema) String() string { return proto.CompactTextString(m) }
func (*CMsgUpdateItemSchema) ProtoMessage()    {}
func (*CMsgUpdateItemSchema) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{32}
}

func (m *CMsgUpdateItemSchema) GetItemsGame() []byte {
	if m != nil {
		return m.ItemsGame
	}
	return nil
}

func (m *CMsgUpdateItemSchema) GetItemSchemaVersion() uint32 {
	if m != nil {
		return m.ItemSchemaVersion
	}
	return 0
}

func (m *CMsgUpdateItemSchema) GetItemsGameUrl_DEPRECATED2013() string {
	if m != nil {
		return m.ItemsGameUrl_DEPRECATED2013
	}
	return ""
}

func (m *CMsgUpdateItemSchema) GetItemsGameUrl() string {
	if m != nil {
		return m.ItemsGameUrl
	}
	return ""
}

type CMsgGCError struct {
	ErrorText string `protobuf:"bytes,1,opt,name=error_text,json=errorText" json:"error_text"`
}

func (m *CMsgGCError) Reset()                    { *m = CMsgGCError{} }
func (m *CMsgGCError) String() string            { return proto.CompactTextString(m) }
func (*CMsgGCError) ProtoMessage()               {}
func (*CMsgGCError) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{33} }

func (m *CMsgGCError) GetErrorText() string {
	if m != nil {
		return m.ErrorText
	}
	return ""
}

type CMsgRequestInventoryRefresh struct {
}

func (m *CMsgRequestInventoryRefresh) Reset()         { *m = CMsgRequestInventoryRefresh{} }
func (m *CMsgRequestInventoryRefresh) String() string { return proto.CompactTextString(m) }
func (*CMsgRequestInventoryRefresh) ProtoMessage()    {}
func (*CMsgRequestInventoryRefresh) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{34}
}

type CMsgConVarValue struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgConVarValue) Reset()                    { *m = CMsgConVarValue{} }
func (m *CMsgConVarValue) String() string            { return proto.CompactTextString(m) }
func (*CMsgConVarValue) ProtoMessage()               {}
func (*CMsgConVarValue) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{35} }

func (m *CMsgConVarValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgConVarValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CMsgReplicateConVars struct {
	Convars []*CMsgConVarValue `protobuf:"bytes,1,rep,name=convars" json:"convars,omitempty"`
}

func (m *CMsgReplicateConVars) Reset()         { *m = CMsgReplicateConVars{} }
func (m *CMsgReplicateConVars) String() string { return proto.CompactTextString(m) }
func (*CMsgReplicateConVars) ProtoMessage()    {}
func (*CMsgReplicateConVars) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{36}
}

func (m *CMsgReplicateConVars) GetConvars() []*CMsgConVarValue {
	if m != nil {
		return m.Convars
	}
	return nil
}

type CMsgUseItem struct {
	ItemId                uint64   `protobuf:"varint,1,opt,name=item_id,json=itemId" json:"item_id"`
	TargetSteamId         uint64   `protobuf:"fixed64,2,opt,name=target_steam_id,json=targetSteamId" json:"target_steam_id"`
	Gift_PotentialTargets []uint32 `protobuf:"varint,3,rep,name=gift__potential_targets,json=giftPotentialTargets" json:"gift__potential_targets,omitempty"`
	Duel_ClassLock        uint32   `protobuf:"varint,4,opt,name=duel__class_lock,json=duelClassLock" json:"duel__class_lock"`
	InitiatorSteamId      uint64   `protobuf:"fixed64,5,opt,name=initiator_steam_id,json=initiatorSteamId" json:"initiator_steam_id"`
}

func (m *CMsgUseItem) Reset()                    { *m = CMsgUseItem{} }
func (m *CMsgUseItem) String() string            { return proto.CompactTextString(m) }
func (*CMsgUseItem) ProtoMessage()               {}
func (*CMsgUseItem) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{37} }

func (m *CMsgUseItem) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CMsgUseItem) GetTargetSteamId() uint64 {
	if m != nil {
		return m.TargetSteamId
	}
	return 0
}

func (m *CMsgUseItem) GetGift_PotentialTargets() []uint32 {
	if m != nil {
		return m.Gift_PotentialTargets
	}
	return nil
}

func (m *CMsgUseItem) GetDuel_ClassLock() uint32 {
	if m != nil {
		return m.Duel_ClassLock
	}
	return 0
}

func (m *CMsgUseItem) GetInitiatorSteamId() uint64 {
	if m != nil {
		return m.InitiatorSteamId
	}
	return 0
}

type CMsgReplayUploadedToYouTube struct {
	YoutubeUrl         string `protobuf:"bytes,1,opt,name=youtube_url,json=youtubeUrl" json:"youtube_url"`
	YoutubeAccountName string `protobuf:"bytes,2,opt,name=youtube_account_name,json=youtubeAccountName" json:"youtube_account_name"`
	SessionId          uint64 `protobuf:"varint,3,opt,name=session_id,json=sessionId" json:"session_id"`
}

func (m *CMsgReplayUploadedToYouTube) Reset()         { *m = CMsgReplayUploadedToYouTube{} }
func (m *CMsgReplayUploadedToYouTube) String() string { return proto.CompactTextString(m) }
func (*CMsgReplayUploadedToYouTube) ProtoMessage()    {}
func (*CMsgReplayUploadedToYouTube) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{38}
}

func (m *CMsgReplayUploadedToYouTube) GetYoutubeUrl() string {
	if m != nil {
		return m.YoutubeUrl
	}
	return ""
}

func (m *CMsgReplayUploadedToYouTube) GetYoutubeAccountName() string {
	if m != nil {
		return m.YoutubeAccountName
	}
	return ""
}

func (m *CMsgReplayUploadedToYouTube) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

type CMsgConsumableExhausted struct {
	ItemDefId int32 `protobuf:"varint,1,opt,name=item_def_id,json=itemDefId" json:"item_def_id"`
}

func (m *CMsgConsumableExhausted) Reset()         { *m = CMsgConsumableExhausted{} }
func (m *CMsgConsumableExhausted) String() string { return proto.CompactTextString(m) }
func (*CMsgConsumableExhausted) ProtoMessage()    {}
func (*CMsgConsumableExhausted) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{39}
}

func (m *CMsgConsumableExhausted) GetItemDefId() int32 {
	if m != nil {
		return m.ItemDefId
	}
	return 0
}

type CMsgItemAcknowledged__DEPRECATED struct {
	AccountId uint32 `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	Inventory uint32 `protobuf:"varint,2,opt,name=inventory" json:"inventory"`
	DefIndex  uint32 `protobuf:"varint,3,opt,name=def_index,json=defIndex" json:"def_index"`
	Quality   uint32 `protobuf:"varint,4,opt,name=quality" json:"quality"`
	Rarity    uint32 `protobuf:"varint,5,opt,name=rarity" json:"rarity"`
	Origin    uint32 `protobuf:"varint,6,opt,name=origin" json:"origin"`
	ItemId    uint64 `protobuf:"varint,7,opt,name=item_id,json=itemId" json:"item_id"`
}

func (m *CMsgItemAcknowledged__DEPRECATED) Reset()         { *m = CMsgItemAcknowledged__DEPRECATED{} }
func (m *CMsgItemAcknowledged__DEPRECATED) String() string { return proto.CompactTextString(m) }
func (*CMsgItemAcknowledged__DEPRECATED) ProtoMessage()    {}
func (*CMsgItemAcknowledged__DEPRECATED) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{40}
}

func (m *CMsgItemAcknowledged__DEPRECATED) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CMsgItemAcknowledged__DEPRECATED) GetInventory() uint32 {
	if m != nil {
		return m.Inventory
	}
	return 0
}

func (m *CMsgItemAcknowledged__DEPRECATED) GetDefIndex() uint32 {
	if m != nil {
		return m.DefIndex
	}
	return 0
}

func (m *CMsgItemAcknowledged__DEPRECATED) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *CMsgItemAcknowledged__DEPRECATED) GetRarity() uint32 {
	if m != nil {
		return m.Rarity
	}
	return 0
}

func (m *CMsgItemAcknowledged__DEPRECATED) GetOrigin() uint32 {
	if m != nil {
		return m.Origin
	}
	return 0
}

func (m *CMsgItemAcknowledged__DEPRECATED) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

type CMsgSetItemPositions struct {
	ItemPositions []*CMsgSetItemPositions_ItemPosition `protobuf:"bytes,1,rep,name=item_positions,json=itemPositions" json:"item_positions,omitempty"`
}

func (m *CMsgSetItemPositions) Reset()         { *m = CMsgSetItemPositions{} }
func (m *CMsgSetItemPositions) String() string { return proto.CompactTextString(m) }
func (*CMsgSetItemPositions) ProtoMessage()    {}
func (*CMsgSetItemPositions) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{41}
}

func (m *CMsgSetItemPositions) GetItemPositions() []*CMsgSetItemPositions_ItemPosition {
	if m != nil {
		return m.ItemPositions
	}
	return nil
}

type CMsgSetItemPositions_ItemPosition struct {
	LegacyItemId uint32 `protobuf:"varint,1,opt,name=legacy_item_id,json=legacyItemId" json:"legacy_item_id"`
	Position     uint32 `protobuf:"varint,2,opt,name=position" json:"position"`
	ItemId       uint64 `protobuf:"varint,3,opt,name=item_id,json=itemId" json:"item_id"`
}

func (m *CMsgSetItemPositions_ItemPosition) Reset()         { *m = CMsgSetItemPositions_ItemPosition{} }
func (m *CMsgSetItemPositions_ItemPosition) String() string { return proto.CompactTextString(m) }
func (*CMsgSetItemPositions_ItemPosition) ProtoMessage()    {}
func (*CMsgSetItemPositions_ItemPosition) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{41, 0}
}

func (m *CMsgSetItemPositions_ItemPosition) GetLegacyItemId() uint32 {
	if m != nil {
		return m.LegacyItemId
	}
	return 0
}

func (m *CMsgSetItemPositions_ItemPosition) GetPosition() uint32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *CMsgSetItemPositions_ItemPosition) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

type CMsgGCReportAbuse struct {
	TargetSteamId        uint64 `protobuf:"fixed64,1,opt,name=target_steam_id,json=targetSteamId" json:"target_steam_id"`
	Description          string `protobuf:"bytes,4,opt,name=description" json:"description"`
	Gid                  uint64 `protobuf:"varint,5,opt,name=gid" json:"gid"`
	AbuseType            uint32 `protobuf:"varint,2,opt,name=abuse_type,json=abuseType" json:"abuse_type"`
	ContentType          uint32 `protobuf:"varint,3,opt,name=content_type,json=contentType" json:"content_type"`
	TargetGameServerIp   uint32 `protobuf:"fixed32,6,opt,name=target_game_server_ip,json=targetGameServerIp" json:"target_game_server_ip"`
	TargetGameServerPort uint32 `protobuf:"varint,7,opt,name=target_game_server_port,json=targetGameServerPort" json:"target_game_server_port"`
}

func (m *CMsgGCReportAbuse) Reset()                    { *m = CMsgGCReportAbuse{} }
func (m *CMsgGCReportAbuse) String() string            { return proto.CompactTextString(m) }
func (*CMsgGCReportAbuse) ProtoMessage()               {}
func (*CMsgGCReportAbuse) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{42} }

func (m *CMsgGCReportAbuse) GetTargetSteamId() uint64 {
	if m != nil {
		return m.TargetSteamId
	}
	return 0
}

func (m *CMsgGCReportAbuse) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CMsgGCReportAbuse) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *CMsgGCReportAbuse) GetAbuseType() uint32 {
	if m != nil {
		return m.AbuseType
	}
	return 0
}

func (m *CMsgGCReportAbuse) GetContentType() uint32 {
	if m != nil {
		return m.ContentType
	}
	return 0
}

func (m *CMsgGCReportAbuse) GetTargetGameServerIp() uint32 {
	if m != nil {
		return m.TargetGameServerIp
	}
	return 0
}

func (m *CMsgGCReportAbuse) GetTargetGameServerPort() uint32 {
	if m != nil {
		return m.TargetGameServerPort
	}
	return 0
}

type CMsgGCReportAbuseResponse struct {
	TargetSteamId uint64 `protobuf:"fixed64,1,opt,name=target_steam_id,json=targetSteamId" json:"target_steam_id"`
	Result        uint32 `protobuf:"varint,2,opt,name=result" json:"result"`
	ErrorMessage  string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage" json:"error_message"`
}

func (m *CMsgGCReportAbuseResponse) Reset()         { *m = CMsgGCReportAbuseResponse{} }
func (m *CMsgGCReportAbuseResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCReportAbuseResponse) ProtoMessage()    {}
func (*CMsgGCReportAbuseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{43}
}

func (m *CMsgGCReportAbuseResponse) GetTargetSteamId() uint64 {
	if m != nil {
		return m.TargetSteamId
	}
	return 0
}

func (m *CMsgGCReportAbuseResponse) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *CMsgGCReportAbuseResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type CMsgGCNameItemNotification struct {
	PlayerSteamid  uint64 `protobuf:"fixed64,1,opt,name=player_steamid,json=playerSteamid" json:"player_steamid"`
	ItemDefIndex   uint32 `protobuf:"varint,2,opt,name=item_def_index,json=itemDefIndex" json:"item_def_index"`
	ItemNameCustom string `protobuf:"bytes,3,opt,name=item_name_custom,json=itemNameCustom" json:"item_name_custom"`
}

func (m *CMsgGCNameItemNotification) Reset()         { *m = CMsgGCNameItemNotification{} }
func (m *CMsgGCNameItemNotification) String() string { return proto.CompactTextString(m) }
func (*CMsgGCNameItemNotification) ProtoMessage()    {}
func (*CMsgGCNameItemNotification) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{44}
}

func (m *CMsgGCNameItemNotification) GetPlayerSteamid() uint64 {
	if m != nil {
		return m.PlayerSteamid
	}
	return 0
}

func (m *CMsgGCNameItemNotification) GetItemDefIndex() uint32 {
	if m != nil {
		return m.ItemDefIndex
	}
	return 0
}

func (m *CMsgGCNameItemNotification) GetItemNameCustom() string {
	if m != nil {
		return m.ItemNameCustom
	}
	return ""
}

type CMsgGCClientDisplayNotification struct {
	NotificationTitleLocalizationKey string   `protobuf:"bytes,1,opt,name=notification_title_localization_key,json=notificationTitleLocalizationKey" json:"notification_title_localization_key"`
	NotificationBodyLocalizationKey  string   `protobuf:"bytes,2,opt,name=notification_body_localization_key,json=notificationBodyLocalizationKey" json:"notification_body_localization_key"`
	BodySubstringKeys                []string `protobuf:"bytes,3,rep,name=body_substring_keys,json=bodySubstringKeys" json:"body_substring_keys,omitempty"`
	BodySubstringValues              []string `protobuf:"bytes,4,rep,name=body_substring_values,json=bodySubstringValues" json:"body_substring_values,omitempty"`
}

func (m *CMsgGCClientDisplayNotification) Reset()         { *m = CMsgGCClientDisplayNotification{} }
func (m *CMsgGCClientDisplayNotification) String() string { return proto.CompactTextString(m) }
func (*CMsgGCClientDisplayNotification) ProtoMessage()    {}
func (*CMsgGCClientDisplayNotification) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{45}
}

func (m *CMsgGCClientDisplayNotification) GetNotificationTitleLocalizationKey() string {
	if m != nil {
		return m.NotificationTitleLocalizationKey
	}
	return ""
}

func (m *CMsgGCClientDisplayNotification) GetNotificationBodyLocalizationKey() string {
	if m != nil {
		return m.NotificationBodyLocalizationKey
	}
	return ""
}

func (m *CMsgGCClientDisplayNotification) GetBodySubstringKeys() []string {
	if m != nil {
		return m.BodySubstringKeys
	}
	return nil
}

func (m *CMsgGCClientDisplayNotification) GetBodySubstringValues() []string {
	if m != nil {
		return m.BodySubstringValues
	}
	return nil
}

type CMsgGCShowItemsPickedUp struct {
	PlayerSteamid uint64 `protobuf:"fixed64,1,opt,name=player_steamid,json=playerSteamid" json:"player_steamid"`
}

func (m *CMsgGCShowItemsPickedUp) Reset()         { *m = CMsgGCShowItemsPickedUp{} }
func (m *CMsgGCShowItemsPickedUp) String() string { return proto.CompactTextString(m) }
func (*CMsgGCShowItemsPickedUp) ProtoMessage()    {}
func (*CMsgGCShowItemsPickedUp) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{46}
}

func (m *CMsgGCShowItemsPickedUp) GetPlayerSteamid() uint64 {
	if m != nil {
		return m.PlayerSteamid
	}
	return 0
}

type CMsgGCIncrementKillCountResponse struct {
	KillerAccountId uint32 `protobuf:"varint,1,opt,name=killer_account_id,json=killerAccountId" json:"killer_account_id"`
	NumKills        uint32 `protobuf:"varint,2,opt,name=num_kills,json=numKills" json:"num_kills"`
	ItemDef         uint32 `protobuf:"varint,3,opt,name=item_def,json=itemDef" json:"item_def"`
	LevelType       uint32 `protobuf:"varint,4,opt,name=level_type,json=levelType" json:"level_type"`
}

func (m *CMsgGCIncrementKillCountResponse) Reset()         { *m = CMsgGCIncrementKillCountResponse{} }
func (m *CMsgGCIncrementKillCountResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCIncrementKillCountResponse) ProtoMessage()    {}
func (*CMsgGCIncrementKillCountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{47}
}

func (m *CMsgGCIncrementKillCountResponse) GetKillerAccountId() uint32 {
	if m != nil {
		return m.KillerAccountId
	}
	return 0
}

func (m *CMsgGCIncrementKillCountResponse) GetNumKills() uint32 {
	if m != nil {
		return m.NumKills
	}
	return 0
}

func (m *CMsgGCIncrementKillCountResponse) GetItemDef() uint32 {
	if m != nil {
		return m.ItemDef
	}
	return 0
}

func (m *CMsgGCIncrementKillCountResponse) GetLevelType() uint32 {
	if m != nil {
		return m.LevelType
	}
	return 0
}

type CSOEconItemDropRateBonus struct {
	AccountId      uint32  `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	ExpirationDate uint32  `protobuf:"fixed32,2,opt,name=expiration_date,json=expirationDate" json:"expiration_date"`
	Bonus          float32 `protobuf:"fixed32,3,opt,name=bonus" json:"bonus"`
	BonusCount     uint32  `protobuf:"varint,4,opt,name=bonus_count,json=bonusCount" json:"bonus_count"`
	ItemId         uint64  `protobuf:"varint,5,opt,name=item_id,json=itemId" json:"item_id"`
	DefIndex       uint32  `protobuf:"varint,6,opt,name=def_index,json=defIndex" json:"def_index"`
}

func (m *CSOEconItemDropRateBonus) Reset()         { *m = CSOEconItemDropRateBonus{} }
func (m *CSOEconItemDropRateBonus) String() string { return proto.CompactTextString(m) }
func (*CSOEconItemDropRateBonus) ProtoMessage()    {}
func (*CSOEconItemDropRateBonus) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{48}
}

func (m *CSOEconItemDropRateBonus) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CSOEconItemDropRateBonus) GetExpirationDate() uint32 {
	if m != nil {
		return m.ExpirationDate
	}
	return 0
}

func (m *CSOEconItemDropRateBonus) GetBonus() float32 {
	if m != nil {
		return m.Bonus
	}
	return 0
}

func (m *CSOEconItemDropRateBonus) GetBonusCount() uint32 {
	if m != nil {
		return m.BonusCount
	}
	return 0
}

func (m *CSOEconItemDropRateBonus) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *CSOEconItemDropRateBonus) GetDefIndex() uint32 {
	if m != nil {
		return m.DefIndex
	}
	return 0
}

type CSOEconItemLeagueViewPass struct {
	AccountId uint32 `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	LeagueId  uint32 `protobuf:"varint,2,opt,name=league_id,json=leagueId" json:"league_id"`
	Admin     uint32 `protobuf:"varint,3,opt,name=admin" json:"admin"`
	Itemindex uint32 `protobuf:"varint,4,opt,name=itemindex" json:"itemindex"`
}

func (m *CSOEconItemLeagueViewPass) Reset()         { *m = CSOEconItemLeagueViewPass{} }
func (m *CSOEconItemLeagueViewPass) String() string { return proto.CompactTextString(m) }
func (*CSOEconItemLeagueViewPass) ProtoMessage()    {}
func (*CSOEconItemLeagueViewPass) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{49}
}

func (m *CSOEconItemLeagueViewPass) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CSOEconItemLeagueViewPass) GetLeagueId() uint32 {
	if m != nil {
		return m.LeagueId
	}
	return 0
}

func (m *CSOEconItemLeagueViewPass) GetAdmin() uint32 {
	if m != nil {
		return m.Admin
	}
	return 0
}

func (m *CSOEconItemLeagueViewPass) GetItemindex() uint32 {
	if m != nil {
		return m.Itemindex
	}
	return 0
}

type CSOEconItemEventTicket struct {
	AccountId uint32 `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	EventId   uint32 `protobuf:"varint,2,opt,name=event_id,json=eventId" json:"event_id"`
	ItemId    uint64 `protobuf:"varint,3,opt,name=item_id,json=itemId" json:"item_id"`
}

func (m *CSOEconItemEventTicket) Reset()         { *m = CSOEconItemEventTicket{} }
func (m *CSOEconItemEventTicket) String() string { return proto.CompactTextString(m) }
func (*CSOEconItemEventTicket) ProtoMessage()    {}
func (*CSOEconItemEventTicket) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{50}
}

func (m *CSOEconItemEventTicket) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CSOEconItemEventTicket) GetEventId() uint32 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *CSOEconItemEventTicket) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

type CMsgGCItemPreviewItemBoughtNotification struct {
	ItemDefIndex uint32 `protobuf:"varint,1,opt,name=item_def_index,json=itemDefIndex" json:"item_def_index"`
}

func (m *CMsgGCItemPreviewItemBoughtNotification) Reset() {
	*m = CMsgGCItemPreviewItemBoughtNotification{}
}
func (m *CMsgGCItemPreviewItemBoughtNotification) String() string { return proto.CompactTextString(m) }
func (*CMsgGCItemPreviewItemBoughtNotification) ProtoMessage()    {}
func (*CMsgGCItemPreviewItemBoughtNotification) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{51}
}

func (m *CMsgGCItemPreviewItemBoughtNotification) GetItemDefIndex() uint32 {
	if m != nil {
		return m.ItemDefIndex
	}
	return 0
}

type CMsgGCStorePurchaseCancel struct {
	TxnId uint64 `protobuf:"varint,1,opt,name=txn_id,json=txnId" json:"txn_id"`
}

func (m *CMsgGCStorePurchaseCancel) Reset()         { *m = CMsgGCStorePurchaseCancel{} }
func (m *CMsgGCStorePurchaseCancel) String() string { return proto.CompactTextString(m) }
func (*CMsgGCStorePurchaseCancel) ProtoMessage()    {}
func (*CMsgGCStorePurchaseCancel) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{52}
}

func (m *CMsgGCStorePurchaseCancel) GetTxnId() uint64 {
	if m != nil {
		return m.TxnId
	}
	return 0
}

type CMsgGCStorePurchaseCancelResponse struct {
	Result uint32 `protobuf:"varint,1,opt,name=result" json:"result"`
}

func (m *CMsgGCStorePurchaseCancelResponse) Reset()         { *m = CMsgGCStorePurchaseCancelResponse{} }
func (m *CMsgGCStorePurchaseCancelResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCStorePurchaseCancelResponse) ProtoMessage()    {}
func (*CMsgGCStorePurchaseCancelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{53}
}

func (m *CMsgGCStorePurchaseCancelResponse) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type CMsgGCStorePurchaseFinalize struct {
	TxnId uint64 `protobuf:"varint,1,opt,name=txn_id,json=txnId" json:"txn_id"`
}

func (m *CMsgGCStorePurchaseFinalize) Reset()         { *m = CMsgGCStorePurchaseFinalize{} }
func (m *CMsgGCStorePurchaseFinalize) String() string { return proto.CompactTextString(m) }
func (*CMsgGCStorePurchaseFinalize) ProtoMessage()    {}
func (*CMsgGCStorePurchaseFinalize) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{54}
}

func (m *CMsgGCStorePurchaseFinalize) GetTxnId() uint64 {
	if m != nil {
		return m.TxnId
	}
	return 0
}

type CMsgGCStorePurchaseFinalizeResponse struct {
	Result  uint32   `protobuf:"varint,1,opt,name=result" json:"result"`
	ItemIds []uint64 `protobuf:"varint,2,rep,name=item_ids,json=itemIds" json:"item_ids,omitempty"`
}

func (m *CMsgGCStorePurchaseFinalizeResponse) Reset()         { *m = CMsgGCStorePurchaseFinalizeResponse{} }
func (m *CMsgGCStorePurchaseFinalizeResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCStorePurchaseFinalizeResponse) ProtoMessage()    {}
func (*CMsgGCStorePurchaseFinalizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{55}
}

func (m *CMsgGCStorePurchaseFinalizeResponse) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *CMsgGCStorePurchaseFinalizeResponse) GetItemIds() []uint64 {
	if m != nil {
		return m.ItemIds
	}
	return nil
}

type CMsgGCBannedWordListRequest struct {
	BanListGroupId uint32 `protobuf:"varint,1,opt,name=ban_list_group_id,json=banListGroupId" json:"ban_list_group_id"`
	WordId         uint32 `protobuf:"varint,2,opt,name=word_id,json=wordId" json:"word_id"`
}

func (m *CMsgGCBannedWordListRequest) Reset()         { *m = CMsgGCBannedWordListRequest{} }
func (m *CMsgGCBannedWordListRequest) String() string { return proto.CompactTextString(m) }
func (*CMsgGCBannedWordListRequest) ProtoMessage()    {}
func (*CMsgGCBannedWordListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{56}
}

func (m *CMsgGCBannedWordListRequest) GetBanListGroupId() uint32 {
	if m != nil {
		return m.BanListGroupId
	}
	return 0
}

func (m *CMsgGCBannedWordListRequest) GetWordId() uint32 {
	if m != nil {
		return m.WordId
	}
	return 0
}

type CMsgGCRequestAnnouncements struct {
}

func (m *CMsgGCRequestAnnouncements) Reset()         { *m = CMsgGCRequestAnnouncements{} }
func (m *CMsgGCRequestAnnouncements) String() string { return proto.CompactTextString(m) }
func (*CMsgGCRequestAnnouncements) ProtoMessage()    {}
func (*CMsgGCRequestAnnouncements) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{57}
}

type CMsgGCRequestAnnouncementsResponse struct {
	AnnouncementTitle string `protobuf:"bytes,1,opt,name=announcement_title,json=announcementTitle" json:"announcement_title"`
	Announcement      string `protobuf:"bytes,2,opt,name=announcement" json:"announcement"`
	NextmatchTitle    string `protobuf:"bytes,3,opt,name=nextmatch_title,json=nextmatchTitle" json:"nextmatch_title"`
	Nextmatch         string `protobuf:"bytes,4,opt,name=nextmatch" json:"nextmatch"`
}

func (m *CMsgGCRequestAnnouncementsResponse) Reset()         { *m = CMsgGCRequestAnnouncementsResponse{} }
func (m *CMsgGCRequestAnnouncementsResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCRequestAnnouncementsResponse) ProtoMessage()    {}
func (*CMsgGCRequestAnnouncementsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{58}
}

func (m *CMsgGCRequestAnnouncementsResponse) GetAnnouncementTitle() string {
	if m != nil {
		return m.AnnouncementTitle
	}
	return ""
}

func (m *CMsgGCRequestAnnouncementsResponse) GetAnnouncement() string {
	if m != nil {
		return m.Announcement
	}
	return ""
}

func (m *CMsgGCRequestAnnouncementsResponse) GetNextmatchTitle() string {
	if m != nil {
		return m.NextmatchTitle
	}
	return ""
}

func (m *CMsgGCRequestAnnouncementsResponse) GetNextmatch() string {
	if m != nil {
		return m.Nextmatch
	}
	return ""
}

type CMsgGCBannedWord struct {
	WordId   uint32             `protobuf:"varint,1,opt,name=word_id,json=wordId" json:"word_id"`
	WordType *GC_BannedWordType `protobuf:"varint,2,opt,name=word_type,json=wordType,enum=GC_BannedWordType,def=0" json:"word_type,omitempty"`
	Word     string             `protobuf:"bytes,3,opt,name=word" json:"word"`
}

func (m *CMsgGCBannedWord) Reset()                    { *m = CMsgGCBannedWord{} }
func (m *CMsgGCBannedWord) String() string            { return proto.CompactTextString(m) }
func (*CMsgGCBannedWord) ProtoMessage()               {}
func (*CMsgGCBannedWord) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{59} }

const Default_CMsgGCBannedWord_WordType GC_BannedWordType = GC_BannedWordType_GC_BANNED_WORD_DISABLE_WORD

func (m *CMsgGCBannedWord) GetWordId() uint32 {
	if m != nil {
		return m.WordId
	}
	return 0
}

func (m *CMsgGCBannedWord) GetWordType() GC_BannedWordType {
	if m != nil && m.WordType != nil {
		return *m.WordType
	}
	return Default_CMsgGCBannedWord_WordType
}

func (m *CMsgGCBannedWord) GetWord() string {
	if m != nil {
		return m.Word
	}
	return ""
}

type CMsgGCBannedWordListResponse struct {
	BanListGroupId uint32              `protobuf:"varint,1,opt,name=ban_list_group_id,json=banListGroupId" json:"ban_list_group_id"`
	WordList       []*CMsgGCBannedWord `protobuf:"bytes,2,rep,name=word_list,json=wordList" json:"word_list,omitempty"`
}

func (m *CMsgGCBannedWordListResponse) Reset()         { *m = CMsgGCBannedWordListResponse{} }
func (m *CMsgGCBannedWordListResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCBannedWordListResponse) ProtoMessage()    {}
func (*CMsgGCBannedWordListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{60}
}

func (m *CMsgGCBannedWordListResponse) GetBanListGroupId() uint32 {
	if m != nil {
		return m.BanListGroupId
	}
	return 0
}

func (m *CMsgGCBannedWordListResponse) GetWordList() []*CMsgGCBannedWord {
	if m != nil {
		return m.WordList
	}
	return nil
}

type CMsgGCToGCBannedWordListBroadcast struct {
	Broadcast *CMsgGCBannedWordListResponse `protobuf:"bytes,1,opt,name=broadcast" json:"broadcast,omitempty"`
}

func (m *CMsgGCToGCBannedWordListBroadcast) Reset()         { *m = CMsgGCToGCBannedWordListBroadcast{} }
func (m *CMsgGCToGCBannedWordListBroadcast) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCBannedWordListBroadcast) ProtoMessage()    {}
func (*CMsgGCToGCBannedWordListBroadcast) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{61}
}

func (m *CMsgGCToGCBannedWordListBroadcast) GetBroadcast() *CMsgGCBannedWordListResponse {
	if m != nil {
		return m.Broadcast
	}
	return nil
}

type CMsgGCToGCBannedWordListUpdated struct {
	GroupId uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id"`
}

func (m *CMsgGCToGCBannedWordListUpdated) Reset()         { *m = CMsgGCToGCBannedWordListUpdated{} }
func (m *CMsgGCToGCBannedWordListUpdated) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCBannedWordListUpdated) ProtoMessage()    {}
func (*CMsgGCToGCBannedWordListUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{62}
}

func (m *CMsgGCToGCBannedWordListUpdated) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type CSOEconDefaultEquippedDefinitionInstanceClient struct {
	AccountId      uint32 `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	ItemDefinition uint32 `protobuf:"varint,2,opt,name=item_definition,json=itemDefinition" json:"item_definition"`
	ClassId        uint32 `protobuf:"varint,3,opt,name=class_id,json=classId" json:"class_id"`
	SlotId         uint32 `protobuf:"varint,4,opt,name=slot_id,json=slotId" json:"slot_id"`
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) Reset() {
	*m = CSOEconDefaultEquippedDefinitionInstanceClient{}
}
func (m *CSOEconDefaultEquippedDefinitionInstanceClient) String() string {
	return proto.CompactTextString(m)
}
func (*CSOEconDefaultEquippedDefinitionInstanceClient) ProtoMessage() {}
func (*CSOEconDefaultEquippedDefinitionInstanceClient) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{63}
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) GetItemDefinition() uint32 {
	if m != nil {
		return m.ItemDefinition
	}
	return 0
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) GetClassId() uint32 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) GetSlotId() uint32 {
	if m != nil {
		return m.SlotId
	}
	return 0
}

type CMsgGCToGCDirtySDOCache struct {
	SdoType   uint32 `protobuf:"varint,1,opt,name=sdo_type,json=sdoType" json:"sdo_type"`
	KeyUint64 uint64 `protobuf:"varint,2,opt,name=key_uint64,json=keyUint64" json:"key_uint64"`
}

func (m *CMsgGCToGCDirtySDOCache) Reset()         { *m = CMsgGCToGCDirtySDOCache{} }
func (m *CMsgGCToGCDirtySDOCache) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCDirtySDOCache) ProtoMessage()    {}
func (*CMsgGCToGCDirtySDOCache) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{64}
}

func (m *CMsgGCToGCDirtySDOCache) GetSdoType() uint32 {
	if m != nil {
		return m.SdoType
	}
	return 0
}

func (m *CMsgGCToGCDirtySDOCache) GetKeyUint64() uint64 {
	if m != nil {
		return m.KeyUint64
	}
	return 0
}

type CMsgGCToGCDirtyMultipleSDOCache struct {
	SdoType   uint32   `protobuf:"varint,1,opt,name=sdo_type,json=sdoType" json:"sdo_type"`
	KeyUint64 []uint64 `protobuf:"varint,2,rep,name=key_uint64,json=keyUint64" json:"key_uint64,omitempty"`
}

func (m *CMsgGCToGCDirtyMultipleSDOCache) Reset()         { *m = CMsgGCToGCDirtyMultipleSDOCache{} }
func (m *CMsgGCToGCDirtyMultipleSDOCache) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCDirtyMultipleSDOCache) ProtoMessage()    {}
func (*CMsgGCToGCDirtyMultipleSDOCache) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{65}
}

func (m *CMsgGCToGCDirtyMultipleSDOCache) GetSdoType() uint32 {
	if m != nil {
		return m.SdoType
	}
	return 0
}

func (m *CMsgGCToGCDirtyMultipleSDOCache) GetKeyUint64() []uint64 {
	if m != nil {
		return m.KeyUint64
	}
	return nil
}

type CMsgGCCollectItem struct {
	CollectionItemId uint64 `protobuf:"varint,1,opt,name=collection_item_id,json=collectionItemId" json:"collection_item_id"`
	SubjectItemId    uint64 `protobuf:"varint,2,opt,name=subject_item_id,json=subjectItemId" json:"subject_item_id"`
}

func (m *CMsgGCCollectItem) Reset()                    { *m = CMsgGCCollectItem{} }
func (m *CMsgGCCollectItem) String() string            { return proto.CompactTextString(m) }
func (*CMsgGCCollectItem) ProtoMessage()               {}
func (*CMsgGCCollectItem) Descriptor() ([]byte, []int) { return fileDescriptorBaseGcmessages, []int{66} }

func (m *CMsgGCCollectItem) GetCollectionItemId() uint64 {
	if m != nil {
		return m.CollectionItemId
	}
	return 0
}

func (m *CMsgGCCollectItem) GetSubjectItemId() uint64 {
	if m != nil {
		return m.SubjectItemId
	}
	return 0
}

type CMsgSDONoMemcached struct {
}

func (m *CMsgSDONoMemcached) Reset()         { *m = CMsgSDONoMemcached{} }
func (m *CMsgSDONoMemcached) String() string { return proto.CompactTextString(m) }
func (*CMsgSDONoMemcached) ProtoMessage()    {}
func (*CMsgSDONoMemcached) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{67}
}

type CMsgGCToGCUpdateSQLKeyValue struct {
	KeyName string `protobuf:"bytes,1,opt,name=key_name,json=keyName" json:"key_name"`
}

func (m *CMsgGCToGCUpdateSQLKeyValue) Reset()         { *m = CMsgGCToGCUpdateSQLKeyValue{} }
func (m *CMsgGCToGCUpdateSQLKeyValue) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCUpdateSQLKeyValue) ProtoMessage()    {}
func (*CMsgGCToGCUpdateSQLKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{68}
}

func (m *CMsgGCToGCUpdateSQLKeyValue) GetKeyName() string {
	if m != nil {
		return m.KeyName
	}
	return ""
}

type CMsgGCToGCIsTrustedServer struct {
	SteamId uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
}

func (m *CMsgGCToGCIsTrustedServer) Reset()         { *m = CMsgGCToGCIsTrustedServer{} }
func (m *CMsgGCToGCIsTrustedServer) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCIsTrustedServer) ProtoMessage()    {}
func (*CMsgGCToGCIsTrustedServer) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{69}
}

func (m *CMsgGCToGCIsTrustedServer) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

type CMsgGCToGCIsTrustedServerResponse struct {
	IsTrusted bool `protobuf:"varint,1,opt,name=is_trusted,json=isTrusted" json:"is_trusted"`
}

func (m *CMsgGCToGCIsTrustedServerResponse) Reset()         { *m = CMsgGCToGCIsTrustedServerResponse{} }
func (m *CMsgGCToGCIsTrustedServerResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCIsTrustedServerResponse) ProtoMessage()    {}
func (*CMsgGCToGCIsTrustedServerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{70}
}

func (m *CMsgGCToGCIsTrustedServerResponse) GetIsTrusted() bool {
	if m != nil {
		return m.IsTrusted
	}
	return false
}

type CMsgGCToGCBroadcastConsoleCommand struct {
	ConCommand string `protobuf:"bytes,1,opt,name=con_command,json=conCommand" json:"con_command"`
}

func (m *CMsgGCToGCBroadcastConsoleCommand) Reset()         { *m = CMsgGCToGCBroadcastConsoleCommand{} }
func (m *CMsgGCToGCBroadcastConsoleCommand) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCBroadcastConsoleCommand) ProtoMessage()    {}
func (*CMsgGCToGCBroadcastConsoleCommand) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{71}
}

func (m *CMsgGCToGCBroadcastConsoleCommand) GetConCommand() string {
	if m != nil {
		return m.ConCommand
	}
	return ""
}

type CMsgGCServerVersionUpdated struct {
	ServerVersion uint32 `protobuf:"varint,1,opt,name=server_version,json=serverVersion" json:"server_version"`
}

func (m *CMsgGCServerVersionUpdated) Reset()         { *m = CMsgGCServerVersionUpdated{} }
func (m *CMsgGCServerVersionUpdated) String() string { return proto.CompactTextString(m) }
func (*CMsgGCServerVersionUpdated) ProtoMessage()    {}
func (*CMsgGCServerVersionUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{72}
}

func (m *CMsgGCServerVersionUpdated) GetServerVersion() uint32 {
	if m != nil {
		return m.ServerVersion
	}
	return 0
}

type CMsgGCClientVersionUpdated struct {
	ClientVersion uint32 `protobuf:"varint,1,opt,name=client_version,json=clientVersion" json:"client_version"`
}

func (m *CMsgGCClientVersionUpdated) Reset()         { *m = CMsgGCClientVersionUpdated{} }
func (m *CMsgGCClientVersionUpdated) String() string { return proto.CompactTextString(m) }
func (*CMsgGCClientVersionUpdated) ProtoMessage()    {}
func (*CMsgGCClientVersionUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{73}
}

func (m *CMsgGCClientVersionUpdated) GetClientVersion() uint32 {
	if m != nil {
		return m.ClientVersion
	}
	return 0
}

type CMsgGCToGCWebAPIAccountChanged struct {
}

func (m *CMsgGCToGCWebAPIAccountChanged) Reset()         { *m = CMsgGCToGCWebAPIAccountChanged{} }
func (m *CMsgGCToGCWebAPIAccountChanged) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCWebAPIAccountChanged) ProtoMessage()    {}
func (*CMsgGCToGCWebAPIAccountChanged) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{74}
}

type CMsgGCToGCRequestPassportItemGrant struct {
	SteamId    uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	LeagueId   uint32 `protobuf:"varint,2,opt,name=league_id,json=leagueId" json:"league_id"`
	RewardFlag int32  `protobuf:"varint,3,opt,name=reward_flag,json=rewardFlag" json:"reward_flag"`
}

func (m *CMsgGCToGCRequestPassportItemGrant) Reset()         { *m = CMsgGCToGCRequestPassportItemGrant{} }
func (m *CMsgGCToGCRequestPassportItemGrant) String() string { return proto.CompactTextString(m) }
func (*CMsgGCToGCRequestPassportItemGrant) ProtoMessage()    {}
func (*CMsgGCToGCRequestPassportItemGrant) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{75}
}

func (m *CMsgGCToGCRequestPassportItemGrant) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgGCToGCRequestPassportItemGrant) GetLeagueId() uint32 {
	if m != nil {
		return m.LeagueId
	}
	return 0
}

func (m *CMsgGCToGCRequestPassportItemGrant) GetRewardFlag() int32 {
	if m != nil {
		return m.RewardFlag
	}
	return 0
}

type CMsgGameServerInfo struct {
	ServerPublicIpAddr          uint32                         `protobuf:"fixed32,1,opt,name=server_public_ip_addr,json=serverPublicIpAddr" json:"server_public_ip_addr"`
	ServerPrivateIpAddr         uint32                         `protobuf:"fixed32,2,opt,name=server_private_ip_addr,json=serverPrivateIpAddr" json:"server_private_ip_addr"`
	ServerPort                  uint32                         `protobuf:"varint,3,opt,name=server_port,json=serverPort" json:"server_port"`
	ServerTvPort                uint32                         `protobuf:"varint,4,opt,name=server_tv_port,json=serverTvPort" json:"server_tv_port"`
	ServerKey                   string                         `protobuf:"bytes,5,opt,name=server_key,json=serverKey" json:"server_key"`
	ServerHibernation           bool                           `protobuf:"varint,6,opt,name=server_hibernation,json=serverHibernation" json:"server_hibernation"`
	ServerType                  *CMsgGameServerInfo_ServerType `protobuf:"varint,7,opt,name=server_type,json=serverType,enum=CMsgGameServerInfo_ServerType,def=0" json:"server_type,omitempty"`
	ServerRegion                uint32                         `protobuf:"varint,8,opt,name=server_region,json=serverRegion" json:"server_region"`
	ServerLoadavg               float32                        `protobuf:"fixed32,9,opt,name=server_loadavg,json=serverLoadavg" json:"server_loadavg"`
	ServerTvBroadcastTime       float32                        `protobuf:"fixed32,10,opt,name=server_tv_broadcast_time,json=serverTvBroadcastTime" json:"server_tv_broadcast_time"`
	ServerGameTime              float32                        `protobuf:"fixed32,11,opt,name=server_game_time,json=serverGameTime" json:"server_game_time"`
	ServerRelayConnectedSteamId uint64                         `protobuf:"fixed64,12,opt,name=server_relay_connected_steam_id,json=serverRelayConnectedSteamId" json:"server_relay_connected_steam_id"`
	RelaySlotsMax               uint32                         `protobuf:"varint,13,opt,name=relay_slots_max,json=relaySlotsMax" json:"relay_slots_max"`
	RelaysConnected             int32                          `protobuf:"varint,14,opt,name=relays_connected,json=relaysConnected" json:"relays_connected"`
	RelayClientsConnected       int32                          `protobuf:"varint,15,opt,name=relay_clients_connected,json=relayClientsConnected" json:"relay_clients_connected"`
	RelayedGameServerSteamId    uint64                         `protobuf:"fixed64,16,opt,name=relayed_game_server_steam_id,json=relayedGameServerSteamId" json:"relayed_game_server_steam_id"`
	ParentRelayCount            uint32                         `protobuf:"varint,17,opt,name=parent_relay_count,json=parentRelayCount" json:"parent_relay_count"`
	TvSecretCode                uint64                         `protobuf:"fixed64,18,opt,name=tv_secret_code,json=tvSecretCode" json:"tv_secret_code"`
}

func (m *CMsgGameServerInfo) Reset()         { *m = CMsgGameServerInfo{} }
func (m *CMsgGameServerInfo) String() string { return proto.CompactTextString(m) }
func (*CMsgGameServerInfo) ProtoMessage()    {}
func (*CMsgGameServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorBaseGcmessages, []int{76}
}

const Default_CMsgGameServerInfo_ServerType CMsgGameServerInfo_ServerType = CMsgGameServerInfo_UNSPECIFIED

func (m *CMsgGameServerInfo) GetServerPublicIpAddr() uint32 {
	if m != nil {
		return m.ServerPublicIpAddr
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerPrivateIpAddr() uint32 {
	if m != nil {
		return m.ServerPrivateIpAddr
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerTvPort() uint32 {
	if m != nil {
		return m.ServerTvPort
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerKey() string {
	if m != nil {
		return m.ServerKey
	}
	return ""
}

func (m *CMsgGameServerInfo) GetServerHibernation() bool {
	if m != nil {
		return m.ServerHibernation
	}
	return false
}

func (m *CMsgGameServerInfo) GetServerType() CMsgGameServerInfo_ServerType {
	if m != nil && m.ServerType != nil {
		return *m.ServerType
	}
	return Default_CMsgGameServerInfo_ServerType
}

func (m *CMsgGameServerInfo) GetServerRegion() uint32 {
	if m != nil {
		return m.ServerRegion
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerLoadavg() float32 {
	if m != nil {
		return m.ServerLoadavg
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerTvBroadcastTime() float32 {
	if m != nil {
		return m.ServerTvBroadcastTime
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerGameTime() float32 {
	if m != nil {
		return m.ServerGameTime
	}
	return 0
}

func (m *CMsgGameServerInfo) GetServerRelayConnectedSteamId() uint64 {
	if m != nil {
		return m.ServerRelayConnectedSteamId
	}
	return 0
}

func (m *CMsgGameServerInfo) GetRelaySlotsMax() uint32 {
	if m != nil {
		return m.RelaySlotsMax
	}
	return 0
}

func (m *CMsgGameServerInfo) GetRelaysConnected() int32 {
	if m != nil {
		return m.RelaysConnected
	}
	return 0
}

func (m *CMsgGameServerInfo) GetRelayClientsConnected() int32 {
	if m != nil {
		return m.RelayClientsConnected
	}
	return 0
}

func (m *CMsgGameServerInfo) GetRelayedGameServerSteamId() uint64 {
	if m != nil {
		return m.RelayedGameServerSteamId
	}
	return 0
}

func (m *CMsgGameServerInfo) GetParentRelayCount() uint32 {
	if m != nil {
		return m.ParentRelayCount
	}
	return 0
}

func (m *CMsgGameServerInfo) GetTvSecretCode() uint64 {
	if m != nil {
		return m.TvSecretCode
	}
	return 0
}

func init() {
	proto.RegisterType((*CGCStorePurchaseInit_LineItem)(nil), "CGCStorePurchaseInit_LineItem")
	proto.RegisterType((*CMsgGCStorePurchaseInit)(nil), "CMsgGCStorePurchaseInit")
	proto.RegisterType((*CMsgGCStorePurchaseInitResponse)(nil), "CMsgGCStorePurchaseInitResponse")
	proto.RegisterType((*CSOPartyInvite)(nil), "CSOPartyInvite")
	proto.RegisterType((*CSOLobbyInvite)(nil), "CSOLobbyInvite")
	proto.RegisterType((*CMsgSystemBroadcast)(nil), "CMsgSystemBroadcast")
	proto.RegisterType((*CMsgInviteToParty)(nil), "CMsgInviteToParty")
	proto.RegisterType((*CMsgInvitationCreated)(nil), "CMsgInvitationCreated")
	proto.RegisterType((*CMsgPartyInviteResponse)(nil), "CMsgPartyInviteResponse")
	proto.RegisterType((*CMsgKickFromParty)(nil), "CMsgKickFromParty")
	proto.RegisterType((*CMsgLeaveParty)(nil), "CMsgLeaveParty")
	proto.RegisterType((*CMsgServerAvailable)(nil), "CMsgServerAvailable")
	proto.RegisterType((*CMsgLANServerAvailable)(nil), "CMsgLANServerAvailable")
	proto.RegisterType((*CSOEconGameAccountClient)(nil), "CSOEconGameAccountClient")
	proto.RegisterType((*CSOItemCriteriaCondition)(nil), "CSOItemCriteriaCondition")
	proto.RegisterType((*CSOItemCriteria)(nil), "CSOItemCriteria")
	proto.RegisterType((*CSOItemRecipe)(nil), "CSOItemRecipe")
	proto.RegisterType((*CMsgDevNewItemRequest)(nil), "CMsgDevNewItemRequest")
	proto.RegisterType((*CMsgIncrementKillCountAttribute)(nil), "CMsgIncrementKillCountAttribute")
	proto.RegisterType((*CMsgApplySticker)(nil), "CMsgApplySticker")
	proto.RegisterType((*CMsgApplyStatTrakSwap)(nil), "CMsgApplyStatTrakSwap")
	proto.RegisterType((*CMsgApplyStrangePart)(nil), "CMsgApplyStrangePart")
	proto.RegisterType((*CMsgApplyPennantUpgrade)(nil), "CMsgApplyPennantUpgrade")
	proto.RegisterType((*CMsgApplyEggEssence)(nil), "CMsgApplyEggEssence")
	proto.RegisterType((*CSOEconItemAttribute)(nil), "CSOEconItemAttribute")
	proto.RegisterType((*CSOEconItemEquipped)(nil), "CSOEconItemEquipped")
	proto.RegisterType((*CSOEconItem)(nil), "CSOEconItem")
	proto.RegisterType((*CMsgAdjustItemEquippedState)(nil), "CMsgAdjustItemEquippedState")
	proto.RegisterType((*CMsgSortItems)(nil), "CMsgSortItems")
	proto.RegisterType((*CSOEconClaimCode)(nil), "CSOEconClaimCode")
	proto.RegisterType((*CMsgStoreGetUserData)(nil), "CMsgStoreGetUserData")
	proto.RegisterType((*CMsgStoreGetUserDataResponse)(nil), "CMsgStoreGetUserDataResponse")
	proto.RegisterType((*CMsgUpdateItemSchema)(nil), "CMsgUpdateItemSchema")
	proto.RegisterType((*CMsgGCError)(nil), "CMsgGCError")
	proto.RegisterType((*CMsgRequestInventoryRefresh)(nil), "CMsgRequestInventoryRefresh")
	proto.RegisterType((*CMsgConVarValue)(nil), "CMsgConVarValue")
	proto.RegisterType((*CMsgReplicateConVars)(nil), "CMsgReplicateConVars")
	proto.RegisterType((*CMsgUseItem)(nil), "CMsgUseItem")
	proto.RegisterType((*CMsgReplayUploadedToYouTube)(nil), "CMsgReplayUploadedToYouTube")
	proto.RegisterType((*CMsgConsumableExhausted)(nil), "CMsgConsumableExhausted")
	proto.RegisterType((*CMsgItemAcknowledged__DEPRECATED)(nil), "CMsgItemAcknowledged__DEPRECATED")
	proto.RegisterType((*CMsgSetItemPositions)(nil), "CMsgSetItemPositions")
	proto.RegisterType((*CMsgSetItemPositions_ItemPosition)(nil), "CMsgSetItemPositions.ItemPosition")
	proto.RegisterType((*CMsgGCReportAbuse)(nil), "CMsgGCReportAbuse")
	proto.RegisterType((*CMsgGCReportAbuseResponse)(nil), "CMsgGCReportAbuseResponse")
	proto.RegisterType((*CMsgGCNameItemNotification)(nil), "CMsgGCNameItemNotification")
	proto.RegisterType((*CMsgGCClientDisplayNotification)(nil), "CMsgGCClientDisplayNotification")
	proto.RegisterType((*CMsgGCShowItemsPickedUp)(nil), "CMsgGCShowItemsPickedUp")
	proto.RegisterType((*CMsgGCIncrementKillCountResponse)(nil), "CMsgGCIncrementKillCountResponse")
	proto.RegisterType((*CSOEconItemDropRateBonus)(nil), "CSOEconItemDropRateBonus")
	proto.RegisterType((*CSOEconItemLeagueViewPass)(nil), "CSOEconItemLeagueViewPass")
	proto.RegisterType((*CSOEconItemEventTicket)(nil), "CSOEconItemEventTicket")
	proto.RegisterType((*CMsgGCItemPreviewItemBoughtNotification)(nil), "CMsgGCItemPreviewItemBoughtNotification")
	proto.RegisterType((*CMsgGCStorePurchaseCancel)(nil), "CMsgGCStorePurchaseCancel")
	proto.RegisterType((*CMsgGCStorePurchaseCancelResponse)(nil), "CMsgGCStorePurchaseCancelResponse")
	proto.RegisterType((*CMsgGCStorePurchaseFinalize)(nil), "CMsgGCStorePurchaseFinalize")
	proto.RegisterType((*CMsgGCStorePurchaseFinalizeResponse)(nil), "CMsgGCStorePurchaseFinalizeResponse")
	proto.RegisterType((*CMsgGCBannedWordListRequest)(nil), "CMsgGCBannedWordListRequest")
	proto.RegisterType((*CMsgGCRequestAnnouncements)(nil), "CMsgGCRequestAnnouncements")
	proto.RegisterType((*CMsgGCRequestAnnouncementsResponse)(nil), "CMsgGCRequestAnnouncementsResponse")
	proto.RegisterType((*CMsgGCBannedWord)(nil), "CMsgGCBannedWord")
	proto.RegisterType((*CMsgGCBannedWordListResponse)(nil), "CMsgGCBannedWordListResponse")
	proto.RegisterType((*CMsgGCToGCBannedWordListBroadcast)(nil), "CMsgGCToGCBannedWordListBroadcast")
	proto.RegisterType((*CMsgGCToGCBannedWordListUpdated)(nil), "CMsgGCToGCBannedWordListUpdated")
	proto.RegisterType((*CSOEconDefaultEquippedDefinitionInstanceClient)(nil), "CSOEconDefaultEquippedDefinitionInstanceClient")
	proto.RegisterType((*CMsgGCToGCDirtySDOCache)(nil), "CMsgGCToGCDirtySDOCache")
	proto.RegisterType((*CMsgGCToGCDirtyMultipleSDOCache)(nil), "CMsgGCToGCDirtyMultipleSDOCache")
	proto.RegisterType((*CMsgGCCollectItem)(nil), "CMsgGCCollectItem")
	proto.RegisterType((*CMsgSDONoMemcached)(nil), "CMsgSDONoMemcached")
	proto.RegisterType((*CMsgGCToGCUpdateSQLKeyValue)(nil), "CMsgGCToGCUpdateSQLKeyValue")
	proto.RegisterType((*CMsgGCToGCIsTrustedServer)(nil), "CMsgGCToGCIsTrustedServer")
	proto.RegisterType((*CMsgGCToGCIsTrustedServerResponse)(nil), "CMsgGCToGCIsTrustedServerResponse")
	proto.RegisterType((*CMsgGCToGCBroadcastConsoleCommand)(nil), "CMsgGCToGCBroadcastConsoleCommand")
	proto.RegisterType((*CMsgGCServerVersionUpdated)(nil), "CMsgGCServerVersionUpdated")
	proto.RegisterType((*CMsgGCClientVersionUpdated)(nil), "CMsgGCClientVersionUpdated")
	proto.RegisterType((*CMsgGCToGCWebAPIAccountChanged)(nil), "CMsgGCToGCWebAPIAccountChanged")
	proto.RegisterType((*CMsgGCToGCRequestPassportItemGrant)(nil), "CMsgGCToGCRequestPassportItemGrant")
	proto.RegisterType((*CMsgGameServerInfo)(nil), "CMsgGameServerInfo")
	proto.RegisterEnum("EGCBaseMsg", EGCBaseMsg_name, EGCBaseMsg_value)
	proto.RegisterEnum("EGCBaseProtoObjectTypes", EGCBaseProtoObjectTypes_name, EGCBaseProtoObjectTypes_value)
	proto.RegisterEnum("GC_BannedWordType", GC_BannedWordType_name, GC_BannedWordType_value)
	proto.RegisterEnum("CMsgGameServerInfo_ServerType", CMsgGameServerInfo_ServerType_name, CMsgGameServerInfo_ServerType_value)
}
func (m *CGCStorePurchaseInit_LineItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCStorePurchaseInit_LineItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemDefId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Quantity))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.CostInLocalCurrency))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.PurchaseType))
	return i, nil
}

func (m *CMsgGCStorePurchaseInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCStorePurchaseInit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Country)))
	i += copy(dAtA[i:], m.Country)
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Language))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Currency))
	if len(m.LineItems) > 0 {
		for _, msg := range m.LineItems {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCStorePurchaseInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCStorePurchaseInitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Result))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.TxnId))
	return i, nil
}

func (m *CSOPartyInvite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOPartyInvite) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.GroupId))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.SenderId))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.SenderName)))
	i += copy(dAtA[i:], m.SenderName)
	return i, nil
}

func (m *CSOLobbyInvite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOLobbyInvite) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.GroupId))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.SenderId))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.SenderName)))
	i += copy(dAtA[i:], m.SenderName)
	return i, nil
}

func (m *CMsgSystemBroadcast) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSystemBroadcast) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Message)))
	i += copy(dAtA[i:], m.Message)
	return i, nil
}

func (m *CMsgInviteToParty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgInviteToParty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.SteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ClientVersion))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.TeamInvite))
	return i, nil
}

func (m *CMsgInvitationCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgInvitationCreated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.GroupId))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.SteamId))
	return i, nil
}

func (m *CMsgPartyInviteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgPartyInviteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.PartyId))
	dAtA[i] = 0x10
	i++
	if m.Accept {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ClientVersion))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.TeamInvite))
	return i, nil
}

func (m *CMsgKickFromParty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgKickFromParty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.SteamId))
	return i, nil
}

func (m *CMsgLeaveParty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgLeaveParty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CMsgServerAvailable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgServerAvailable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CMsgLANServerAvailable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgLANServerAvailable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.LobbyId))
	return i, nil
}

func (m *CSOEconGameAccountClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconGameAccountClient) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AdditionalBackpackSlots != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(*m.AdditionalBackpackSlots))
	}
	dAtA[i] = 0x65
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.BonusXpTimestampRefresh))
	dAtA[i] = 0x68
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.BonusXpUsedflags))
	dAtA[i] = 0x70
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ElevatedState))
	dAtA[i] = 0x78
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ElevatedTimestamp))
	return i, nil
}

func (m *CSOItemCriteriaCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOItemCriteriaCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Op))
	dAtA[i] = 0x12
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Field)))
	i += copy(dAtA[i:], m.Field)
	dAtA[i] = 0x18
	i++
	if m.Required {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x25
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.FloatValue))))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.StringValue)))
	i += copy(dAtA[i:], m.StringValue)
	return i, nil
}

func (m *CSOItemCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOItemCriteria) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemLevel))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemQuality))
	dAtA[i] = 0x18
	i++
	if m.ItemLevelSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.ItemQualitySet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.InitialInventory))
	dAtA[i] = 0x30
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.InitialQuantity))
	dAtA[i] = 0x40
	i++
	if m.IgnoreEnabledFlag {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x50
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemRarity))
	dAtA[i] = 0x58
	i++
	if m.ItemRaritySet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x60
	i++
	if m.RecentOnly {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CSOItemRecipe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOItemRecipe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.DefIndex))
	dAtA[i] = 0x12
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.NA)))
	i += copy(dAtA[i:], m.NA)
	dAtA[i] = 0x22
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DescInputs)))
	i += copy(dAtA[i:], m.DescInputs)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DescOutputs)))
	i += copy(dAtA[i:], m.DescOutputs)
	dAtA[i] = 0x32
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DiA)))
	i += copy(dAtA[i:], m.DiA)
	dAtA[i] = 0x3a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DiB)))
	i += copy(dAtA[i:], m.DiB)
	dAtA[i] = 0x42
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DiC)))
	i += copy(dAtA[i:], m.DiC)
	dAtA[i] = 0x4a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DoA)))
	i += copy(dAtA[i:], m.DoA)
	dAtA[i] = 0x52
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DoB)))
	i += copy(dAtA[i:], m.DoB)
	dAtA[i] = 0x5a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.DoC)))
	i += copy(dAtA[i:], m.DoC)
	dAtA[i] = 0x60
	i++
	if m.RequiresAllSameClass {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x68
	i++
	if m.RequiresAllSameSlot {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ClassUsageForOutput))
	dAtA[i] = 0x78
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SlotUsageForOutput))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SetForOutput))
	if len(m.InputItemsCriteria) > 0 {
		for _, msg := range m.InputItemsCriteria {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputItemsCriteria) > 0 {
		for _, msg := range m.OutputItemsCriteria {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InputItemDupeCounts) > 0 {
		for _, num := range m.InputItemDupeCounts {
			dAtA[i] = 0xb0
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CMsgDevNewItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgDevNewItemRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.Receiver))
	if m.Criteria != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Criteria.Size()))
		n1, err := m.Criteria.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *CMsgIncrementKillCountAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgIncrementKillCountAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.KillerAccountId))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.VictimAccountId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.EventType))
	dAtA[i] = 0x28
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Amount))
	return i, nil
}

func (m *CMsgApplySticker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgApplySticker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.StickerItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemItemId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.StickerSlot))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.BaseitemDefidx))
	dAtA[i] = 0x2d
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.StickerWear))))
	return i, nil
}

func (m *CMsgApplyStatTrakSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgApplyStatTrakSwap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ToolItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Item_1ItemId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Item_2ItemId))
	return i, nil
}

func (m *CMsgApplyStrangePart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgApplyStrangePart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.StrangePartItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemItemId))
	return i, nil
}

func (m *CMsgApplyPennantUpgrade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgApplyPennantUpgrade) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.UpgradeItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.PennantItemId))
	return i, nil
}

func (m *CMsgApplyEggEssence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgApplyEggEssence) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.EssenceItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.EggItemId))
	return i, nil
}

func (m *CSOEconItemAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconItemAttribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.DefIndex))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Value))
	if m.ValueBytes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ValueBytes)))
		i += copy(dAtA[i:], m.ValueBytes)
	}
	return i, nil
}

func (m *CSOEconItemEquipped) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconItemEquipped) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.NewClass))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.NewSlot))
	return i, nil
}

func (m *CSOEconItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Inventory))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.DefIndex))
	dAtA[i] = 0x28
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Quantity))
	dAtA[i] = 0x30
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Level))
	dAtA[i] = 0x38
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Quality))
	if m.Flags != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(*m.Flags))
	}
	dAtA[i] = 0x48
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Origin))
	dAtA[i] = 0x52
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.CustomName)))
	i += copy(dAtA[i:], m.CustomName)
	dAtA[i] = 0x5a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.CustomDesc)))
	i += copy(dAtA[i:], m.CustomDesc)
	if len(m.Attribute) > 0 {
		for _, msg := range m.Attribute {
			dAtA[i] = 0x62
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InteriorItem != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.InteriorItem.Size()))
		n2, err := m.InteriorItem.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.InUse != nil {
		dAtA[i] = 0x70
		i++
		if *m.InUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Style != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(*m.Style))
	}
	if m.OriginalId != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(*m.OriginalId))
	}
	if len(m.EquippedState) > 0 {
		for _, msg := range m.EquippedState {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Rarity))
	return i, nil
}

func (m *CMsgAdjustItemEquippedState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAdjustItemEquippedState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.NewClass))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.NewSlot))
	dAtA[i] = 0x20
	i++
	if m.Swap {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgSortItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSortItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SortType))
	return i, nil
}

func (m *CSOEconClaimCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconClaimCode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.CodeType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.TimeAcquired))
	dAtA[i] = 0x22
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Code)))
	i += copy(dAtA[i:], m.Code)
	return i, nil
}

func (m *CMsgStoreGetUserData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgStoreGetUserData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.PriceSheetVersion))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Currency))
	return i, nil
}

func (m *CMsgStoreGetUserDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgStoreGetUserDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Result))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.CurrencyDeprecated))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.CountryDeprecated)))
	i += copy(dAtA[i:], m.CountryDeprecated)
	dAtA[i] = 0x25
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.PriceSheetVersion))
	if m.PriceSheet != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.PriceSheet)))
		i += copy(dAtA[i:], m.PriceSheet)
	}
	return i, nil
}

func (m *CMsgUpdateItemSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgUpdateItemSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemsGame != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ItemsGame)))
		i += copy(dAtA[i:], m.ItemsGame)
	}
	dAtA[i] = 0x15
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.ItemSchemaVersion))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ItemsGameUrl_DEPRECATED2013)))
	i += copy(dAtA[i:], m.ItemsGameUrl_DEPRECATED2013)
	dAtA[i] = 0x22
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ItemsGameUrl)))
	i += copy(dAtA[i:], m.ItemsGameUrl)
	return i, nil
}

func (m *CMsgGCError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ErrorText)))
	i += copy(dAtA[i:], m.ErrorText)
	return i, nil
}

func (m *CMsgRequestInventoryRefresh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgRequestInventoryRefresh) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CMsgConVarValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgConVarValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CMsgReplicateConVars) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgReplicateConVars) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Convars) > 0 {
		for _, msg := range m.Convars {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgUseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgUseItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemId))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.TargetSteamId))
	if len(m.Gift_PotentialTargets) > 0 {
		for _, num := range m.Gift_PotentialTargets {
			dAtA[i] = 0x18
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(num))
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Duel_ClassLock))
	dAtA[i] = 0x29
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.InitiatorSteamId))
	return i, nil
}

func (m *CMsgReplayUploadedToYouTube) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgReplayUploadedToYouTube) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.YoutubeUrl)))
	i += copy(dAtA[i:], m.YoutubeUrl)
	dAtA[i] = 0x12
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.YoutubeAccountName)))
	i += copy(dAtA[i:], m.YoutubeAccountName)
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SessionId))
	return i, nil
}

func (m *CMsgConsumableExhausted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgConsumableExhausted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemDefId))
	return i, nil
}

func (m *CMsgItemAcknowledged__DEPRECATED) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgItemAcknowledged__DEPRECATED) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Inventory))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.DefIndex))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Quality))
	dAtA[i] = 0x28
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Rarity))
	dAtA[i] = 0x30
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Origin))
	dAtA[i] = 0x38
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemId))
	return i, nil
}

func (m *CMsgSetItemPositions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSetItemPositions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ItemPositions) > 0 {
		for _, msg := range m.ItemPositions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgSetItemPositions_ItemPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSetItemPositions_ItemPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.LegacyItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Position))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemId))
	return i, nil
}

func (m *CMsgGCReportAbuse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCReportAbuse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.TargetSteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AbuseType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ContentType))
	dAtA[i] = 0x22
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Description)))
	i += copy(dAtA[i:], m.Description)
	dAtA[i] = 0x28
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Gid))
	dAtA[i] = 0x35
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.TargetGameServerIp))
	dAtA[i] = 0x38
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.TargetGameServerPort))
	return i, nil
}

func (m *CMsgGCReportAbuseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCReportAbuseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.TargetSteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Result))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ErrorMessage)))
	i += copy(dAtA[i:], m.ErrorMessage)
	return i, nil
}

func (m *CMsgGCNameItemNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCNameItemNotification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.PlayerSteamid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemDefIndex))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ItemNameCustom)))
	i += copy(dAtA[i:], m.ItemNameCustom)
	return i, nil
}

func (m *CMsgGCClientDisplayNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCClientDisplayNotification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.NotificationTitleLocalizationKey)))
	i += copy(dAtA[i:], m.NotificationTitleLocalizationKey)
	dAtA[i] = 0x12
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.NotificationBodyLocalizationKey)))
	i += copy(dAtA[i:], m.NotificationBodyLocalizationKey)
	if len(m.BodySubstringKeys) > 0 {
		for _, s := range m.BodySubstringKeys {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BodySubstringValues) > 0 {
		for _, s := range m.BodySubstringValues {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CMsgGCShowItemsPickedUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCShowItemsPickedUp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.PlayerSteamid))
	return i, nil
}

func (m *CMsgGCIncrementKillCountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCIncrementKillCountResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.KillerAccountId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.NumKills))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemDef))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.LevelType))
	return i, nil
}

func (m *CSOEconItemDropRateBonus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconItemDropRateBonus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.ExpirationDate))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.Bonus))))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.BonusCount))
	dAtA[i] = 0x28
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemId))
	dAtA[i] = 0x30
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.DefIndex))
	return i, nil
}

func (m *CSOEconItemLeagueViewPass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconItemLeagueViewPass) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.LeagueId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Admin))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Itemindex))
	return i, nil
}

func (m *CSOEconItemEventTicket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconItemEventTicket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.EventId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemId))
	return i, nil
}

func (m *CMsgGCItemPreviewItemBoughtNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCItemPreviewItemBoughtNotification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemDefIndex))
	return i, nil
}

func (m *CMsgGCStorePurchaseCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCStorePurchaseCancel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.TxnId))
	return i, nil
}

func (m *CMsgGCStorePurchaseCancelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCStorePurchaseCancelResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Result))
	return i, nil
}

func (m *CMsgGCStorePurchaseFinalize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCStorePurchaseFinalize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.TxnId))
	return i, nil
}

func (m *CMsgGCStorePurchaseFinalizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCStorePurchaseFinalizeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Result))
	if len(m.ItemIds) > 0 {
		for _, num := range m.ItemIds {
			dAtA[i] = 0x10
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CMsgGCBannedWordListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCBannedWordListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.BanListGroupId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.WordId))
	return i, nil
}

func (m *CMsgGCRequestAnnouncements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCRequestAnnouncements) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CMsgGCRequestAnnouncementsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCRequestAnnouncementsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.AnnouncementTitle)))
	i += copy(dAtA[i:], m.AnnouncementTitle)
	dAtA[i] = 0x12
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Announcement)))
	i += copy(dAtA[i:], m.Announcement)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.NextmatchTitle)))
	i += copy(dAtA[i:], m.NextmatchTitle)
	dAtA[i] = 0x22
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Nextmatch)))
	i += copy(dAtA[i:], m.Nextmatch)
	return i, nil
}

func (m *CMsgGCBannedWord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCBannedWord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.WordId))
	if m.WordType != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(*m.WordType))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.Word)))
	i += copy(dAtA[i:], m.Word)
	return i, nil
}

func (m *CMsgGCBannedWordListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCBannedWordListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.BanListGroupId))
	if len(m.WordList) > 0 {
		for _, msg := range m.WordList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCToGCBannedWordListBroadcast) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCBannedWordListBroadcast) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Broadcast != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.Broadcast.Size()))
		n3, err := m.Broadcast.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *CMsgGCToGCBannedWordListUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCBannedWordListUpdated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.GroupId))
	return i, nil
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ItemDefinition))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ClassId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SlotId))
	return i, nil
}

func (m *CMsgGCToGCDirtySDOCache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCDirtySDOCache) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SdoType))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.KeyUint64))
	return i, nil
}

func (m *CMsgGCToGCDirtyMultipleSDOCache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCDirtyMultipleSDOCache) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SdoType))
	if len(m.KeyUint64) > 0 {
		for _, num := range m.KeyUint64 {
			dAtA[i] = 0x10
			i++
			i = encodeVarintBaseGcmessages(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CMsgGCCollectItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCCollectItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.CollectionItemId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.SubjectItemId))
	return i, nil
}

func (m *CMsgSDONoMemcached) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSDONoMemcached) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CMsgGCToGCUpdateSQLKeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCUpdateSQLKeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.KeyName)))
	i += copy(dAtA[i:], m.KeyName)
	return i, nil
}

func (m *CMsgGCToGCIsTrustedServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCIsTrustedServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.SteamId))
	return i, nil
}

func (m *CMsgGCToGCIsTrustedServerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCIsTrustedServerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.IsTrusted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCToGCBroadcastConsoleCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCBroadcastConsoleCommand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ConCommand)))
	i += copy(dAtA[i:], m.ConCommand)
	return i, nil
}

func (m *CMsgGCServerVersionUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCServerVersionUpdated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ServerVersion))
	return i, nil
}

func (m *CMsgGCClientVersionUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCClientVersionUpdated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ClientVersion))
	return i, nil
}

func (m *CMsgGCToGCWebAPIAccountChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCWebAPIAccountChanged) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CMsgGCToGCRequestPassportItemGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCToGCRequestPassportItemGrant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.SteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.LeagueId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.RewardFlag))
	return i, nil
}

func (m *CMsgGameServerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGameServerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.ServerPublicIpAddr))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(m.ServerPrivateIpAddr))
	dAtA[i] = 0x18
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ServerPort))
	dAtA[i] = 0x20
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ServerTvPort))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(len(m.ServerKey)))
	i += copy(dAtA[i:], m.ServerKey)
	dAtA[i] = 0x30
	i++
	if m.ServerHibernation {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.ServerType != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBaseGcmessages(dAtA, i, uint64(*m.ServerType))
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ServerRegion))
	dAtA[i] = 0x4d
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.ServerLoadavg))))
	dAtA[i] = 0x55
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.ServerTvBroadcastTime))))
	dAtA[i] = 0x5d
	i++
	i = encodeFixed32BaseGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.ServerGameTime))))
	dAtA[i] = 0x61
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.ServerRelayConnectedSteamId))
	dAtA[i] = 0x68
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.RelaySlotsMax))
	dAtA[i] = 0x70
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.RelaysConnected))
	dAtA[i] = 0x78
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.RelayClientsConnected))
	dAtA[i] = 0x81
	i++
	dAtA[i] = 0x1
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.RelayedGameServerSteamId))
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintBaseGcmessages(dAtA, i, uint64(m.ParentRelayCount))
	dAtA[i] = 0x91
	i++
	dAtA[i] = 0x1
	i++
	i = encodeFixed64BaseGcmessages(dAtA, i, uint64(m.TvSecretCode))
	return i, nil
}

func encodeFixed64BaseGcmessages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32BaseGcmessages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintBaseGcmessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CGCStorePurchaseInit_LineItem) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ItemDefId))
	n += 1 + sovBaseGcmessages(uint64(m.Quantity))
	n += 1 + sovBaseGcmessages(uint64(m.CostInLocalCurrency))
	n += 1 + sovBaseGcmessages(uint64(m.PurchaseType))
	return n
}

func (m *CMsgGCStorePurchaseInit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Country)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	n += 1 + sovBaseGcmessages(uint64(m.Language))
	n += 1 + sovBaseGcmessages(uint64(m.Currency))
	if len(m.LineItems) > 0 {
		for _, e := range m.LineItems {
			l = e.Size()
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCStorePurchaseInitResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.Result))
	n += 1 + sovBaseGcmessages(uint64(m.TxnId))
	return n
}

func (m *CSOPartyInvite) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.GroupId))
	n += 9
	l = len(m.SenderName)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CSOLobbyInvite) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.GroupId))
	n += 9
	l = len(m.SenderName)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgSystemBroadcast) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgInviteToParty) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovBaseGcmessages(uint64(m.ClientVersion))
	n += 1 + sovBaseGcmessages(uint64(m.TeamInvite))
	return n
}

func (m *CMsgInvitationCreated) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.GroupId))
	n += 9
	return n
}

func (m *CMsgPartyInviteResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.PartyId))
	n += 2
	n += 1 + sovBaseGcmessages(uint64(m.ClientVersion))
	n += 1 + sovBaseGcmessages(uint64(m.TeamInvite))
	return n
}

func (m *CMsgKickFromParty) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgLeaveParty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CMsgServerAvailable) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CMsgLANServerAvailable) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CSOEconGameAccountClient) Size() (n int) {
	var l int
	_ = l
	if m.AdditionalBackpackSlots != nil {
		n += 1 + sovBaseGcmessages(uint64(*m.AdditionalBackpackSlots))
	}
	n += 5
	n += 1 + sovBaseGcmessages(uint64(m.BonusXpUsedflags))
	n += 1 + sovBaseGcmessages(uint64(m.ElevatedState))
	n += 1 + sovBaseGcmessages(uint64(m.ElevatedTimestamp))
	return n
}

func (m *CSOItemCriteriaCondition) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.Op))
	l = len(m.Field)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	n += 2
	n += 5
	l = len(m.StringValue)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CSOItemCriteria) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ItemLevel))
	n += 1 + sovBaseGcmessages(uint64(m.ItemQuality))
	n += 2
	n += 2
	n += 1 + sovBaseGcmessages(uint64(m.InitialInventory))
	n += 1 + sovBaseGcmessages(uint64(m.InitialQuantity))
	n += 2
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	n += 1 + sovBaseGcmessages(uint64(m.ItemRarity))
	n += 2
	n += 2
	return n
}

func (m *CSOItemRecipe) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.DefIndex))
	l = len(m.Name)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.NA)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DescInputs)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DescOutputs)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DiA)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DiB)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DiC)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DoA)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DoB)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.DoC)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	n += 2
	n += 2
	n += 1 + sovBaseGcmessages(uint64(m.ClassUsageForOutput))
	n += 1 + sovBaseGcmessages(uint64(m.SlotUsageForOutput))
	n += 2 + sovBaseGcmessages(uint64(m.SetForOutput))
	if len(m.InputItemsCriteria) > 0 {
		for _, e := range m.InputItemsCriteria {
			l = e.Size()
			n += 2 + l + sovBaseGcmessages(uint64(l))
		}
	}
	if len(m.OutputItemsCriteria) > 0 {
		for _, e := range m.OutputItemsCriteria {
			l = e.Size()
			n += 2 + l + sovBaseGcmessages(uint64(l))
		}
	}
	if len(m.InputItemDupeCounts) > 0 {
		for _, e := range m.InputItemDupeCounts {
			n += 2 + sovBaseGcmessages(uint64(e))
		}
	}
	return n
}

func (m *CMsgDevNewItemRequest) Size() (n int) {
	var l int
	_ = l
	n += 9
	if m.Criteria != nil {
		l = m.Criteria.Size()
		n += 1 + l + sovBaseGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgIncrementKillCountAttribute) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 1 + sovBaseGcmessages(uint64(m.ItemId))
	n += 1 + sovBaseGcmessages(uint64(m.EventType))
	n += 1 + sovBaseGcmessages(uint64(m.Amount))
	return n
}

func (m *CMsgApplySticker) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.StickerItemId))
	n += 1 + sovBaseGcmessages(uint64(m.ItemItemId))
	n += 1 + sovBaseGcmessages(uint64(m.StickerSlot))
	n += 1 + sovBaseGcmessages(uint64(m.BaseitemDefidx))
	n += 5
	return n
}

func (m *CMsgApplyStatTrakSwap) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ToolItemId))
	n += 1 + sovBaseGcmessages(uint64(m.Item_1ItemId))
	n += 1 + sovBaseGcmessages(uint64(m.Item_2ItemId))
	return n
}

func (m *CMsgApplyStrangePart) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.StrangePartItemId))
	n += 1 + sovBaseGcmessages(uint64(m.ItemItemId))
	return n
}

func (m *CMsgApplyPennantUpgrade) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.UpgradeItemId))
	n += 1 + sovBaseGcmessages(uint64(m.PennantItemId))
	return n
}

func (m *CMsgApplyEggEssence) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.EssenceItemId))
	n += 1 + sovBaseGcmessages(uint64(m.EggItemId))
	return n
}

func (m *CSOEconItemAttribute) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.DefIndex))
	n += 1 + sovBaseGcmessages(uint64(m.Value))
	if m.ValueBytes != nil {
		l = len(m.ValueBytes)
		n += 1 + l + sovBaseGcmessages(uint64(l))
	}
	return n
}

func (m *CSOEconItemEquipped) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.NewClass))
	n += 1 + sovBaseGcmessages(uint64(m.NewSlot))
	return n
}

func (m *CSOEconItem) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.Id))
	n += 1 + sovBaseGcmessages(uint64(m.AccountId))
	n += 1 + sovBaseGcmessages(uint64(m.Inventory))
	n += 1 + sovBaseGcmessages(uint64(m.DefIndex))
	n += 1 + sovBaseGcmessages(uint64(m.Quantity))
	n += 1 + sovBaseGcmessages(uint64(m.Level))
	n += 1 + sovBaseGcmessages(uint64(m.Quality))
	if m.Flags != nil {
		n += 1 + sovBaseGcmessages(uint64(*m.Flags))
	}
	n += 1 + sovBaseGcmessages(uint64(m.Origin))
	l = len(m.CustomName)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.CustomDesc)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	if len(m.Attribute) > 0 {
		for _, e := range m.Attribute {
			l = e.Size()
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	if m.InteriorItem != nil {
		l = m.InteriorItem.Size()
		n += 1 + l + sovBaseGcmessages(uint64(l))
	}
	if m.InUse != nil {
		n += 2
	}
	if m.Style != nil {
		n += 1 + sovBaseGcmessages(uint64(*m.Style))
	}
	if m.OriginalId != nil {
		n += 2 + sovBaseGcmessages(uint64(*m.OriginalId))
	}
	if len(m.EquippedState) > 0 {
		for _, e := range m.EquippedState {
			l = e.Size()
			n += 2 + l + sovBaseGcmessages(uint64(l))
		}
	}
	n += 2 + sovBaseGcmessages(uint64(m.Rarity))
	return n
}

func (m *CMsgAdjustItemEquippedState) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ItemId))
	n += 1 + sovBaseGcmessages(uint64(m.NewClass))
	n += 1 + sovBaseGcmessages(uint64(m.NewSlot))
	n += 2
	return n
}

func (m *CMsgSortItems) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.SortType))
	return n
}

func (m *CSOEconClaimCode) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.AccountId))
	n += 1 + sovBaseGcmessages(uint64(m.CodeType))
	n += 1 + sovBaseGcmessages(uint64(m.TimeAcquired))
	l = len(m.Code)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgStoreGetUserData) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 1 + sovBaseGcmessages(uint64(m.Currency))
	return n
}

func (m *CMsgStoreGetUserDataResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.Result))
	n += 1 + sovBaseGcmessages(uint64(m.CurrencyDeprecated))
	l = len(m.CountryDeprecated)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	n += 5
	if m.PriceSheet != nil {
		l = len(m.PriceSheet)
		n += 1 + l + sovBaseGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgUpdateItemSchema) Size() (n int) {
	var l int
	_ = l
	if m.ItemsGame != nil {
		l = len(m.ItemsGame)
		n += 1 + l + sovBaseGcmessages(uint64(l))
	}
	n += 5
	l = len(m.ItemsGameUrl_DEPRECATED2013)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.ItemsGameUrl)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgGCError) Size() (n int) {
	var l int
	_ = l
	l = len(m.ErrorText)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgRequestInventoryRefresh) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CMsgConVarValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgReplicateConVars) Size() (n int) {
	var l int
	_ = l
	if len(m.Convars) > 0 {
		for _, e := range m.Convars {
			l = e.Size()
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgUseItem) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ItemId))
	n += 9
	if len(m.Gift_PotentialTargets) > 0 {
		for _, e := range m.Gift_PotentialTargets {
			n += 1 + sovBaseGcmessages(uint64(e))
		}
	}
	n += 1 + sovBaseGcmessages(uint64(m.Duel_ClassLock))
	n += 9
	return n
}

func (m *CMsgReplayUploadedToYouTube) Size() (n int) {
	var l int
	_ = l
	l = len(m.YoutubeUrl)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.YoutubeAccountName)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	n += 1 + sovBaseGcmessages(uint64(m.SessionId))
	return n
}

func (m *CMsgConsumableExhausted) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ItemDefId))
	return n
}

func (m *CMsgItemAcknowledged__DEPRECATED) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.AccountId))
	n += 1 + sovBaseGcmessages(uint64(m.Inventory))
	n += 1 + sovBaseGcmessages(uint64(m.DefIndex))
	n += 1 + sovBaseGcmessages(uint64(m.Quality))
	n += 1 + sovBaseGcmessages(uint64(m.Rarity))
	n += 1 + sovBaseGcmessages(uint64(m.Origin))
	n += 1 + sovBaseGcmessages(uint64(m.ItemId))
	return n
}

func (m *CMsgSetItemPositions) Size() (n int) {
	var l int
	_ = l
	if len(m.ItemPositions) > 0 {
		for _, e := range m.ItemPositions {
			l = e.Size()
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgSetItemPositions_ItemPosition) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.LegacyItemId))
	n += 1 + sovBaseGcmessages(uint64(m.Position))
	n += 1 + sovBaseGcmessages(uint64(m.ItemId))
	return n
}

func (m *CMsgGCReportAbuse) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovBaseGcmessages(uint64(m.AbuseType))
	n += 1 + sovBaseGcmessages(uint64(m.ContentType))
	l = len(m.Description)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	n += 1 + sovBaseGcmessages(uint64(m.Gid))
	n += 5
	n += 1 + sovBaseGcmessages(uint64(m.TargetGameServerPort))
	return n
}

func (m *CMsgGCReportAbuseResponse) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovBaseGcmessages(uint64(m.Result))
	l = len(m.ErrorMessage)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgGCNameItemNotification) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovBaseGcmessages(uint64(m.ItemDefIndex))
	l = len(m.ItemNameCustom)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgGCClientDisplayNotification) Size() (n int) {
	var l int
	_ = l
	l = len(m.NotificationTitleLocalizationKey)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.NotificationBodyLocalizationKey)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	if len(m.BodySubstringKeys) > 0 {
		for _, s := range m.BodySubstringKeys {
			l = len(s)
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	if len(m.BodySubstringValues) > 0 {
		for _, s := range m.BodySubstringValues {
			l = len(s)
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCShowItemsPickedUp) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgGCIncrementKillCountResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.KillerAccountId))
	n += 1 + sovBaseGcmessages(uint64(m.NumKills))
	n += 1 + sovBaseGcmessages(uint64(m.ItemDef))
	n += 1 + sovBaseGcmessages(uint64(m.LevelType))
	return n
}

func (m *CSOEconItemDropRateBonus) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.AccountId))
	n += 5
	n += 5
	n += 1 + sovBaseGcmessages(uint64(m.BonusCount))
	n += 1 + sovBaseGcmessages(uint64(m.ItemId))
	n += 1 + sovBaseGcmessages(uint64(m.DefIndex))
	return n
}

func (m *CSOEconItemLeagueViewPass) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.AccountId))
	n += 1 + sovBaseGcmessages(uint64(m.LeagueId))
	n += 1 + sovBaseGcmessages(uint64(m.Admin))
	n += 1 + sovBaseGcmessages(uint64(m.Itemindex))
	return n
}

func (m *CSOEconItemEventTicket) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.AccountId))
	n += 1 + sovBaseGcmessages(uint64(m.EventId))
	n += 1 + sovBaseGcmessages(uint64(m.ItemId))
	return n
}

func (m *CMsgGCItemPreviewItemBoughtNotification) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ItemDefIndex))
	return n
}

func (m *CMsgGCStorePurchaseCancel) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.TxnId))
	return n
}

func (m *CMsgGCStorePurchaseCancelResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.Result))
	return n
}

func (m *CMsgGCStorePurchaseFinalize) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.TxnId))
	return n
}

func (m *CMsgGCStorePurchaseFinalizeResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.Result))
	if len(m.ItemIds) > 0 {
		for _, e := range m.ItemIds {
			n += 1 + sovBaseGcmessages(uint64(e))
		}
	}
	return n
}

func (m *CMsgGCBannedWordListRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.BanListGroupId))
	n += 1 + sovBaseGcmessages(uint64(m.WordId))
	return n
}

func (m *CMsgGCRequestAnnouncements) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CMsgGCRequestAnnouncementsResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.AnnouncementTitle)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.Announcement)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.NextmatchTitle)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	l = len(m.Nextmatch)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgGCBannedWord) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.WordId))
	if m.WordType != nil {
		n += 1 + sovBaseGcmessages(uint64(*m.WordType))
	}
	l = len(m.Word)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgGCBannedWordListResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.BanListGroupId))
	if len(m.WordList) > 0 {
		for _, e := range m.WordList {
			l = e.Size()
			n += 1 + l + sovBaseGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCToGCBannedWordListBroadcast) Size() (n int) {
	var l int
	_ = l
	if m.Broadcast != nil {
		l = m.Broadcast.Size()
		n += 1 + l + sovBaseGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgGCToGCBannedWordListUpdated) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.GroupId))
	return n
}

func (m *CSOEconDefaultEquippedDefinitionInstanceClient) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.AccountId))
	n += 1 + sovBaseGcmessages(uint64(m.ItemDefinition))
	n += 1 + sovBaseGcmessages(uint64(m.ClassId))
	n += 1 + sovBaseGcmessages(uint64(m.SlotId))
	return n
}

func (m *CMsgGCToGCDirtySDOCache) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.SdoType))
	n += 1 + sovBaseGcmessages(uint64(m.KeyUint64))
	return n
}

func (m *CMsgGCToGCDirtyMultipleSDOCache) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.SdoType))
	if len(m.KeyUint64) > 0 {
		for _, e := range m.KeyUint64 {
			n += 1 + sovBaseGcmessages(uint64(e))
		}
	}
	return n
}

func (m *CMsgGCCollectItem) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.CollectionItemId))
	n += 1 + sovBaseGcmessages(uint64(m.SubjectItemId))
	return n
}

func (m *CMsgSDONoMemcached) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CMsgGCToGCUpdateSQLKeyValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.KeyName)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgGCToGCIsTrustedServer) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgGCToGCIsTrustedServerResponse) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}

func (m *CMsgGCToGCBroadcastConsoleCommand) Size() (n int) {
	var l int
	_ = l
	l = len(m.ConCommand)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	return n
}

func (m *CMsgGCServerVersionUpdated) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ServerVersion))
	return n
}

func (m *CMsgGCClientVersionUpdated) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovBaseGcmessages(uint64(m.ClientVersion))
	return n
}

func (m *CMsgGCToGCWebAPIAccountChanged) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CMsgGCToGCRequestPassportItemGrant) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovBaseGcmessages(uint64(m.LeagueId))
	n += 1 + sovBaseGcmessages(uint64(m.RewardFlag))
	return n
}

func (m *CMsgGameServerInfo) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	n += 1 + sovBaseGcmessages(uint64(m.ServerPort))
	n += 1 + sovBaseGcmessages(uint64(m.ServerTvPort))
	l = len(m.ServerKey)
	n += 1 + l + sovBaseGcmessages(uint64(l))
	n += 2
	if m.ServerType != nil {
		n += 1 + sovBaseGcmessages(uint64(*m.ServerType))
	}
	n += 1 + sovBaseGcmessages(uint64(m.ServerRegion))
	n += 5
	n += 5
	n += 5
	n += 9
	n += 1 + sovBaseGcmessages(uint64(m.RelaySlotsMax))
	n += 1 + sovBaseGcmessages(uint64(m.RelaysConnected))
	n += 1 + sovBaseGcmessages(uint64(m.RelayClientsConnected))
	n += 10
	n += 2 + sovBaseGcmessages(uint64(m.ParentRelayCount))
	n += 10
	return n
}

func sovBaseGcmessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBaseGcmessages(x uint64) (n int) {
	return sovBaseGcmessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CGCStorePurchaseInit_LineItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCStorePurchaseInit_LineItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCStorePurchaseInit_LineItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemDefId", wireType)
			}
			m.ItemDefId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemDefId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostInLocalCurrency", wireType)
			}
			m.CostInLocalCurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostInLocalCurrency |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseType", wireType)
			}
			m.PurchaseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurchaseType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCStorePurchaseInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			m.Language = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Language |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			m.Currency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currency |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LineItems = append(m.LineItems, &CGCStorePurchaseInit_LineItem{})
			if err := m.LineItems[len(m.LineItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCStorePurchaseInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			m.TxnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOPartyInvite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOPartyInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOPartyInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			m.SenderId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SenderId = uint64(dAtA[iNdEx-8])
			m.SenderId |= uint64(dAtA[iNdEx-7]) << 8
			m.SenderId |= uint64(dAtA[iNdEx-6]) << 16
			m.SenderId |= uint64(dAtA[iNdEx-5]) << 24
			m.SenderId |= uint64(dAtA[iNdEx-4]) << 32
			m.SenderId |= uint64(dAtA[iNdEx-3]) << 40
			m.SenderId |= uint64(dAtA[iNdEx-2]) << 48
			m.SenderId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOLobbyInvite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOLobbyInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOLobbyInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			m.SenderId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SenderId = uint64(dAtA[iNdEx-8])
			m.SenderId |= uint64(dAtA[iNdEx-7]) << 8
			m.SenderId |= uint64(dAtA[iNdEx-6]) << 16
			m.SenderId |= uint64(dAtA[iNdEx-5]) << 24
			m.SenderId |= uint64(dAtA[iNdEx-4]) << 32
			m.SenderId |= uint64(dAtA[iNdEx-3]) << 40
			m.SenderId |= uint64(dAtA[iNdEx-2]) << 48
			m.SenderId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSystemBroadcast) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSystemBroadcast: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSystemBroadcast: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgInviteToParty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgInviteToParty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgInviteToParty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			m.ClientVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamInvite", wireType)
			}
			m.TeamInvite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamInvite |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgInvitationCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgInvitationCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgInvitationCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgPartyInviteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgPartyInviteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgPartyInviteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartyId", wireType)
			}
			m.PartyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accept", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Accept = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			m.ClientVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamInvite", wireType)
			}
			m.TeamInvite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamInvite |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgKickFromParty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgKickFromParty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgKickFromParty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgLeaveParty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgLeaveParty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgLeaveParty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgServerAvailable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgServerAvailable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgServerAvailable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgLANServerAvailable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgLANServerAvailable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgLANServerAvailable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LobbyId", wireType)
			}
			m.LobbyId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.LobbyId = uint64(dAtA[iNdEx-8])
			m.LobbyId |= uint64(dAtA[iNdEx-7]) << 8
			m.LobbyId |= uint64(dAtA[iNdEx-6]) << 16
			m.LobbyId |= uint64(dAtA[iNdEx-5]) << 24
			m.LobbyId |= uint64(dAtA[iNdEx-4]) << 32
			m.LobbyId |= uint64(dAtA[iNdEx-3]) << 40
			m.LobbyId |= uint64(dAtA[iNdEx-2]) << 48
			m.LobbyId |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconGameAccountClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconGameAccountClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconGameAccountClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalBackpackSlots", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdditionalBackpackSlots = &v
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusXpTimestampRefresh", wireType)
			}
			m.BonusXpTimestampRefresh = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.BonusXpTimestampRefresh = uint32(dAtA[iNdEx-4])
			m.BonusXpTimestampRefresh |= uint32(dAtA[iNdEx-3]) << 8
			m.BonusXpTimestampRefresh |= uint32(dAtA[iNdEx-2]) << 16
			m.BonusXpTimestampRefresh |= uint32(dAtA[iNdEx-1]) << 24
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusXpUsedflags", wireType)
			}
			m.BonusXpUsedflags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusXpUsedflags |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElevatedState", wireType)
			}
			m.ElevatedState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElevatedState |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElevatedTimestamp", wireType)
			}
			m.ElevatedTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElevatedTimestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOItemCriteriaCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOItemCriteriaCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOItemCriteriaCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.FloatValue = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOItemCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOItemCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOItemCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemLevel", wireType)
			}
			m.ItemLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemLevel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemQuality", wireType)
			}
			m.ItemQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemQuality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemLevelSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ItemLevelSet = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemQualitySet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ItemQualitySet = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialInventory", wireType)
			}
			m.InitialInventory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialInventory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialQuantity", wireType)
			}
			m.InitialQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialQuantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEnabledFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreEnabledFlag = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &CSOItemCriteriaCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemRarity", wireType)
			}
			m.ItemRarity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemRarity |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemRaritySet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ItemRaritySet = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecentOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOItemRecipe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOItemRecipe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOItemRecipe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefIndex", wireType)
			}
			m.DefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescInputs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescInputs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescOutputs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DescOutputs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DoC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiresAllSameClass", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequiresAllSameClass = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiresAllSameSlot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequiresAllSameSlot = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassUsageForOutput", wireType)
			}
			m.ClassUsageForOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassUsageForOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotUsageForOutput", wireType)
			}
			m.SlotUsageForOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotUsageForOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetForOutput", wireType)
			}
			m.SetForOutput = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetForOutput |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputItemsCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputItemsCriteria = append(m.InputItemsCriteria, &CSOItemCriteria{})
			if err := m.InputItemsCriteria[len(m.InputItemsCriteria)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputItemsCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputItemsCriteria = append(m.OutputItemsCriteria, &CSOItemCriteria{})
			if err := m.OutputItemsCriteria[len(m.OutputItemsCriteria)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InputItemDupeCounts = append(m.InputItemDupeCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBaseGcmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBaseGcmessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InputItemDupeCounts = append(m.InputItemDupeCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InputItemDupeCounts", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgDevNewItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgDevNewItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgDevNewItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			m.Receiver = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Receiver = uint64(dAtA[iNdEx-8])
			m.Receiver |= uint64(dAtA[iNdEx-7]) << 8
			m.Receiver |= uint64(dAtA[iNdEx-6]) << 16
			m.Receiver |= uint64(dAtA[iNdEx-5]) << 24
			m.Receiver |= uint64(dAtA[iNdEx-4]) << 32
			m.Receiver |= uint64(dAtA[iNdEx-3]) << 40
			m.Receiver |= uint64(dAtA[iNdEx-2]) << 48
			m.Receiver |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Criteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Criteria == nil {
				m.Criteria = &CSOItemCriteria{}
			}
			if err := m.Criteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgIncrementKillCountAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgIncrementKillCountAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgIncrementKillCountAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillerAccountId", wireType)
			}
			m.KillerAccountId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.KillerAccountId = uint32(dAtA[iNdEx-4])
			m.KillerAccountId |= uint32(dAtA[iNdEx-3]) << 8
			m.KillerAccountId |= uint32(dAtA[iNdEx-2]) << 16
			m.KillerAccountId |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field VictimAccountId", wireType)
			}
			m.VictimAccountId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.VictimAccountId = uint32(dAtA[iNdEx-4])
			m.VictimAccountId |= uint32(dAtA[iNdEx-3]) << 8
			m.VictimAccountId |= uint32(dAtA[iNdEx-2]) << 16
			m.VictimAccountId |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgApplySticker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgApplySticker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgApplySticker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerItemId", wireType)
			}
			m.StickerItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickerItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemItemId", wireType)
			}
			m.ItemItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSlot", wireType)
			}
			m.StickerSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickerSlot |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseitemDefidx", wireType)
			}
			m.BaseitemDefidx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseitemDefidx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerWear", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.StickerWear = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgApplyStatTrakSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgApplyStatTrakSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgApplyStatTrakSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToolItemId", wireType)
			}
			m.ToolItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToolItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item_1ItemId", wireType)
			}
			m.Item_1ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Item_1ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item_2ItemId", wireType)
			}
			m.Item_2ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Item_2ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgApplyStrangePart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgApplyStrangePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgApplyStrangePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrangePartItemId", wireType)
			}
			m.StrangePartItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StrangePartItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemItemId", wireType)
			}
			m.ItemItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgApplyPennantUpgrade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgApplyPennantUpgrade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgApplyPennantUpgrade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeItemId", wireType)
			}
			m.UpgradeItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradeItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PennantItemId", wireType)
			}
			m.PennantItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PennantItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgApplyEggEssence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgApplyEggEssence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgApplyEggEssence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EssenceItemId", wireType)
			}
			m.EssenceItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EssenceItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EggItemId", wireType)
			}
			m.EggItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EggItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconItemAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconItemAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconItemAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefIndex", wireType)
			}
			m.DefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBytes = append(m.ValueBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBytes == nil {
				m.ValueBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconItemEquipped) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconItemEquipped: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconItemEquipped: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewClass", wireType)
			}
			m.NewClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewClass |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSlot", wireType)
			}
			m.NewSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSlot |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			m.Inventory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inventory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefIndex", wireType)
			}
			m.DefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flags = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			m.Origin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Origin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attribute = append(m.Attribute, &CSOEconItemAttribute{})
			if err := m.Attribute[len(m.Attribute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InteriorItem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InteriorItem == nil {
				m.InteriorItem = &CSOEconItem{}
			}
			if err := m.InteriorItem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.InUse = &b
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Style = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OriginalId = &v
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquippedState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquippedState = append(m.EquippedState, &CSOEconItemEquipped{})
			if err := m.EquippedState[len(m.EquippedState)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rarity", wireType)
			}
			m.Rarity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rarity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAdjustItemEquippedState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAdjustItemEquippedState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAdjustItemEquippedState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewClass", wireType)
			}
			m.NewClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewClass |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSlot", wireType)
			}
			m.NewSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSlot |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Swap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSortItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSortItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSortItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortType", wireType)
			}
			m.SortType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconClaimCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconClaimCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconClaimCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeType", wireType)
			}
			m.CodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeAcquired", wireType)
			}
			m.TimeAcquired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeAcquired |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgStoreGetUserData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgStoreGetUserData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgStoreGetUserData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceSheetVersion", wireType)
			}
			m.PriceSheetVersion = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.PriceSheetVersion = uint32(dAtA[iNdEx-4])
			m.PriceSheetVersion |= uint32(dAtA[iNdEx-3]) << 8
			m.PriceSheetVersion |= uint32(dAtA[iNdEx-2]) << 16
			m.PriceSheetVersion |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			m.Currency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currency |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgStoreGetUserDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgStoreGetUserDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgStoreGetUserDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyDeprecated", wireType)
			}
			m.CurrencyDeprecated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyDeprecated |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryDeprecated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryDeprecated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceSheetVersion", wireType)
			}
			m.PriceSheetVersion = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.PriceSheetVersion = uint32(dAtA[iNdEx-4])
			m.PriceSheetVersion |= uint32(dAtA[iNdEx-3]) << 8
			m.PriceSheetVersion |= uint32(dAtA[iNdEx-2]) << 16
			m.PriceSheetVersion |= uint32(dAtA[iNdEx-1]) << 24
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceSheet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceSheet = append(m.PriceSheet[:0], dAtA[iNdEx:postIndex]...)
			if m.PriceSheet == nil {
				m.PriceSheet = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgUpdateItemSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgUpdateItemSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgUpdateItemSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemsGame", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemsGame = append(m.ItemsGame[:0], dAtA[iNdEx:postIndex]...)
			if m.ItemsGame == nil {
				m.ItemsGame = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemSchemaVersion", wireType)
			}
			m.ItemSchemaVersion = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ItemSchemaVersion = uint32(dAtA[iNdEx-4])
			m.ItemSchemaVersion |= uint32(dAtA[iNdEx-3]) << 8
			m.ItemSchemaVersion |= uint32(dAtA[iNdEx-2]) << 16
			m.ItemSchemaVersion |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemsGameUrl_DEPRECATED2013", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemsGameUrl_DEPRECATED2013 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemsGameUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemsGameUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgRequestInventoryRefresh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgRequestInventoryRefresh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgRequestInventoryRefresh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgConVarValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgConVarValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgConVarValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgReplicateConVars) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgReplicateConVars: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgReplicateConVars: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Convars", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Convars = append(m.Convars, &CMsgConVarValue{})
			if err := m.Convars[len(m.Convars)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgUseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgUseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgUseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSteamId", wireType)
			}
			m.TargetSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.TargetSteamId = uint64(dAtA[iNdEx-8])
			m.TargetSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.TargetSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.TargetSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.TargetSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.TargetSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.TargetSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.TargetSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Gift_PotentialTargets = append(m.Gift_PotentialTargets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBaseGcmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBaseGcmessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Gift_PotentialTargets = append(m.Gift_PotentialTargets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Gift_PotentialTargets", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duel_ClassLock", wireType)
			}
			m.Duel_ClassLock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duel_ClassLock |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorSteamId", wireType)
			}
			m.InitiatorSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.InitiatorSteamId = uint64(dAtA[iNdEx-8])
			m.InitiatorSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.InitiatorSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.InitiatorSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.InitiatorSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.InitiatorSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.InitiatorSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.InitiatorSteamId |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgReplayUploadedToYouTube) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgReplayUploadedToYouTube: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgReplayUploadedToYouTube: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YoutubeUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YoutubeUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YoutubeAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YoutubeAccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgConsumableExhausted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgConsumableExhausted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgConsumableExhausted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemDefId", wireType)
			}
			m.ItemDefId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemDefId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgItemAcknowledged__DEPRECATED) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgItemAcknowledged__DEPRECATED: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgItemAcknowledged__DEPRECATED: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			m.Inventory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inventory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefIndex", wireType)
			}
			m.DefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rarity", wireType)
			}
			m.Rarity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rarity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			m.Origin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Origin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSetItemPositions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSetItemPositions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSetItemPositions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemPositions = append(m.ItemPositions, &CMsgSetItemPositions_ItemPosition{})
			if err := m.ItemPositions[len(m.ItemPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSetItemPositions_ItemPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyItemId", wireType)
			}
			m.LegacyItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LegacyItemId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCReportAbuse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCReportAbuse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCReportAbuse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSteamId", wireType)
			}
			m.TargetSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.TargetSteamId = uint64(dAtA[iNdEx-8])
			m.TargetSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.TargetSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.TargetSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.TargetSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.TargetSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.TargetSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.TargetSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbuseType", wireType)
			}
			m.AbuseType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbuseType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetGameServerIp", wireType)
			}
			m.TargetGameServerIp = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.TargetGameServerIp = uint32(dAtA[iNdEx-4])
			m.TargetGameServerIp |= uint32(dAtA[iNdEx-3]) << 8
			m.TargetGameServerIp |= uint32(dAtA[iNdEx-2]) << 16
			m.TargetGameServerIp |= uint32(dAtA[iNdEx-1]) << 24
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetGameServerPort", wireType)
			}
			m.TargetGameServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetGameServerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCReportAbuseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCReportAbuseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCReportAbuseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSteamId", wireType)
			}
			m.TargetSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.TargetSteamId = uint64(dAtA[iNdEx-8])
			m.TargetSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.TargetSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.TargetSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.TargetSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.TargetSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.TargetSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.TargetSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCNameItemNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCNameItemNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCNameItemNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerSteamid", wireType)
			}
			m.PlayerSteamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.PlayerSteamid = uint64(dAtA[iNdEx-8])
			m.PlayerSteamid |= uint64(dAtA[iNdEx-7]) << 8
			m.PlayerSteamid |= uint64(dAtA[iNdEx-6]) << 16
			m.PlayerSteamid |= uint64(dAtA[iNdEx-5]) << 24
			m.PlayerSteamid |= uint64(dAtA[iNdEx-4]) << 32
			m.PlayerSteamid |= uint64(dAtA[iNdEx-3]) << 40
			m.PlayerSteamid |= uint64(dAtA[iNdEx-2]) << 48
			m.PlayerSteamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemDefIndex", wireType)
			}
			m.ItemDefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemDefIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNameCustom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemNameCustom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCClientDisplayNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCClientDisplayNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCClientDisplayNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationTitleLocalizationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotificationTitleLocalizationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationBodyLocalizationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotificationBodyLocalizationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySubstringKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodySubstringKeys = append(m.BodySubstringKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySubstringValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodySubstringValues = append(m.BodySubstringValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCShowItemsPickedUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCShowItemsPickedUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCShowItemsPickedUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerSteamid", wireType)
			}
			m.PlayerSteamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.PlayerSteamid = uint64(dAtA[iNdEx-8])
			m.PlayerSteamid |= uint64(dAtA[iNdEx-7]) << 8
			m.PlayerSteamid |= uint64(dAtA[iNdEx-6]) << 16
			m.PlayerSteamid |= uint64(dAtA[iNdEx-5]) << 24
			m.PlayerSteamid |= uint64(dAtA[iNdEx-4]) << 32
			m.PlayerSteamid |= uint64(dAtA[iNdEx-3]) << 40
			m.PlayerSteamid |= uint64(dAtA[iNdEx-2]) << 48
			m.PlayerSteamid |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCIncrementKillCountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCIncrementKillCountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCIncrementKillCountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillerAccountId", wireType)
			}
			m.KillerAccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillerAccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumKills", wireType)
			}
			m.NumKills = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumKills |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemDef", wireType)
			}
			m.ItemDef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemDef |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelType", wireType)
			}
			m.LevelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconItemDropRateBonus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconItemDropRateBonus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconItemDropRateBonus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDate", wireType)
			}
			m.ExpirationDate = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ExpirationDate = uint32(dAtA[iNdEx-4])
			m.ExpirationDate |= uint32(dAtA[iNdEx-3]) << 8
			m.ExpirationDate |= uint32(dAtA[iNdEx-2]) << 16
			m.ExpirationDate |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bonus", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Bonus = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusCount", wireType)
			}
			m.BonusCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefIndex", wireType)
			}
			m.DefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconItemLeagueViewPass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconItemLeagueViewPass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconItemLeagueViewPass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeagueId", wireType)
			}
			m.LeagueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeagueId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			m.Admin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Admin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemindex", wireType)
			}
			m.Itemindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemindex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconItemEventTicket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconItemEventTicket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconItemEventTicket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCItemPreviewItemBoughtNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCItemPreviewItemBoughtNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCItemPreviewItemBoughtNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemDefIndex", wireType)
			}
			m.ItemDefIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemDefIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCStorePurchaseCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			m.TxnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCStorePurchaseCancelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseCancelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseCancelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCStorePurchaseFinalize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseFinalize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseFinalize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			m.TxnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCStorePurchaseFinalizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseFinalizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCStorePurchaseFinalizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ItemIds = append(m.ItemIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBaseGcmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBaseGcmessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ItemIds = append(m.ItemIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCBannedWordListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCBannedWordListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCBannedWordListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BanListGroupId", wireType)
			}
			m.BanListGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BanListGroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordId", wireType)
			}
			m.WordId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WordId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCRequestAnnouncements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCRequestAnnouncements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCRequestAnnouncements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCRequestAnnouncementsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCRequestAnnouncementsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCRequestAnnouncementsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnouncementTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnouncementTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Announcement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Announcement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextmatchTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextmatchTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nextmatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nextmatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCBannedWord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCBannedWord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCBannedWord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordId", wireType)
			}
			m.WordId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WordId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordType", wireType)
			}
			var v GC_BannedWordType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (GC_BannedWordType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WordType = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Word", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Word = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCBannedWordListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCBannedWordListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCBannedWordListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BanListGroupId", wireType)
			}
			m.BanListGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BanListGroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WordList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WordList = append(m.WordList, &CMsgGCBannedWord{})
			if err := m.WordList[len(m.WordList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCBannedWordListBroadcast) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCBannedWordListBroadcast: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCBannedWordListBroadcast: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Broadcast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Broadcast == nil {
				m.Broadcast = &CMsgGCBannedWordListResponse{}
			}
			if err := m.Broadcast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCBannedWordListUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCBannedWordListUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCBannedWordListUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSOEconDefaultEquippedDefinitionInstanceClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSOEconDefaultEquippedDefinitionInstanceClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSOEconDefaultEquippedDefinitionInstanceClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemDefinition", wireType)
			}
			m.ItemDefinition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemDefinition |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotId", wireType)
			}
			m.SlotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCDirtySDOCache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCDirtySDOCache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCDirtySDOCache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdoType", wireType)
			}
			m.SdoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SdoType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUint64", wireType)
			}
			m.KeyUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyUint64 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCDirtyMultipleSDOCache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCDirtyMultipleSDOCache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCDirtyMultipleSDOCache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdoType", wireType)
			}
			m.SdoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SdoType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyUint64 = append(m.KeyUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBaseGcmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBaseGcmessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyUint64 = append(m.KeyUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUint64", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCCollectItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCCollectItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCCollectItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionItemId", wireType)
			}
			m.CollectionItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectItemId", wireType)
			}
			m.SubjectItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubjectItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSDONoMemcached) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSDONoMemcached: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSDONoMemcached: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCUpdateSQLKeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCUpdateSQLKeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCUpdateSQLKeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCIsTrustedServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCIsTrustedServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCIsTrustedServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCIsTrustedServerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCIsTrustedServerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCIsTrustedServerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTrusted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCBroadcastConsoleCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCBroadcastConsoleCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCBroadcastConsoleCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConCommand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCServerVersionUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCServerVersionUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCServerVersionUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			m.ServerVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCClientVersionUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCClientVersionUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCClientVersionUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			m.ClientVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCWebAPIAccountChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCWebAPIAccountChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCWebAPIAccountChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCToGCRequestPassportItemGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCToGCRequestPassportItemGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCToGCRequestPassportItemGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeagueId", wireType)
			}
			m.LeagueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeagueId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardFlag", wireType)
			}
			m.RewardFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardFlag |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGameServerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGameServerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGameServerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPublicIpAddr", wireType)
			}
			m.ServerPublicIpAddr = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ServerPublicIpAddr = uint32(dAtA[iNdEx-4])
			m.ServerPublicIpAddr |= uint32(dAtA[iNdEx-3]) << 8
			m.ServerPublicIpAddr |= uint32(dAtA[iNdEx-2]) << 16
			m.ServerPublicIpAddr |= uint32(dAtA[iNdEx-1]) << 24
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPrivateIpAddr", wireType)
			}
			m.ServerPrivateIpAddr = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.ServerPrivateIpAddr = uint32(dAtA[iNdEx-4])
			m.ServerPrivateIpAddr |= uint32(dAtA[iNdEx-3]) << 8
			m.ServerPrivateIpAddr |= uint32(dAtA[iNdEx-2]) << 16
			m.ServerPrivateIpAddr |= uint32(dAtA[iNdEx-1]) << 24
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTvPort", wireType)
			}
			m.ServerTvPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTvPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerHibernation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServerHibernation = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerType", wireType)
			}
			var v CMsgGameServerInfo_ServerType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CMsgGameServerInfo_ServerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServerType = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerRegion", wireType)
			}
			m.ServerRegion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerRegion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerLoadavg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ServerLoadavg = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTvBroadcastTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ServerTvBroadcastTime = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerGameTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ServerGameTime = float32(math.Float32frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerRelayConnectedSteamId", wireType)
			}
			m.ServerRelayConnectedSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ServerRelayConnectedSteamId = uint64(dAtA[iNdEx-8])
			m.ServerRelayConnectedSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.ServerRelayConnectedSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.ServerRelayConnectedSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.ServerRelayConnectedSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.ServerRelayConnectedSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.ServerRelayConnectedSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.ServerRelayConnectedSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelaySlotsMax", wireType)
			}
			m.RelaySlotsMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelaySlotsMax |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelaysConnected", wireType)
			}
			m.RelaysConnected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelaysConnected |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayClientsConnected", wireType)
			}
			m.RelayClientsConnected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayClientsConnected |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayedGameServerSteamId", wireType)
			}
			m.RelayedGameServerSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.RelayedGameServerSteamId = uint64(dAtA[iNdEx-8])
			m.RelayedGameServerSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.RelayedGameServerSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.RelayedGameServerSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.RelayedGameServerSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.RelayedGameServerSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.RelayedGameServerSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.RelayedGameServerSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentRelayCount", wireType)
			}
			m.ParentRelayCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentRelayCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TvSecretCode", wireType)
			}
			m.TvSecretCode = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.TvSecretCode = uint64(dAtA[iNdEx-8])
			m.TvSecretCode |= uint64(dAtA[iNdEx-7]) << 8
			m.TvSecretCode |= uint64(dAtA[iNdEx-6]) << 16
			m.TvSecretCode |= uint64(dAtA[iNdEx-5]) << 24
			m.TvSecretCode |= uint64(dAtA[iNdEx-4]) << 32
			m.TvSecretCode |= uint64(dAtA[iNdEx-3]) << 40
			m.TvSecretCode |= uint64(dAtA[iNdEx-2]) << 48
			m.TvSecretCode |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipBaseGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBaseGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBaseGcmessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBaseGcmessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBaseGcmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBaseGcmessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBaseGcmessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBaseGcmessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBaseGcmessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBaseGcmessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("base_gcmessages.proto", fileDescriptorBaseGcmessages) }

var fileDescriptorBaseGcmessages = []byte{
	// 4792 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5b, 0xdd, 0x6f, 0x2c, 0x47,
	0x56, 0xcf, 0xf8, 0x7b, 0x8e, 0xbf, 0xc6, 0x65, 0xfb, 0x7a, 0xe2, 0xfb, 0x61, 0xa7, 0xbd, 0xd9,
	0xdc, 0xdc, 0x4d, 0xbc, 0x1b, 0xdf, 0x64, 0x97, 0x24, 0x1b, 0x90, 0x3d, 0xe3, 0xeb, 0xcc, 0xc6,
	0xf7, 0x5e, 0x67, 0xc6, 0x4e, 0x36, 0x12, 0xa2, 0xa9, 0xe9, 0x2e, 0x8f, 0x7b, 0xdd, 0xd3, 0xdd,
	0xe9, 0xaa, 0xb6, 0x3d, 0x7c, 0x68, 0xf7, 0x05, 0x09, 0x24, 0x10, 0x2b, 0xa4, 0x05, 0x76, 0xf9,
	0x58, 0x16, 0x04, 0x42, 0x02, 0x5e, 0x78, 0x46, 0x48, 0x3c, 0x20, 0xf6, 0x05, 0x69, 0x9f, 0x78,
	0x5c, 0xa1, 0x20, 0x81, 0x96, 0x57, 0xf8, 0x03, 0x50, 0x9d, 0xaa, 0xea, 0xa9, 0x9e, 0x19, 0xdf,
	0xeb, 0x3c, 0xf1, 0xe6, 0x39, 0xbf, 0x73, 0xea, 0xe3, 0xf4, 0xa9, 0xf3, 0x55, 0x65, 0x58, 0x6d,
	0x53, 0xce, 0xdc, 0x8e, 0xd7, 0x65, 0x9c, 0xd3, 0x0e, 0xe3, 0xdb, 0x49, 0x1a, 0x8b, 0x78, 0x7d,
	0x99, 0x0b, 0x46, 0xbb, 0x45, 0xa2, 0xf3, 0xaf, 0x25, 0xb8, 0x5b, 0x3b, 0xa8, 0xb5, 0x44, 0x9c,
	0xb2, 0xa3, 0x2c, 0xf5, 0xce, 0x28, 0x67, 0x8d, 0x28, 0x10, 0xee, 0x61, 0x10, 0xb1, 0x86, 0x60,
	0x5d, 0xf2, 0x05, 0x98, 0x0d, 0x04, 0xeb, 0xba, 0x3e, 0x3b, 0x75, 0x03, 0xbf, 0x5a, 0xda, 0x2c,
	0xdd, 0x9f, 0xdf, 0x9b, 0xf8, 0xf1, 0x4f, 0x37, 0x5e, 0x68, 0x96, 0x25, 0x50, 0x67, 0xa7, 0x0d,
	0x9f, 0x6c, 0xc2, 0xcc, 0xa7, 0x19, 0x8d, 0x44, 0x20, 0x7a, 0xd5, 0x31, 0x8b, 0x25, 0xa7, 0x92,
	0xb7, 0xe1, 0x96, 0x17, 0x73, 0xe1, 0x06, 0x91, 0x1b, 0xc6, 0x1e, 0x0d, 0x5d, 0x2f, 0x4b, 0x53,
	0x16, 0x79, 0xbd, 0xea, 0xb8, 0xc5, 0xbf, 0x2c, 0x79, 0x1a, 0xd1, 0xa1, 0xe4, 0xa8, 0x69, 0x06,
	0xf2, 0x2a, 0xcc, 0x27, 0x7a, 0x6d, 0xae, 0xe8, 0x25, 0xac, 0x3a, 0x61, 0x49, 0xcc, 0x19, 0xe8,
	0xb8, 0x97, 0x30, 0xe7, 0x1f, 0x4a, 0xb0, 0x56, 0x7b, 0xcc, 0x3b, 0x23, 0xb6, 0x44, 0xee, 0xc1,
	0xb4, 0x17, 0x67, 0x91, 0x48, 0x7b, 0xb8, 0x8b, 0xb2, 0x1e, 0xc0, 0x10, 0xe5, 0x1e, 0x42, 0x1a,
	0x75, 0x32, 0xda, 0x61, 0xb8, 0x87, 0x49, 0xb3, 0x07, 0x43, 0x95, 0x1c, 0x85, 0x55, 0xe7, 0x1c,
	0x86, 0x4a, 0xde, 0x03, 0x08, 0x83, 0x88, 0xb9, 0x52, 0x33, 0xbc, 0x3a, 0xb1, 0x39, 0x7e, 0x7f,
	0x76, 0xe7, 0xde, 0xf6, 0x33, 0x35, 0xdc, 0x2c, 0x87, 0xfa, 0x2f, 0xee, 0xfc, 0x22, 0x6c, 0x5c,
	0xb3, 0xfa, 0x26, 0xe3, 0x49, 0x1c, 0x71, 0x46, 0xee, 0xc0, 0x54, 0xca, 0x78, 0x16, 0x0a, 0xdc,
	0x84, 0x59, 0x81, 0xa6, 0x91, 0xdb, 0x30, 0x25, 0xae, 0x22, 0xf9, 0xa1, 0xe4, 0x0e, 0x26, 0x34,
	0x3a, 0x29, 0xae, 0xa2, 0x86, 0xef, 0x7c, 0x1b, 0x16, 0x6a, 0xad, 0xa7, 0x47, 0x34, 0x15, 0xbd,
	0x46, 0x74, 0x11, 0x08, 0x46, 0xb6, 0x60, 0xa6, 0x93, 0xc6, 0x59, 0x62, 0xbe, 0xec, 0xc4, 0xde,
	0xcc, 0x77, 0xfe, 0xea, 0x6e, 0x49, 0xe9, 0x05, 0x91, 0x86, 0x4f, 0x5e, 0x82, 0x32, 0x67, 0x91,
	0xcf, 0x52, 0x33, 0xec, 0x94, 0xd9, 0xb6, 0x22, 0x37, 0x7c, 0xf2, 0x32, 0xcc, 0x6a, 0x96, 0x88,
	0x76, 0x19, 0xea, 0xc6, 0xa8, 0x17, 0x14, 0xf0, 0x84, 0x76, 0x99, 0x5e, 0xc0, 0x61, 0xdc, 0x6e,
	0xff, 0x3f, 0x2d, 0xe0, 0x2d, 0x58, 0x96, 0xfa, 0x6d, 0xf5, 0xb8, 0x60, 0xdd, 0xbd, 0x34, 0xa6,
	0xbe, 0x47, 0x39, 0x5a, 0x86, 0x3e, 0x17, 0x45, 0xcb, 0xd0, 0x44, 0xe7, 0x37, 0x4b, 0xb0, 0x24,
	0xe5, 0xd4, 0xa2, 0x8f, 0x63, 0x54, 0x21, 0xd9, 0x80, 0x19, 0x3c, 0x52, 0x66, 0xed, 0x66, 0x55,
	0xd3, 0x48, 0x6d, 0xf8, 0xe4, 0x4b, 0xb0, 0xe0, 0x85, 0x01, 0x8b, 0x84, 0x7b, 0xc1, 0x52, 0x1e,
	0xc4, 0x51, 0xe1, 0x68, 0xcc, 0x2b, 0xec, 0x23, 0x05, 0xc9, 0x1d, 0xa8, 0xc1, 0x70, 0x8e, 0xc2,
	0xa1, 0x00, 0x1c, 0x0f, 0xe9, 0xce, 0x27, 0xb0, 0x9a, 0xaf, 0x84, 0x8a, 0x20, 0x8e, 0x6a, 0x29,
	0xa3, 0x82, 0xf9, 0x72, 0x35, 0x03, 0x9a, 0x9c, 0x28, 0x6a, 0xd1, 0x5e, 0xee, 0xd8, 0x88, 0xe5,
	0x3a, 0x7f, 0xab, 0xcf, 0x8e, 0x65, 0x20, 0xb9, 0xd5, 0x6d, 0xc0, 0x4c, 0x22, 0xc9, 0x43, 0xa3,
	0x23, 0xb5, 0xe1, 0x4b, 0xb3, 0xa4, 0x9e, 0xc7, 0x12, 0x81, 0x63, 0xcf, 0x18, 0xb3, 0x54, 0xb4,
	0x11, 0x9a, 0x18, 0xbf, 0xb1, 0x26, 0x26, 0xae, 0xd1, 0xc4, 0x9b, 0xea, 0x9b, 0x7c, 0x10, 0x78,
	0xe7, 0x8f, 0xd2, 0xb8, 0x7b, 0xb3, 0x6f, 0xe2, 0x54, 0x60, 0x41, 0x4a, 0x1d, 0x32, 0x7a, 0xc1,
	0x50, 0xc4, 0x59, 0xd5, 0x36, 0xc1, 0xd2, 0x0b, 0x96, 0xee, 0x5e, 0xd0, 0x20, 0xa4, 0xed, 0x90,
	0x39, 0x6f, 0xc3, 0x2d, 0x64, 0xdc, 0x7d, 0x32, 0x80, 0xc8, 0x39, 0x42, 0x69, 0xc2, 0x43, 0x73,
	0x20, 0xb5, 0xe1, 0x3b, 0x7f, 0x3f, 0x06, 0xd5, 0x5a, 0xeb, 0xe9, 0xbe, 0x17, 0x47, 0x07, 0xb4,
	0xcb, 0x76, 0x3d, 0xf4, 0x30, 0x35, 0xdc, 0x24, 0x79, 0x0f, 0x5e, 0xa4, 0xbe, 0x1f, 0xc8, 0x4f,
	0x47, 0x43, 0xb7, 0x4d, 0xbd, 0xf3, 0x84, 0x7a, 0xe7, 0x2e, 0x0f, 0x63, 0xc1, 0x95, 0x77, 0x7d,
	0xa7, 0xf4, 0x95, 0xe6, 0x5a, 0x9f, 0x67, 0x4f, 0xb3, 0xb4, 0x24, 0x07, 0xd9, 0x85, 0xf5, 0x76,
	0x1c, 0x65, 0xdc, 0xbd, 0x4a, 0x5c, 0x11, 0x74, 0x19, 0x17, 0xb4, 0x9b, 0xb8, 0x29, 0x3b, 0x4d,
	0x19, 0x3f, 0xab, 0xce, 0x6d, 0x96, 0xee, 0x4f, 0xeb, 0xe5, 0xac, 0x21, 0xdf, 0x37, 0x93, 0x63,
	0xc3, 0xd5, 0x54, 0x4c, 0x64, 0x07, 0x48, 0x3e, 0x44, 0xc6, 0x99, 0x7f, 0x1a, 0xd2, 0x0e, 0xaf,
	0xce, 0x5b, 0x6a, 0xae, 0x68, 0xd1, 0x13, 0x83, 0xca, 0x0f, 0xc8, 0x42, 0x76, 0x21, 0x2d, 0xcd,
	0xe5, 0x82, 0x0a, 0x56, 0x5d, 0xb0, 0x3f, 0xa0, 0xc1, 0x5a, 0x12, 0x22, 0x0f, 0x81, 0xe4, 0xcc,
	0xf9, 0x1a, 0xab, 0x8b, 0x96, 0xc0, 0x92, 0xc1, 0xf3, 0xc5, 0x39, 0xff, 0x58, 0x42, 0xa5, 0x49,
	0x3f, 0x58, 0x4b, 0x03, 0xc1, 0xd2, 0x80, 0xd6, 0xe2, 0x48, 0x29, 0x81, 0xac, 0xc0, 0x58, 0x9c,
	0x14, 0x1c, 0xde, 0x58, 0x9c, 0x90, 0x75, 0x98, 0x3c, 0x0d, 0x58, 0xa8, 0xcc, 0xd9, 0x1c, 0x5a,
	0x45, 0x92, 0xae, 0x3a, 0x65, 0x9f, 0x66, 0x41, 0xca, 0x7c, 0xb4, 0x35, 0x63, 0x91, 0x39, 0x55,
	0x9a, 0xd9, 0x69, 0x18, 0x53, 0xe1, 0x5e, 0xd0, 0x30, 0x53, 0x66, 0x36, 0x66, 0xcc, 0x0c, 0x81,
	0x8f, 0x24, 0x9d, 0xbc, 0x02, 0x73, 0x5c, 0xa4, 0x41, 0xd4, 0xd1, 0x7c, 0x93, 0xd6, 0x5c, 0xb3,
	0x0a, 0x41, 0x46, 0xe7, 0xb7, 0x27, 0x60, 0x71, 0x60, 0x03, 0x64, 0x0b, 0x00, 0x83, 0x67, 0xc8,
	0x2e, 0x58, 0x38, 0x1c, 0x3b, 0x0f, 0x25, 0x59, 0xce, 0x80, 0x4c, 0x9f, 0x66, 0x34, 0x34, 0xf1,
	0xd3, 0x6c, 0x13, 0x63, 0xef, 0x87, 0x0a, 0x20, 0x0f, 0x60, 0xa1, 0x3f, 0x9a, 0xcb, 0x99, 0x28,
	0xec, 0x6c, 0x2e, 0x1f, 0xb1, 0xc5, 0x04, 0xd9, 0x86, 0x8a, 0x3d, 0x28, 0x72, 0x4f, 0x58, 0xdc,
	0x0b, 0xd6, 0xc0, 0x92, 0xff, 0x0d, 0x58, 0x0a, 0xa2, 0x40, 0x04, 0x34, 0x94, 0xe7, 0x8e, 0x45,
	0x22, 0x4e, 0x7b, 0xb8, 0xd7, 0xdc, 0x26, 0x34, 0xdc, 0x30, 0x28, 0xf9, 0x32, 0x18, 0x9a, 0x9b,
	0xc7, 0xfe, 0x29, 0x4b, 0x62, 0x51, 0xa3, 0x1f, 0x9a, 0x14, 0xe0, 0x4d, 0x58, 0x0e, 0x3a, 0x51,
	0x9c, 0x32, 0x97, 0x45, 0xf2, 0x24, 0xf9, 0xae, 0x34, 0xae, 0xea, 0x8c, 0xb5, 0xac, 0x25, 0xc5,
	0xb0, 0xaf, 0xf0, 0x47, 0x21, 0xed, 0x90, 0xb7, 0x01, 0x3c, 0x63, 0x08, 0xbc, 0x5a, 0xc6, 0x90,
	0xfa, 0xe2, 0xf6, 0x75, 0xa6, 0xd2, 0xb4, 0x98, 0xe5, 0x27, 0x46, 0x25, 0xa4, 0x34, 0x95, 0x8b,
	0x03, 0x4b, 0xb1, 0xf8, 0x5d, 0x9a, 0x48, 0x27, 0xaf, 0xc1, 0xa2, 0xc5, 0x86, 0xaa, 0x9a, 0xb5,
	0xd6, 0x34, 0xdf, 0x67, 0x95, 0x9a, 0x7a, 0x19, 0x66, 0x53, 0xe6, 0x49, 0x5f, 0x16, 0x47, 0x61,
	0x0f, 0x8f, 0x9c, 0xe1, 0x04, 0x05, 0x3c, 0x8d, 0xc2, 0x9e, 0xf3, 0x67, 0x53, 0x30, 0xaf, 0x17,
	0xd9, 0x64, 0x5e, 0x90, 0x30, 0x19, 0xc6, 0x30, 0x89, 0x8a, 0x7c, 0x76, 0x55, 0xb0, 0x85, 0x19,
	0x9f, 0x9d, 0x36, 0x24, 0x95, 0x54, 0x61, 0x02, 0xe3, 0x97, 0x6d, 0xd0, 0x48, 0x21, 0xab, 0x30,
	0x1e, 0xb9, 0xb4, 0x10, 0xd8, 0xc6, 0xa2, 0x5d, 0xb9, 0x18, 0x9f, 0x71, 0xcf, 0x0d, 0xa2, 0x24,
	0x13, 0x1c, 0xbf, 0x70, 0x1e, 0xf7, 0x24, 0xd0, 0x40, 0xba, 0x34, 0x31, 0x64, 0x8b, 0x33, 0x81,
	0x7c, 0x05, 0x23, 0x96, 0xc8, 0x53, 0x05, 0x90, 0x35, 0x98, 0xf0, 0x03, 0x97, 0xe2, 0x77, 0x34,
	0x0c, 0xe3, 0x7e, 0xb0, 0xab, 0x81, 0x76, 0x75, 0xba, 0x08, 0xec, 0x69, 0xc0, 0xc3, 0xaf, 0x68,
	0x01, 0x35, 0x04, 0x62, 0x97, 0x56, 0xcb, 0x05, 0x20, 0xde, 0xd5, 0x40, 0x1b, 0x3f, 0x87, 0x05,
	0xec, 0x69, 0xc0, 0x43, 0xe5, 0x5b, 0x40, 0x8d, 0xbc, 0x0b, 0x6b, 0xfa, 0xd8, 0x72, 0x97, 0x86,
	0xa1, 0xcb, 0x69, 0x97, 0xb9, 0x5e, 0x48, 0x39, 0x2f, 0xa8, 0x7f, 0xc5, 0x30, 0xed, 0x86, 0x61,
	0x8b, 0x76, 0x59, 0x4d, 0x72, 0xc8, 0xc4, 0x73, 0x58, 0x58, 0xba, 0x5b, 0x74, 0x79, 0x46, 0x76,
	0x79, 0x40, 0x56, 0x7a, 0x5b, 0xcc, 0x59, 0xe5, 0x18, 0x6e, 0x26, 0xd3, 0x00, 0xf7, 0x34, 0x4e,
	0xb5, 0x06, 0xd1, 0xfb, 0x4d, 0xe6, 0x39, 0xab, 0xe4, 0x39, 0x91, 0x2c, 0x8f, 0xe2, 0x54, 0x69,
	0x92, 0x7c, 0x0d, 0x56, 0xe5, 0x1c, 0xc3, 0x92, 0x8b, 0x96, 0x24, 0x91, 0x2c, 0x03, 0x82, 0x0f,
	0x60, 0x81, 0x33, 0x61, 0x4b, 0x54, 0x2c, 0x89, 0x39, 0xce, 0x44, 0x9f, 0x77, 0x0f, 0x56, 0xf0,
	0xc3, 0xab, 0x74, 0xd3, 0xf5, 0xf4, 0x61, 0xa8, 0xae, 0xe0, 0x21, 0xa9, 0x0c, 0x1e, 0x92, 0x26,
	0x41, 0x6e, 0x4c, 0x35, 0x73, 0x17, 0x55, 0x87, 0x55, 0x35, 0xcf, 0xe0, 0x20, 0xab, 0xd7, 0x0c,
	0xb2, 0xac, 0xd8, 0x8b, 0xa3, 0x3c, 0x84, 0x5b, 0xfd, 0x95, 0xb8, 0x7e, 0x96, 0x30, 0x17, 0x83,
	0x1e, 0xaf, 0xde, 0xda, 0x1c, 0xbf, 0x3f, 0xdf, 0x5c, 0xce, 0x67, 0xae, 0x67, 0x09, 0xab, 0x21,
	0xe4, 0x74, 0x54, 0x2e, 0x53, 0x67, 0x17, 0x4f, 0xd8, 0xa5, 0x3a, 0x28, 0x9f, 0x66, 0x8c, 0x0b,
	0xe5, 0xbc, 0x3d, 0x16, 0x5c, 0xb0, 0xb4, 0x10, 0x61, 0x73, 0x2a, 0x79, 0x0d, 0x66, 0xf2, 0x85,
	0xca, 0xc3, 0x32, 0x6a, 0xa1, 0x39, 0x87, 0xf3, 0x5f, 0x25, 0x95, 0x57, 0x37, 0x22, 0x2f, 0x65,
	0x5d, 0x16, 0x89, 0x0f, 0x82, 0x30, 0xc4, 0x45, 0xec, 0x0a, 0x91, 0x06, 0xed, 0x4c, 0x30, 0xf2,
	0x15, 0x58, 0x3a, 0x0f, 0xc2, 0x90, 0xa5, 0x2e, 0x55, 0xf1, 0xda, 0x84, 0x77, 0x13, 0x4f, 0x17,
	0x15, 0xac, 0xa3, 0x79, 0xc3, 0x97, 0x12, 0x17, 0x81, 0x27, 0x82, 0xae, 0x2d, 0x31, 0x66, 0x4b,
	0x28, 0xb8, 0x2f, 0x71, 0x17, 0xa6, 0x51, 0x3f, 0x81, 0x8a, 0x49, 0x26, 0x89, 0x9a, 0x92, 0xc4,
	0x86, 0x2f, 0xa3, 0x05, 0x93, 0xce, 0x75, 0xb8, 0xc8, 0x29, 0x23, 0x5d, 0x56, 0x38, 0x98, 0x68,
	0x75, 0xe5, 0x78, 0x05, 0xef, 0xac, 0x69, 0xce, 0xcf, 0x4a, 0x50, 0x91, 0x3b, 0xdd, 0x4d, 0x92,
	0xb0, 0xd7, 0x12, 0x81, 0x77, 0x8e, 0xca, 0x5a, 0xe4, 0xea, 0x4f, 0xd7, 0x4c, 0x6f, 0xe7, 0x70,
	0xf3, 0x1a, 0x6c, 0xa8, 0x55, 0x7c, 0x51, 0x87, 0x23, 0xc3, 0x6a, 0x17, 0x12, 0xe8, 0x35, 0x35,
	0x1f, 0x06, 0x46, 0x35, 0x2a, 0x9e, 0x26, 0x3b, 0xa3, 0x9b, 0xd5, 0x08, 0x9e, 0xa2, 0xd7, 0x61,
	0x51, 0x56, 0xa4, 0xa6, 0x8a, 0x0c, 0xfc, 0xab, 0xc2, 0xde, 0x16, 0x0c, 0x58, 0x47, 0xcc, 0x1e,
	0xf7, 0x92, 0xd1, 0x14, 0xb7, 0x39, 0x36, 0x30, 0xee, 0xc7, 0x8c, 0xa6, 0xce, 0xf7, 0x4a, 0xca,
	0x7e, 0xf4, 0x5e, 0xa9, 0x38, 0x4e, 0xe9, 0x79, 0xeb, 0x92, 0x26, 0x72, 0x0b, 0x22, 0x8e, 0xc3,
	0x91, 0xbb, 0x05, 0x89, 0xe8, 0x2d, 0xbc, 0xaa, 0x03, 0xea, 0x1b, 0x23, 0x37, 0x8b, 0xb1, 0xe3,
	0x8d, 0x01, 0xd6, 0x1d, 0x77, 0xd4, 0x17, 0x44, 0xd6, 0x1d, 0xc5, 0xea, 0x64, 0xb0, 0x62, 0x2d,
	0x2b, 0xa5, 0x51, 0x07, 0x33, 0x4d, 0xf2, 0x16, 0xac, 0x70, 0xf5, 0xd3, 0x95, 0x59, 0xf3, 0xc8,
	0xd5, 0x2d, 0xf1, 0xbe, 0xc0, 0xe7, 0xfb, 0x1e, 0x4e, 0xa6, 0xb2, 0x77, 0x9c, 0xf6, 0x88, 0x45,
	0x11, 0x8d, 0xc4, 0x49, 0xd2, 0x49, 0xa9, 0xcf, 0xa4, 0x01, 0x64, 0xea, 0xcf, 0xd1, 0x06, 0xa0,
	0x41, 0x3d, 0xe1, 0x6b, 0xb0, 0x98, 0x28, 0xf9, 0x91, 0x73, 0xce, 0x6b, 0x50, 0x4f, 0x1b, 0xa8,
	0xf4, 0x19, 0xa7, 0xdd, 0xef, 0x74, 0xf6, 0x39, 0x67, 0x91, 0x87, 0x53, 0x32, 0xf5, 0xe7, 0xe8,
	0x29, 0x35, 0xa8, 0xa7, 0xfc, 0x02, 0xcc, 0xb2, 0x4e, 0x67, 0xe4, 0x74, 0x65, 0xd6, 0xe9, 0xe8,
	0xa9, 0x7e, 0x0d, 0x56, 0x74, 0x5a, 0x2d, 0x09, 0xfd, 0xa3, 0x7b, 0x83, 0xc0, 0xba, 0x0e, 0x93,
	0x2a, 0x7d, 0xb3, 0x2b, 0x30, 0x45, 0x92, 0x31, 0x14, 0xff, 0x70, 0xdb, 0x3d, 0xc1, 0x38, 0x7e,
	0xd7, 0x39, 0xa3, 0x5f, 0x04, 0xf6, 0x24, 0xdd, 0xf9, 0x04, 0x96, 0xad, 0xd9, 0xf7, 0x3f, 0xcd,
	0x82, 0x24, 0x61, 0x58, 0x9c, 0x46, 0xec, 0x52, 0x47, 0xa3, 0xc2, 0xe4, 0x11, 0xbb, 0x54, 0x11,
	0x68, 0x03, 0xe4, 0xdf, 0xea, 0x94, 0xd8, 0xf3, 0x4f, 0x47, 0xec, 0x52, 0x9e, 0x10, 0xe7, 0xbb,
	0x93, 0x30, 0x6b, 0x8d, 0x2d, 0xd3, 0xdd, 0x01, 0x7d, 0x8d, 0x05, 0xe8, 0x1e, 0x06, 0x1c, 0x4d,
	0xee, 0x1e, 0x68, 0xee, 0x62, 0x1c, 0x28, 0xf7, 0xf3, 0xb7, 0xf1, 0x42, 0xc2, 0x99, 0x27, 0x6e,
	0x05, 0x7d, 0x4d, 0x8c, 0xd4, 0x97, 0xdd, 0xcf, 0x99, 0x1c, 0xd9, 0xcf, 0x59, 0x87, 0x49, 0x95,
	0xd5, 0xda, 0x29, 0x9f, 0x22, 0xc9, 0x7a, 0xda, 0x24, 0xb3, 0xd3, 0xf6, 0x7e, 0x35, 0x91, 0xac,
	0xc1, 0xa4, 0x2a, 0x3a, 0x66, 0x4c, 0xbd, 0xa3, 0x7e, 0x4b, 0xe7, 0x16, 0xa7, 0x41, 0x27, 0x88,
	0x30, 0x6b, 0xc8, 0x9d, 0x9b, 0xa2, 0xc9, 0x0f, 0xe5, 0x65, 0x5c, 0xc4, 0x5d, 0x55, 0xe4, 0xdb,
	0xf9, 0x03, 0x28, 0x40, 0x16, 0xf9, 0x16, 0x9b, 0xcc, 0x6c, 0x0a, 0xd9, 0x84, 0x66, 0xab, 0x33,
	0xee, 0x91, 0x87, 0x50, 0xa6, 0xc6, 0x84, 0xaa, 0x73, 0x18, 0xec, 0x56, 0xb7, 0x47, 0xd9, 0x57,
	0xb3, 0xcf, 0x47, 0xde, 0x80, 0xf9, 0x20, 0x92, 0x41, 0x25, 0x56, 0xbe, 0x14, 0x73, 0x88, 0xd9,
	0x9d, 0x39, 0x5b, 0xb0, 0x39, 0x67, 0x58, 0xf0, 0x63, 0xde, 0x81, 0xa9, 0x20, 0x92, 0x85, 0x16,
	0x26, 0x0d, 0x33, 0xef, 0x4c, 0x9e, 0xd2, 0x90, 0xb3, 0xe6, 0x64, 0x10, 0x9d, 0x70, 0x26, 0x55,
	0xc1, 0x45, 0x2f, 0x64, 0xaa, 0x3c, 0x42, 0x55, 0xe0, 0x6f, 0xe2, 0xc0, 0xac, 0xda, 0xb6, 0xcc,
	0xc8, 0x7d, 0x4c, 0x02, 0x26, 0x24, 0x0c, 0x86, 0xda, 0xf0, 0xc9, 0xbb, 0xb0, 0xc0, 0xb4, 0x1d,
	0xea, 0xaa, 0x8c, 0xe0, 0x3e, 0x56, 0xb6, 0x47, 0x58, 0x6a, 0x73, 0xde, 0xf0, 0xaa, 0x2a, 0xed,
	0x0e, 0x4c, 0xe9, 0xbc, 0x78, 0xd9, 0xd6, 0xb5, 0xa2, 0x39, 0x3f, 0x28, 0xc1, 0x6d, 0x3c, 0xd7,
	0xfe, 0xb7, 0x32, 0x2e, 0xec, 0x71, 0x94, 0xb4, 0x15, 0xca, 0x4a, 0x23, 0x42, 0x59, 0xe1, 0x54,
	0x8c, 0x3d, 0xf7, 0x54, 0x8c, 0x8f, 0x38, 0x15, 0x32, 0x19, 0xe6, 0x97, 0x34, 0x29, 0x94, 0x2d,
	0x48, 0x71, 0x76, 0x60, 0x1e, 0x4b, 0xf6, 0x58, 0x39, 0x49, 0x8e, 0x1d, 0xa2, 0x38, 0xd5, 0x81,
	0xb3, 0x70, 0x08, 0x25, 0x19, 0x3b, 0x83, 0x3f, 0x94, 0x91, 0x51, 0x69, 0xa5, 0x16, 0xd2, 0xa0,
	0x5b, 0x8b, 0x7d, 0x36, 0x70, 0xa4, 0x4a, 0xa3, 0x8f, 0xd4, 0x4b, 0x50, 0xf6, 0x62, 0x5f, 0xb7,
	0x1e, 0x0b, 0x7b, 0x91, 0x64, 0x0c, 0xca, 0xaf, 0xc2, 0xbc, 0x2c, 0x74, 0x5d, 0xea, 0x59, 0x25,
	0x67, 0xde, 0xa1, 0x94, 0xd0, 0xae, 0x46, 0xe4, 0xae, 0xa4, 0x58, 0x21, 0x55, 0x47, 0x8a, 0x13,
	0xa9, 0xb8, 0x81, 0xad, 0xbf, 0x03, 0x26, 0x4e, 0x38, 0x4b, 0xeb, 0x54, 0x50, 0x59, 0x36, 0x25,
	0x69, 0xe0, 0x31, 0x97, 0x9f, 0x31, 0xd6, 0xef, 0xa0, 0xd8, 0xb9, 0xc9, 0x12, 0x32, 0xb4, 0x24,
	0x6e, 0xba, 0x28, 0x76, 0xaf, 0x72, 0x6c, 0x54, 0xaf, 0xd2, 0xf9, 0x8d, 0x31, 0xb8, 0x33, 0x6a,
	0xc2, 0x1b, 0xb6, 0x1a, 0xdf, 0x82, 0x65, 0x33, 0x94, 0xeb, 0xb3, 0x24, 0x65, 0x9e, 0x2c, 0xe8,
	0x0b, 0x73, 0x11, 0xc3, 0x50, 0xcf, 0x71, 0xf2, 0x10, 0x88, 0x6e, 0xb8, 0xda, 0x52, 0x76, 0x5d,
	0xb3, 0xa4, 0x71, 0x4b, 0xe8, 0x1a, 0x15, 0x4c, 0x3c, 0x5b, 0x05, 0x2f, 0xc3, 0xac, 0x25, 0x85,
	0xce, 0x26, 0x77, 0xec, 0x7d, 0x6e, 0xe7, 0x3f, 0x4b, 0x4a, 0xf1, 0x27, 0x89, 0x4f, 0x05, 0x46,
	0xa4, 0x96, 0x77, 0xc6, 0xba, 0x79, 0xf5, 0xce, 0xdd, 0x8e, 0x74, 0x37, 0x25, 0x4b, 0x1c, 0xab,
	0x77, 0x7e, 0x20, 0xbd, 0x8d, 0x2c, 0x6a, 0xe5, 0x41, 0xe0, 0x28, 0x53, 0xe8, 0xf4, 0xe5, 0x4b,
	0x0b, 0xf2, 0x31, 0xcd, 0xd2, 0x0e, 0xe0, 0x6e, 0x7f, 0x68, 0x37, 0x4b, 0x43, 0xb7, 0xbe, 0x7f,
	0xd4, 0xdc, 0xaf, 0xed, 0x1e, 0xef, 0xd7, 0x77, 0xbe, 0xf2, 0xc6, 0xc3, 0x82, 0x42, 0xd6, 0xf3,
	0xd9, 0x4e, 0xd2, 0xb0, 0xc8, 0x67, 0x7a, 0x02, 0xfd, 0x81, 0x0a, 0x86, 0x35, 0x67, 0x4b, 0x3a,
	0x3b, 0x30, 0xab, 0xba, 0xcb, 0xfb, 0x69, 0x1a, 0xa7, 0x98, 0x6e, 0xca, 0x3f, 0x5c, 0xc1, 0xae,
	0x44, 0xa1, 0xf1, 0x59, 0x46, 0xfa, 0x31, 0xbb, 0x12, 0xce, 0x5d, 0xe5, 0x06, 0x74, 0x66, 0x9e,
	0x17, 0xff, 0xba, 0x97, 0xe4, 0x1c, 0xc0, 0xa2, 0x84, 0x6b, 0x71, 0xf4, 0x11, 0x4d, 0x55, 0xc3,
	0xc4, 0xd4, 0xb0, 0xa5, 0xa1, 0x1a, 0xb6, 0x10, 0x84, 0xcb, 0x85, 0x20, 0xec, 0xec, 0xa9, 0x6f,
	0xd0, 0x64, 0x49, 0x18, 0xc8, 0x6f, 0xae, 0x46, 0xe4, 0xe4, 0x01, 0x4c, 0x7b, 0x71, 0x74, 0x41,
	0x53, 0x19, 0x5c, 0x75, 0x41, 0x52, 0x9c, 0xb0, 0x69, 0x18, 0x9c, 0xff, 0x2d, 0xa9, 0x0d, 0x9e,
	0x70, 0x75, 0x75, 0xf1, 0x1c, 0x1f, 0xf5, 0x1a, 0x2c, 0x0a, 0x9a, 0x76, 0x98, 0x70, 0x47, 0xf6,
	0x45, 0xe7, 0x15, 0xd8, 0xd2, 0xcd, 0xdc, 0xb7, 0x60, 0xad, 0x13, 0x9c, 0x0a, 0xd7, 0x4d, 0x62,
	0xc1, 0x22, 0xec, 0x7a, 0x28, 0x06, 0x99, 0x31, 0xc8, 0x12, 0x67, 0x45, 0xc2, 0x47, 0x06, 0x3c,
	0x56, 0x18, 0x79, 0x1d, 0x2a, 0x7e, 0xc6, 0x42, 0x57, 0xb9, 0x42, 0x37, 0x8c, 0xbd, 0xf3, 0x42,
	0xc8, 0x9d, 0x97, 0x28, 0x3a, 0xc4, 0xc3, 0xd8, 0x3b, 0x27, 0x3b, 0x40, 0x54, 0xd7, 0x44, 0xc4,
	0x69, 0x7f, 0x59, 0x93, 0xd6, 0xb2, 0x2a, 0x39, 0xae, 0x57, 0xe6, 0xfc, 0xa8, 0x64, 0xbe, 0x51,
	0x12, 0xd2, 0xde, 0x49, 0x12, 0xc6, 0xd4, 0x67, 0xfe, 0x71, 0xfc, 0x49, 0x9c, 0x1d, 0x67, 0x6d,
	0x8c, 0x87, 0xbd, 0x38, 0x13, 0x59, 0x5b, 0xd9, 0x87, 0xfd, 0x5d, 0x40, 0x03, 0x27, 0x69, 0x48,
	0xbe, 0x0a, 0x2b, 0x86, 0xcd, 0xf8, 0xc4, 0xa1, 0x5e, 0x04, 0xd1, 0x1c, 0xba, 0xa4, 0xc1, 0x70,
	0xbb, 0x05, 0xc0, 0x19, 0x97, 0x56, 0x3d, 0x98, 0x15, 0x97, 0x35, 0xbd, 0xe1, 0x3b, 0xbf, 0xa0,
	0x92, 0xd3, 0x5a, 0x1c, 0xf1, 0xac, 0x4b, 0xdb, 0x21, 0xdb, 0xbf, 0x3a, 0xa3, 0x19, 0x97, 0x67,
	0x7b, 0xc4, 0x05, 0xd3, 0xe4, 0xd0, 0x05, 0x93, 0xf3, 0x5b, 0x63, 0xb0, 0x89, 0x25, 0x9c, 0x8c,
	0xcc, 0xde, 0x79, 0x14, 0x5f, 0x86, 0xcc, 0xef, 0x30, 0xdf, 0xb5, 0x0e, 0xce, 0xcd, 0xdc, 0x79,
	0x21, 0x43, 0x1a, 0xbb, 0x41, 0x86, 0x34, 0x3e, 0x32, 0x43, 0xb2, 0x72, 0x9c, 0x89, 0x51, 0x39,
	0x4e, 0x3f, 0xbc, 0x4e, 0x0e, 0x87, 0x57, 0x2b, 0xd1, 0x99, 0x1a, 0x91, 0xe8, 0x58, 0x86, 0x3b,
	0x3d, 0x6c, 0xb8, 0xce, 0x4f, 0xb5, 0xc3, 0x6a, 0x31, 0x0c, 0x7f, 0x47, 0x31, 0xd7, 0xfd, 0xae,
	0x86, 0x2e, 0x52, 0x12, 0x43, 0xd1, 0x67, 0xc6, 0xd9, 0x1e, 0xc5, 0xbe, 0x6d, 0xff, 0x52, 0x5d,
	0xae, 0x1c, 0x5b, 0xff, 0x55, 0x98, 0xb3, 0x61, 0xe9, 0x67, 0x42, 0xd6, 0xa1, 0x5e, 0xaf, 0x90,
	0xce, 0xe7, 0x21, 0x4e, 0x61, 0x3a, 0x9b, 0xdf, 0x84, 0x19, 0xb3, 0x82, 0x62, 0xbc, 0x34, 0xd4,
	0xe7, 0x14, 0xc2, 0xce, 0x3f, 0x8f, 0xa9, 0xde, 0xfe, 0x41, 0xad, 0xc9, 0x92, 0x38, 0x15, 0xbb,
	0xed, 0x8c, 0xb3, 0x51, 0xe7, 0xb5, 0x74, 0xfd, 0x79, 0x95, 0xb6, 0x20, 0xc5, 0x86, 0xc3, 0x76,
	0x19, 0xe9, 0x18, 0xb7, 0x5f, 0x81, 0x39, 0x2f, 0x8e, 0x44, 0x5e, 0x73, 0x17, 0x6a, 0x58, 0x8d,
	0x20, 0xe3, 0x17, 0x55, 0x9f, 0x2d, 0x0d, 0x12, 0x61, 0x02, 0x4f, 0xa1, 0x7f, 0xa6, 0x01, 0x72,
	0x0b, 0xc6, 0x3b, 0xfa, 0xc0, 0x9a, 0x4d, 0x49, 0x02, 0xf9, 0x1a, 0xac, 0xea, 0xb5, 0xa3, 0x9f,
	0xe6, 0x78, 0xa5, 0xe0, 0x06, 0x09, 0x7e, 0x7e, 0x13, 0x27, 0x88, 0x62, 0x91, 0xee, 0x5a, 0xdd,
	0x39, 0x34, 0x12, 0xf2, 0x2e, 0xac, 0x8d, 0x10, 0x94, 0x4a, 0x29, 0xa4, 0xd6, 0x2b, 0x83, 0xa2,
	0x47, 0x71, 0x2a, 0x9c, 0xdf, 0x2b, 0xc1, 0x8b, 0x43, 0x7a, 0xcc, 0xc3, 0xfb, 0xe7, 0xd3, 0x67,
	0x3f, 0x19, 0x18, 0x2b, 0xd8, 0xb3, 0x4a, 0x06, 0x5e, 0x85, 0x79, 0x15, 0x4b, 0xcc, 0x3d, 0x9a,
	0x1d, 0xbf, 0xe6, 0x10, 0x7a, 0xac, 0x2f, 0xd3, 0xfe, 0xb2, 0x04, 0xeb, 0x6a, 0x51, 0xd2, 0x7d,
	0x48, 0x93, 0x79, 0x12, 0x8b, 0xe0, 0x54, 0x7a, 0x7d, 0xa9, 0xc1, 0x2f, 0xc1, 0x82, 0x74, 0x63,
	0x4c, 0xbb, 0xbf, 0xc1, 0x45, 0x29, 0xac, 0xa5, 0xa0, 0xbc, 0x23, 0xde, 0x3f, 0xac, 0xf6, 0xe2,
	0xe6, 0x8c, 0xfb, 0xc0, 0x03, 0x6b, 0x3a, 0xe2, 0x11, 0x36, 0x0f, 0xb1, 0x0e, 0x28, 0xac, 0x12,
	0x47, 0x92, 0x4b, 0xaa, 0x21, 0xe6, 0xfc, 0xdd, 0x98, 0xb9, 0x8c, 0x55, 0x37, 0x37, 0xf5, 0x80,
	0xcb, 0xc9, 0x0b, 0x8b, 0x6d, 0xc1, 0x56, 0x64, 0xfd, 0x76, 0x45, 0x20, 0x42, 0xa6, 0xee, 0xb7,
	0x83, 0x5f, 0x51, 0xa4, 0x73, 0x56, 0xbc, 0x6e, 0xde, 0xb4, 0x05, 0x8e, 0x25, 0xff, 0xa1, 0xc5,
	0xfe, 0x01, 0xeb, 0x91, 0x0f, 0xc1, 0x29, 0x0c, 0xda, 0x8e, 0xfd, 0xde, 0xf0, 0x98, 0xb6, 0x5b,
	0xde, 0xb0, 0xf9, 0xf7, 0x62, 0xbf, 0x37, 0x38, 0xe4, 0x36, 0x2c, 0xe3, 0x28, 0x3c, 0x6b, 0xeb,
	0xcb, 0x8c, 0x73, 0xd6, 0x53, 0x81, 0xab, 0xdc, 0x5c, 0x92, 0x50, 0xcb, 0x20, 0x1f, 0xb0, 0x1e,
	0x27, 0x3b, 0xb0, 0x3a, 0xc0, 0x8f, 0x51, 0x5a, 0xdd, 0x68, 0x97, 0x9b, 0xcb, 0x05, 0x09, 0x8c,
	0xc2, 0xdc, 0x79, 0x94, 0xdf, 0xbc, 0x9f, 0xc5, 0xd8, 0xcd, 0xe3, 0x47, 0x81, 0x77, 0xce, 0xfc,
	0x93, 0xe4, 0x73, 0x7d, 0x53, 0xe7, 0x9f, 0x4a, 0xca, 0xd3, 0x1f, 0xd4, 0x86, 0xdb, 0x75, 0xb9,
	0xed, 0xbe, 0x79, 0x5d, 0xb7, 0x6e, 0xde, 0xba, 0x40, 0x1e, 0xea, 0xd8, 0xc9, 0xaa, 0x24, 0xeb,
	0xba, 0x92, 0x3c, 0x58, 0x95, 0x64, 0x5d, 0x39, 0x09, 0x56, 0x25, 0xc6, 0xa2, 0x8a, 0x55, 0x89,
	0xb6, 0x25, 0xe9, 0x57, 0xd4, 0xfd, 0xcb, 0x70, 0x93, 0x0e, 0xe9, 0x58, 0x6c, 0xfc, 0x4f, 0x29,
	0xbf, 0x01, 0xc4, 0x9e, 0x67, 0x1a, 0x27, 0x4d, 0x2a, 0xd8, 0x5e, 0x1c, 0x65, 0xfc, 0x66, 0x51,
	0xea, 0x75, 0x58, 0x64, 0x57, 0x49, 0x90, 0xaa, 0x0f, 0x2e, 0x13, 0xd3, 0x42, 0x4a, 0xb9, 0xd0,
	0x07, 0xeb, 0xb2, 0x1c, 0x5b, 0x87, 0x49, 0xbc, 0xb3, 0xc3, 0x35, 0x9b, 0x6e, 0x99, 0x22, 0xc9,
	0xf8, 0xaf, 0xee, 0xfb, 0x70, 0xec, 0xe2, 0x7d, 0x2a, 0x02, 0xa8, 0x5a, 0xdb, 0x27, 0x4f, 0x8e,
	0xae, 0xe8, 0xfa, 0xa7, 0x6c, 0x6a, 0x54, 0x48, 0x74, 0xfe, 0x46, 0xba, 0x9b, 0xfe, 0xae, 0x0f,
	0x19, 0xed, 0x64, 0xec, 0xa3, 0x80, 0x5d, 0x1e, 0xc9, 0x7a, 0xef, 0x95, 0x11, 0xdb, 0xee, 0x7f,
	0x2b, 0x6b, 0xeb, 0x2f, 0x43, 0x39, 0x44, 0xd1, 0x7e, 0x9b, 0xa3, 0xcf, 0x37, 0xa3, 0xa0, 0x86,
	0x2f, 0xb7, 0x4c, 0xfd, 0x6e, 0x50, 0xbc, 0x4a, 0x56, 0x24, 0x8c, 0xf1, 0x82, 0x75, 0x87, 0x3b,
	0x1c, 0x7d, 0xb2, 0xf3, 0xeb, 0x70, 0xcb, 0xae, 0x92, 0xb1, 0xc1, 0x2a, 0x0d, 0x56, 0xdc, 0xec,
	0x03, 0x6d, 0xc0, 0x8c, 0x6a, 0xd6, 0x0e, 0xf4, 0x62, 0xa6, 0x91, 0xfa, 0xdc, 0x66, 0xaf, 0x73,
	0x02, 0xaf, 0x68, 0x2b, 0x97, 0x61, 0x36, 0x65, 0x17, 0x81, 0xea, 0x81, 0xef, 0xc5, 0x59, 0xe7,
	0x4c, 0x14, 0xbc, 0xcc, 0xb0, 0x97, 0x2b, 0x5d, 0xe7, 0xe5, 0x9c, 0x9f, 0x33, 0x1e, 0xbf, 0xf0,
	0x82, 0xa4, 0x46, 0x23, 0x8f, 0x85, 0xd6, 0xeb, 0x90, 0xd2, 0xf0, 0xeb, 0x90, 0x5d, 0x78, 0xe9,
	0x5a, 0xc9, 0x6b, 0x4a, 0xc2, 0x81, 0x28, 0xe0, 0xbc, 0xa3, 0x12, 0xd1, 0x81, 0x21, 0x1e, 0x05,
	0x91, 0x74, 0x46, 0xec, 0xd9, 0xd3, 0xff, 0x12, 0x6c, 0x3d, 0x43, 0xf6, 0x66, 0x0b, 0x20, 0x2f,
	0xea, 0xd3, 0x1b, 0xf8, 0xf2, 0x7c, 0x8f, 0xdf, 0x9f, 0x50, 0xe7, 0xb6, 0xe1, 0x73, 0xa7, 0x6b,
	0xd6, 0xb6, 0x47, 0xa3, 0x88, 0xf9, 0x1f, 0xc7, 0xa9, 0x7f, 0x18, 0x70, 0x61, 0xae, 0x1c, 0xbe,
	0x0c, 0x4b, 0x6d, 0x1a, 0xb9, 0x61, 0xc0, 0x85, 0x5b, 0x78, 0x47, 0x61, 0xb5, 0xa9, 0x23, 0x29,
	0x70, 0xa0, 0x9f, 0x53, 0xdc, 0x85, 0xe9, 0xcb, 0x38, 0xf5, 0x07, 0x3f, 0xff, 0x94, 0x24, 0x36,
	0x7c, 0xe7, 0x8e, 0x09, 0x72, 0x7a, 0x82, 0xdd, 0x28, 0x8a, 0xb3, 0xc8, 0x43, 0x77, 0xc6, 0x9d,
	0x7f, 0x2b, 0x81, 0x73, 0x3d, 0x9c, 0x6f, 0xf6, 0x21, 0x10, 0x6a, 0x01, 0x2a, 0xbc, 0x14, 0xa2,
	0xc9, 0x92, 0x8d, 0x63, 0x34, 0x21, 0xf7, 0x61, 0xce, 0x26, 0x16, 0x02, 0x45, 0x01, 0x91, 0x3e,
	0x26, 0x62, 0x57, 0xa2, 0x4b, 0x85, 0x77, 0xa6, 0xc7, 0x2e, 0x04, 0xc4, 0x1c, 0x54, 0x03, 0x3b,
	0x50, 0xce, 0x29, 0x85, 0x0c, 0xa8, 0x4f, 0x76, 0xbe, 0xaf, 0xef, 0x1f, 0x6c, 0x35, 0xdb, 0xaa,
	0x2a, 0x0d, 0xab, 0x8a, 0x1c, 0x42, 0x19, 0xe1, 0x3c, 0x51, 0x5b, 0xd8, 0x21, 0xdb, 0x07, 0x35,
	0xb7, 0x3f, 0x82, 0xf4, 0xa9, 0xef, 0xdc, 0x96, 0xa4, 0xdd, 0x27, 0x4f, 0xf6, 0xeb, 0xee, 0xc7,
	0x4f, 0x9b, 0x75, 0xb7, 0xde, 0x68, 0xed, 0xee, 0x1d, 0xee, 0xe3, 0x8f, 0xe6, 0xcc, 0xa5, 0x66,
	0x93, 0xe5, 0xa7, 0xfc, 0xbb, 0xb0, 0x13, 0xa4, 0x38, 0xdf, 0x56, 0xed, 0x8e, 0x61, 0x0b, 0xd0,
	0xda, 0xfe, 0xdc, 0x26, 0xb0, 0xad, 0x17, 0x2e, 0x25, 0xd0, 0xdc, 0x66, 0x77, 0x96, 0xb6, 0x07,
	0xa7, 0x50, 0x4b, 0x93, 0x62, 0xce, 0x2f, 0x9b, 0x13, 0x76, 0x1c, 0x0f, 0x2e, 0xa2, 0xff, 0x16,
	0xe9, 0x5d, 0x28, 0xb7, 0xcd, 0x0f, 0x9c, 0x7d, 0x76, 0xe7, 0xee, 0xf6, 0xb3, 0xd6, 0xdd, 0xec,
	0xf3, 0x3b, 0x7b, 0x26, 0x65, 0x19, 0x9e, 0x41, 0x75, 0x37, 0x86, 0xdf, 0x09, 0xcd, 0x0f, 0xbc,
	0x13, 0x72, 0x7e, 0x52, 0x02, 0xd3, 0x3e, 0xac, 0xb3, 0x53, 0x9a, 0x85, 0xc2, 0x74, 0xfe, 0xea,
	0xec, 0x14, 0x8b, 0xcf, 0x38, 0x6a, 0x44, 0x5c, 0x48, 0xc7, 0xa0, 0xdf, 0xb4, 0xdc, 0xd8, 0xb5,
	0xbf, 0xae, 0x6f, 0xda, 0xfd, 0x7c, 0xa4, 0xc2, 0xe1, 0x59, 0x30, 0xd7, 0x40, 0x0a, 0x23, 0x5b,
	0x30, 0xa3, 0xca, 0xe6, 0xc0, 0x74, 0xd4, 0xac, 0xd7, 0x61, 0x88, 0x60, 0x60, 0x9a, 0xc6, 0x9b,
	0xd6, 0xc0, 0xd7, 0x9e, 0xbe, 0xcf, 0x33, 0x25, 0x81, 0x86, 0xef, 0xb8, 0x26, 0x35, 0x91, 0x6a,
	0xa9, 0x07, 0xa9, 0xe8, 0xb5, 0xea, 0x4f, 0x6b, 0xd4, 0x3b, 0xc3, 0xc7, 0x3c, 0xdc, 0x8f, 0x87,
	0x1b, 0x87, 0xd3, 0xdc, 0x8f, 0xd1, 0x9e, 0xb6, 0x00, 0xce, 0x59, 0xcf, 0xcd, 0x82, 0x48, 0x7c,
	0xf5, 0xcd, 0xe2, 0xcd, 0xc4, 0x39, 0xeb, 0x9d, 0x20, 0xd9, 0xa1, 0xb6, 0xde, 0x71, 0x82, 0xc7,
	0x59, 0x28, 0x82, 0x24, 0x64, 0x37, 0x9f, 0xe8, 0xee, 0xc0, 0x44, 0xd2, 0x7b, 0x59, 0x53, 0x64,
	0xa6, 0x24, 0xaa, 0xc5, 0x61, 0xc8, 0x3c, 0x2c, 0xe5, 0xc8, 0x0e, 0x10, 0x4f, 0xfd, 0xc4, 0xf2,
	0x7b, 0x44, 0xb3, 0xa3, 0xd2, 0xc7, 0xfb, 0xd7, 0x3b, 0x3c, 0x6b, 0x7f, 0x8b, 0x79, 0xd7, 0x5c,
	0xef, 0x68, 0x50, 0xdf, 0xb9, 0xac, 0x00, 0xc1, 0xda, 0xb1, 0xfe, 0xf4, 0x49, 0xfc, 0x98, 0x75,
	0x3d, 0xb9, 0x17, 0xdf, 0xf9, 0x79, 0xe3, 0x4c, 0xe5, 0x7e, 0x95, 0x65, 0xb5, 0x3e, 0x3c, 0xfc,
	0x80, 0xf5, 0x54, 0x0b, 0x68, 0x03, 0x66, 0xe4, 0x56, 0x86, 0xda, 0x40, 0xd3, 0xe7, 0xac, 0x87,
	0xef, 0xf0, 0xbe, 0x6e, 0xa2, 0x94, 0x94, 0x6f, 0xf0, 0xe3, 0x14, 0x5b, 0x01, 0xaa, 0x72, 0x79,
	0xfe, 0x1b, 0xae, 0xf7, 0xed, 0x73, 0x34, 0x20, 0x9d, 0x9f, 0xe6, 0x2d, 0x80, 0x80, 0xbb, 0x42,
	0x61, 0x38, 0xce, 0x4c, 0x9e, 0x03, 0x18, 0x11, 0xe7, 0x1b, 0x85, 0x13, 0x69, 0x8e, 0x51, 0x2d,
	0x8e, 0x78, 0x1c, 0xb2, 0x5a, 0xdc, 0xed, 0xd2, 0x08, 0x1f, 0x0a, 0x79, 0x71, 0xe4, 0x7a, 0xea,
	0x67, 0xb1, 0x7f, 0xe2, 0xc5, 0x91, 0x66, 0x73, 0x1a, 0xc6, 0xe3, 0xab, 0x85, 0xe8, 0x4e, 0x9f,
	0x39, 0x76, 0x5f, 0x82, 0x05, 0x5d, 0xbb, 0xd9, 0xfd, 0xdb, 0xbc, 0x0b, 0xc4, 0x6d, 0x99, 0xfe,
	0x50, 0x35, 0xfb, 0x61, 0x9c, 0x35, 0xd4, 0xc0, 0x63, 0xba, 0xd2, 0xb5, 0x8f, 0xe9, 0x9c, 0x4d,
	0xb8, 0xd7, 0xdf, 0xe1, 0xc7, 0xac, 0xbd, 0x7b, 0xd4, 0x30, 0xef, 0xd1, 0xce, 0x68, 0xd4, 0x61,
	0xbe, 0xf3, 0xbb, 0x79, 0x2c, 0x92, 0x2c, 0x3a, 0x1e, 0xc9, 0x8c, 0x2d, 0xd1, 0xed, 0xf5, 0x83,
	0x94, 0x46, 0xe2, 0xf9, 0xaf, 0x1d, 0x5f, 0x1a, 0x4e, 0xdb, 0x26, 0x06, 0x52, 0x36, 0x7c, 0x3a,
	0x73, 0x49, 0x53, 0xfd, 0xf0, 0xc7, 0x7e, 0x42, 0x0b, 0x0a, 0x78, 0x14, 0xd2, 0x8e, 0xf3, 0x3b,
	0x33, 0xca, 0xe8, 0xac, 0x42, 0x38, 0x3a, 0x8d, 0xf1, 0x49, 0x85, 0x2e, 0x7f, 0xb3, 0x76, 0x18,
	0x78, 0x6e, 0x90, 0xb8, 0xd4, 0xf7, 0xd3, 0x42, 0x27, 0x9c, 0x28, 0x96, 0x23, 0xe4, 0x68, 0x24,
	0xbb, 0xbe, 0x9f, 0x92, 0xb7, 0xe1, 0x96, 0x11, 0x4c, 0x83, 0x0b, 0x2a, 0x58, 0x2e, 0x69, 0xa7,
	0xd4, 0xcb, 0x5a, 0x52, 0xb1, 0x68, 0x51, 0x7c, 0x57, 0xda, 0x2f, 0xb9, 0x0b, 0xaf, 0x32, 0x79,
	0x5e, 0x68, 0xab, 0x47, 0x1b, 0xc8, 0x26, 0x2e, 0x14, 0x67, 0xe1, 0x89, 0xb2, 0xc2, 0x8e, 0x2f,
	0x90, 0x17, 0xfb, 0x65, 0xc8, 0x2b, 0xcb, 0x38, 0xfb, 0x25, 0x4e, 0x59, 0xd1, 0x65, 0xc1, 0xf6,
	0x10, 0xf4, 0x46, 0xdc, 0xb3, 0xa0, 0xcd, 0xd2, 0x08, 0x13, 0x41, 0x4c, 0xbb, 0xf3, 0x97, 0x52,
	0x0a, 0x7f, 0xbf, 0x0f, 0x93, 0xc3, 0x7c, 0xb1, 0xe8, 0x65, 0xa6, 0x31, 0x94, 0xde, 0xdb, 0x1e,
	0x56, 0xe5, 0xb6, 0xfa, 0x13, 0xc3, 0xea, 0xec, 0xc9, 0x93, 0xd6, 0xd1, 0x7e, 0xad, 0xf1, 0xa8,
	0xb1, 0x5f, 0x37, 0x7b, 0x32, 0x77, 0x1a, 0x7a, 0xb4, 0x94, 0x75, 0xe4, 0xec, 0x33, 0xc3, 0x5b,
	0x6a, 0x22, 0x62, 0x19, 0x77, 0x18, 0x53, 0x9f, 0x5e, 0x74, 0xf0, 0xfa, 0x6e, 0xac, 0x68, 0xdc,
	0x87, 0x0a, 0x22, 0xef, 0x41, 0xb5, 0xaf, 0xab, 0x3c, 0x74, 0xe1, 0x43, 0x41, 0xbc, 0xd2, 0x33,
	0x62, 0xab, 0x46, 0x6b, 0xf9, 0xb9, 0x3c, 0x0e, 0xba, 0x4c, 0x96, 0xf1, 0x5a, 0x1c, 0x1b, 0x22,
	0x28, 0x36, 0x6b, 0x89, 0xe9, 0x95, 0xc8, 0x0d, 0x23, 0xff, 0x37, 0x60, 0x23, 0xdf, 0x46, 0x48,
	0x7b, 0xae, 0x17, 0x47, 0x11, 0xf3, 0xd4, 0x3b, 0x46, 0x6d, 0xce, 0x73, 0x96, 0x39, 0xdf, 0x36,
	0x1b, 0x0b, 0x69, 0xaf, 0x66, 0x58, 0x4d, 0x0f, 0xe4, 0x35, 0x58, 0x54, 0x83, 0xe0, 0x6b, 0x4d,
	0xb7, 0x4b, 0xaf, 0x0a, 0xcf, 0x26, 0xe7, 0x11, 0xc4, 0x77, 0x9a, 0x8f, 0xe9, 0x15, 0xf9, 0x32,
	0x54, 0x90, 0xc0, 0xfb, 0x73, 0x16, 0xde, 0x0d, 0xa9, 0xb1, 0x78, 0x3e, 0x0b, 0xf9, 0x3a, 0xac,
	0xe9, 0x35, 0xe2, 0x11, 0xb6, 0xe5, 0xec, 0x57, 0x43, 0xab, 0xc8, 0xa4, 0x5c, 0x83, 0x25, 0x5d,
	0x87, 0x3b, 0x08, 0x30, 0xbf, 0xd0, 0x2a, 0xca, 0x77, 0x59, 0xb1, 0x76, 0x59, 0xd5, 0x9c, 0x7d,
	0xb3, 0x30, 0x5b, 0xdc, 0x01, 0x92, 0xd0, 0x54, 0x3a, 0x17, 0xa3, 0x2e, 0x59, 0x33, 0x2e, 0xd9,
	0x0f, 0x01, 0x15, 0xae, 0x35, 0x24, 0x2b, 0xc7, 0x07, 0xb0, 0x20, 0x2e, 0x5c, 0xce, 0xbc, 0x94,
	0x09, 0x17, 0x2f, 0xb7, 0x88, 0x35, 0xd7, 0x9c, 0xb8, 0x68, 0x21, 0x54, 0x8b, 0x7d, 0xe6, 0xec,
	0x00, 0xf4, 0x8d, 0x8f, 0x2c, 0x82, 0x6d, 0x7e, 0x95, 0x17, 0xc8, 0x0c, 0x4c, 0x1c, 0xec, 0x3e,
	0xde, 0xaf, 0x94, 0x48, 0x19, 0x26, 0x8f, 0x9a, 0x4f, 0xbf, 0xf9, 0x49, 0x65, 0xec, 0xc1, 0xbf,
	0x8c, 0x03, 0xec, 0xcb, 0x7c, 0x86, 0xb3, 0xc7, 0xbc, 0x43, 0xd6, 0x61, 0xf5, 0xdc, 0xdd, 0x57,
	0xae, 0x16, 0x1f, 0x72, 0xeb, 0xce, 0x52, 0xe5, 0x47, 0x1b, 0xe4, 0x2e, 0x54, 0x0d, 0x36, 0x78,
	0x95, 0x50, 0xf9, 0xf3, 0x0d, 0x5b, 0x54, 0x51, 0xb5, 0x4f, 0xad, 0xfc, 0xc5, 0x06, 0x59, 0x81,
	0x45, 0x83, 0x35, 0xa2, 0x0f, 0x33, 0x96, 0xb1, 0xca, 0x5f, 0x17, 0x24, 0x0a, 0xaf, 0xbf, 0x2b,
	0xdf, 0xdb, 0x22, 0xf7, 0xe0, 0xc5, 0x02, 0x66, 0xbf, 0xc7, 0xae, 0xfc, 0xfe, 0x16, 0xd9, 0x84,
	0xdb, 0x06, 0x1f, 0xf1, 0xa6, 0xba, 0xf2, 0x07, 0x5b, 0xf6, 0xe8, 0x85, 0x77, 0xcc, 0x95, 0x3f,
	0xdc, 0x22, 0x6b, 0x40, 0x0c, 0xd6, 0x7f, 0xad, 0x5c, 0xf9, 0xfe, 0x16, 0xb9, 0x03, 0x6b, 0xf9,
	0xfe, 0x8b, 0x4f, 0x93, 0x2b, 0x3f, 0xd8, 0x22, 0x0e, 0xdc, 0xcd, 0xb7, 0x88, 0x26, 0xa2, 0x2d,
	0xe4, 0x38, 0x56, 0xcc, 0x95, 0x3f, 0xda, 0x22, 0xb7, 0xe1, 0x96, 0xe1, 0x29, 0x3a, 0x86, 0xca,
	0x1f, 0x6f, 0x11, 0x02, 0xf3, 0x06, 0xc4, 0x7b, 0xa2, 0xca, 0x9f, 0x6c, 0x91, 0x97, 0x61, 0xd3,
	0x56, 0x2b, 0xed, 0xb9, 0x43, 0xd7, 0x0c, 0x95, 0x3f, 0xdd, 0x22, 0x1b, 0xb0, 0x9e, 0x2f, 0x79,
	0xe8, 0xdd, 0x74, 0xe5, 0x87, 0x5b, 0x0f, 0x3e, 0x81, 0x35, 0xfd, 0x21, 0x8f, 0xd2, 0x58, 0xc4,
	0x4f, 0x31, 0xd3, 0x90, 0x96, 0xc0, 0xb5, 0x32, 0x2d, 0xb2, 0xa5, 0xb2, 0xca, 0xcf, 0xa6, 0x87,
	0x71, 0xeb, 0xdf, 0x08, 0x2a, 0xff, 0x3d, 0xfd, 0xe0, 0x18, 0x96, 0x86, 0x6a, 0x06, 0xb2, 0x01,
	0xcf, 0xaa, 0x1a, 0x2a, 0x2f, 0x90, 0x7b, 0xb0, 0x3e, 0xc0, 0xb0, 0xff, 0xa4, 0x8f, 0x97, 0xf6,
	0x56, 0x7f, 0xfc, 0xd9, 0xbd, 0xd2, 0x4f, 0x3e, 0xbb, 0x57, 0xfa, 0xf7, 0xcf, 0xee, 0x95, 0xbe,
	0xfb, 0x1f, 0xf7, 0x5e, 0x78, 0xbf, 0xf4, 0x9d, 0xd2, 0x0b, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff,
	0x53, 0xd4, 0xb3, 0x33, 0x63, 0x33, 0x00, 0x00,
}
