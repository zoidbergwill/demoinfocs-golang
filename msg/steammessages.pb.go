// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: steammessages.proto

/*
	Package steammessages is a generated protocol buffer package.

	It is generated from these files:
		steammessages.proto

	It has these top-level messages:
		CMsgProtoBufHeader
		CMsgWebAPIKey
		CMsgHttpRequest
		CMsgWebAPIRequest
		CMsgHttpResponse
		CMsgAMFindAccounts
		CMsgAMFindAccountsResponse
		CMsgNotifyWatchdog
		CMsgAMGetLicenses
		CMsgPackageLicense
		CMsgAMGetLicensesResponse
		CMsgAMGetUserGameStats
		CMsgAMGetUserGameStatsResponse
		CMsgGCGetCommandList
		CMsgGCGetCommandListResponse
		CGCMsgMemCachedGet
		CGCMsgMemCachedGetResponse
		CGCMsgMemCachedSet
		CGCMsgMemCachedDelete
		CGCMsgMemCachedStats
		CGCMsgMemCachedStatsResponse
		CGCMsgSQLStats
		CGCMsgSQLStatsResponse
		CMsgAMAddFreeLicense
		CMsgAMAddFreeLicenseResponse
		CGCMsgGetIPLocation
		CIPLocationInfo
		CGCMsgGetIPLocationResponse
		CGCMsgSystemStatsSchema
		CGCMsgGetSystemStats
		CGCMsgGetSystemStatsResponse
		CMsgAMSendEmail
		CMsgAMSendEmailResponse
		CMsgGCGetEmailTemplate
		CMsgGCGetEmailTemplateResponse
		CMsgAMGrantGuestPasses2
		CMsgAMGrantGuestPasses2Response
		CGCSystemMsg_GetAccountDetails
		CGCSystemMsg_GetAccountDetails_Response
		CMsgGCGetPersonaNames
		CMsgGCGetPersonaNames_Response
		CMsgGCCheckFriendship
		CMsgGCCheckFriendship_Response
		CMsgGCMsgMasterSetDirectory
		CMsgGCMsgMasterSetDirectory_Response
		CMsgGCMsgWebAPIJobRequestForwardResponse
		CGCSystemMsg_GetPurchaseTrust_Request
		CGCSystemMsg_GetPurchaseTrust_Response
		CMsgGCHAccountVacStatusChange
		CMsgGCGetPartnerAccountLink
		CMsgGCGetPartnerAccountLink_Response
		CMsgGCRoutingInfo
		CMsgGCMsgMasterSetWebAPIRouting
		CMsgGCMsgMasterSetClientMsgRouting
		CMsgGCMsgMasterSetWebAPIRouting_Response
		CMsgGCMsgMasterSetClientMsgRouting_Response
		CMsgGCMsgSetOptions
		CMsgGCHUpdateSession
		CMsgNotificationOfSuspiciousActivity
*/
package steammessages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"

import io "io"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GCProtoBufMsgSrc int32

const (
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_Unspecified GCProtoBufMsgSrc = 0
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_FromSystem  GCProtoBufMsgSrc = 1
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_FromSteamID GCProtoBufMsgSrc = 2
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_FromGC      GCProtoBufMsgSrc = 3
	GCProtoBufMsgSrc_GCProtoBufMsgSrc_ReplySystem GCProtoBufMsgSrc = 4
)

var GCProtoBufMsgSrc_name = map[int32]string{
	0: "GCProtoBufMsgSrc_Unspecified",
	1: "GCProtoBufMsgSrc_FromSystem",
	2: "GCProtoBufMsgSrc_FromSteamID",
	3: "GCProtoBufMsgSrc_FromGC",
	4: "GCProtoBufMsgSrc_ReplySystem",
}
var GCProtoBufMsgSrc_value = map[string]int32{
	"GCProtoBufMsgSrc_Unspecified": 0,
	"GCProtoBufMsgSrc_FromSystem":  1,
	"GCProtoBufMsgSrc_FromSteamID": 2,
	"GCProtoBufMsgSrc_FromGC":      3,
	"GCProtoBufMsgSrc_ReplySystem": 4,
}

func (x GCProtoBufMsgSrc) Enum() *GCProtoBufMsgSrc {
	p := new(GCProtoBufMsgSrc)
	*p = x
	return p
}
func (x GCProtoBufMsgSrc) String() string {
	return proto.EnumName(GCProtoBufMsgSrc_name, int32(x))
}
func (x *GCProtoBufMsgSrc) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GCProtoBufMsgSrc_value, data, "GCProtoBufMsgSrc")
	if err != nil {
		return err
	}
	*x = GCProtoBufMsgSrc(value)
	return nil
}
func (GCProtoBufMsgSrc) EnumDescriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{0} }

type CMsgGCRoutingInfo_RoutingMethod int32

const (
	CMsgGCRoutingInfo_RANDOM                CMsgGCRoutingInfo_RoutingMethod = 0
	CMsgGCRoutingInfo_DISCARD               CMsgGCRoutingInfo_RoutingMethod = 1
	CMsgGCRoutingInfo_CLIENT_STEAMID        CMsgGCRoutingInfo_RoutingMethod = 2
	CMsgGCRoutingInfo_PROTOBUF_FIELD_UINT64 CMsgGCRoutingInfo_RoutingMethod = 3
	CMsgGCRoutingInfo_WEBAPI_PARAM_UINT64   CMsgGCRoutingInfo_RoutingMethod = 4
)

var CMsgGCRoutingInfo_RoutingMethod_name = map[int32]string{
	0: "RANDOM",
	1: "DISCARD",
	2: "CLIENT_STEAMID",
	3: "PROTOBUF_FIELD_UINT64",
	4: "WEBAPI_PARAM_UINT64",
}
var CMsgGCRoutingInfo_RoutingMethod_value = map[string]int32{
	"RANDOM":                0,
	"DISCARD":               1,
	"CLIENT_STEAMID":        2,
	"PROTOBUF_FIELD_UINT64": 3,
	"WEBAPI_PARAM_UINT64":   4,
}

func (x CMsgGCRoutingInfo_RoutingMethod) Enum() *CMsgGCRoutingInfo_RoutingMethod {
	p := new(CMsgGCRoutingInfo_RoutingMethod)
	*p = x
	return p
}
func (x CMsgGCRoutingInfo_RoutingMethod) String() string {
	return proto.EnumName(CMsgGCRoutingInfo_RoutingMethod_name, int32(x))
}
func (x *CMsgGCRoutingInfo_RoutingMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMsgGCRoutingInfo_RoutingMethod_value, data, "CMsgGCRoutingInfo_RoutingMethod")
	if err != nil {
		return err
	}
	*x = CMsgGCRoutingInfo_RoutingMethod(value)
	return nil
}
func (CMsgGCRoutingInfo_RoutingMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{51, 0}
}

type CMsgGCMsgSetOptions_Option int32

const (
	CMsgGCMsgSetOptions_NOTIFY_USER_SESSIONS   CMsgGCMsgSetOptions_Option = 0
	CMsgGCMsgSetOptions_NOTIFY_SERVER_SESSIONS CMsgGCMsgSetOptions_Option = 1
	CMsgGCMsgSetOptions_NOTIFY_ACHIEVEMENTS    CMsgGCMsgSetOptions_Option = 2
	CMsgGCMsgSetOptions_NOTIFY_VAC_ACTION      CMsgGCMsgSetOptions_Option = 3
)

var CMsgGCMsgSetOptions_Option_name = map[int32]string{
	0: "NOTIFY_USER_SESSIONS",
	1: "NOTIFY_SERVER_SESSIONS",
	2: "NOTIFY_ACHIEVEMENTS",
	3: "NOTIFY_VAC_ACTION",
}
var CMsgGCMsgSetOptions_Option_value = map[string]int32{
	"NOTIFY_USER_SESSIONS":   0,
	"NOTIFY_SERVER_SESSIONS": 1,
	"NOTIFY_ACHIEVEMENTS":    2,
	"NOTIFY_VAC_ACTION":      3,
}

func (x CMsgGCMsgSetOptions_Option) Enum() *CMsgGCMsgSetOptions_Option {
	p := new(CMsgGCMsgSetOptions_Option)
	*p = x
	return p
}
func (x CMsgGCMsgSetOptions_Option) String() string {
	return proto.EnumName(CMsgGCMsgSetOptions_Option_name, int32(x))
}
func (x *CMsgGCMsgSetOptions_Option) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMsgGCMsgSetOptions_Option_value, data, "CMsgGCMsgSetOptions_Option")
	if err != nil {
		return err
	}
	*x = CMsgGCMsgSetOptions_Option(value)
	return nil
}
func (CMsgGCMsgSetOptions_Option) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{56, 0}
}

type CMsgProtoBufHeader struct {
	ClientSteamId    uint64            `protobuf:"fixed64,1,opt,name=client_steam_id,json=clientSteamId" json:"client_steam_id"`
	ClientSessionId  int32             `protobuf:"varint,2,opt,name=client_session_id,json=clientSessionId" json:"client_session_id"`
	SourceAppId      uint32            `protobuf:"varint,3,opt,name=source_app_id,json=sourceAppId" json:"source_app_id"`
	JobIdSource      *uint64           `protobuf:"fixed64,10,opt,name=job_id_source,json=jobIdSource,def=18446744073709551615" json:"job_id_source,omitempty"`
	JobIdTarget      *uint64           `protobuf:"fixed64,11,opt,name=job_id_target,json=jobIdTarget,def=18446744073709551615" json:"job_id_target,omitempty"`
	TargetJobName    string            `protobuf:"bytes,12,opt,name=target_job_name,json=targetJobName" json:"target_job_name"`
	Eresult          *int32            `protobuf:"varint,13,opt,name=eresult,def=2" json:"eresult,omitempty"`
	ErrorMessage     string            `protobuf:"bytes,14,opt,name=error_message,json=errorMessage" json:"error_message"`
	GcMsgSrc         *GCProtoBufMsgSrc `protobuf:"varint,200,opt,name=gc_msg_src,json=gcMsgSrc,enum=GCProtoBufMsgSrc,def=0" json:"gc_msg_src,omitempty"`
	GcDirIndexSource uint32            `protobuf:"varint,201,opt,name=gc_dir_index_source,json=gcDirIndexSource" json:"gc_dir_index_source"`
}

func (m *CMsgProtoBufHeader) Reset()                    { *m = CMsgProtoBufHeader{} }
func (m *CMsgProtoBufHeader) String() string            { return proto.CompactTextString(m) }
func (*CMsgProtoBufHeader) ProtoMessage()               {}
func (*CMsgProtoBufHeader) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{0} }

const Default_CMsgProtoBufHeader_JobIdSource uint64 = 18446744073709551615
const Default_CMsgProtoBufHeader_JobIdTarget uint64 = 18446744073709551615
const Default_CMsgProtoBufHeader_Eresult int32 = 2
const Default_CMsgProtoBufHeader_GcMsgSrc GCProtoBufMsgSrc = GCProtoBufMsgSrc_GCProtoBufMsgSrc_Unspecified

func (m *CMsgProtoBufHeader) GetClientSteamId() uint64 {
	if m != nil {
		return m.ClientSteamId
	}
	return 0
}

func (m *CMsgProtoBufHeader) GetClientSessionId() int32 {
	if m != nil {
		return m.ClientSessionId
	}
	return 0
}

func (m *CMsgProtoBufHeader) GetSourceAppId() uint32 {
	if m != nil {
		return m.SourceAppId
	}
	return 0
}

func (m *CMsgProtoBufHeader) GetJobIdSource() uint64 {
	if m != nil && m.JobIdSource != nil {
		return *m.JobIdSource
	}
	return Default_CMsgProtoBufHeader_JobIdSource
}

func (m *CMsgProtoBufHeader) GetJobIdTarget() uint64 {
	if m != nil && m.JobIdTarget != nil {
		return *m.JobIdTarget
	}
	return Default_CMsgProtoBufHeader_JobIdTarget
}

func (m *CMsgProtoBufHeader) GetTargetJobName() string {
	if m != nil {
		return m.TargetJobName
	}
	return ""
}

func (m *CMsgProtoBufHeader) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgProtoBufHeader_Eresult
}

func (m *CMsgProtoBufHeader) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CMsgProtoBufHeader) GetGcMsgSrc() GCProtoBufMsgSrc {
	if m != nil && m.GcMsgSrc != nil {
		return *m.GcMsgSrc
	}
	return Default_CMsgProtoBufHeader_GcMsgSrc
}

func (m *CMsgProtoBufHeader) GetGcDirIndexSource() uint32 {
	if m != nil {
		return m.GcDirIndexSource
	}
	return 0
}

type CMsgWebAPIKey struct {
	Status           *uint32 `protobuf:"varint,1,opt,name=status,def=255" json:"status,omitempty"`
	AccountId        *uint32 `protobuf:"varint,2,opt,name=account_id,json=accountId,def=0" json:"account_id,omitempty"`
	PublisherGroupId *uint32 `protobuf:"varint,3,opt,name=publisher_group_id,json=publisherGroupId,def=0" json:"publisher_group_id,omitempty"`
	KeyId            uint32  `protobuf:"varint,4,opt,name=key_id,json=keyId" json:"key_id"`
	Domain           string  `protobuf:"bytes,5,opt,name=domain" json:"domain"`
}

func (m *CMsgWebAPIKey) Reset()                    { *m = CMsgWebAPIKey{} }
func (m *CMsgWebAPIKey) String() string            { return proto.CompactTextString(m) }
func (*CMsgWebAPIKey) ProtoMessage()               {}
func (*CMsgWebAPIKey) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{1} }

const Default_CMsgWebAPIKey_Status uint32 = 255
const Default_CMsgWebAPIKey_AccountId uint32 = 0
const Default_CMsgWebAPIKey_PublisherGroupId uint32 = 0

func (m *CMsgWebAPIKey) GetStatus() uint32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_CMsgWebAPIKey_Status
}

func (m *CMsgWebAPIKey) GetAccountId() uint32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return Default_CMsgWebAPIKey_AccountId
}

func (m *CMsgWebAPIKey) GetPublisherGroupId() uint32 {
	if m != nil && m.PublisherGroupId != nil {
		return *m.PublisherGroupId
	}
	return Default_CMsgWebAPIKey_PublisherGroupId
}

func (m *CMsgWebAPIKey) GetKeyId() uint32 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *CMsgWebAPIKey) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

type CMsgHttpRequest struct {
	RequestMethod   uint32                           `protobuf:"varint,1,opt,name=request_method,json=requestMethod" json:"request_method"`
	Hostname        string                           `protobuf:"bytes,2,opt,name=hostname" json:"hostname"`
	Url             string                           `protobuf:"bytes,3,opt,name=url" json:"url"`
	Headers         []*CMsgHttpRequest_RequestHeader `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty"`
	GetParams       []*CMsgHttpRequest_QueryParam    `protobuf:"bytes,5,rep,name=get_params,json=getParams" json:"get_params,omitempty"`
	PostParams      []*CMsgHttpRequest_QueryParam    `protobuf:"bytes,6,rep,name=post_params,json=postParams" json:"post_params,omitempty"`
	Body            []byte                           `protobuf:"bytes,7,opt,name=body" json:"body"`
	AbsoluteTimeout uint32                           `protobuf:"varint,8,opt,name=absolute_timeout,json=absoluteTimeout" json:"absolute_timeout"`
}

func (m *CMsgHttpRequest) Reset()                    { *m = CMsgHttpRequest{} }
func (m *CMsgHttpRequest) String() string            { return proto.CompactTextString(m) }
func (*CMsgHttpRequest) ProtoMessage()               {}
func (*CMsgHttpRequest) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{2} }

func (m *CMsgHttpRequest) GetRequestMethod() uint32 {
	if m != nil {
		return m.RequestMethod
	}
	return 0
}

func (m *CMsgHttpRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *CMsgHttpRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *CMsgHttpRequest) GetHeaders() []*CMsgHttpRequest_RequestHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *CMsgHttpRequest) GetGetParams() []*CMsgHttpRequest_QueryParam {
	if m != nil {
		return m.GetParams
	}
	return nil
}

func (m *CMsgHttpRequest) GetPostParams() []*CMsgHttpRequest_QueryParam {
	if m != nil {
		return m.PostParams
	}
	return nil
}

func (m *CMsgHttpRequest) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *CMsgHttpRequest) GetAbsoluteTimeout() uint32 {
	if m != nil {
		return m.AbsoluteTimeout
	}
	return 0
}

type CMsgHttpRequest_RequestHeader struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgHttpRequest_RequestHeader) Reset()         { *m = CMsgHttpRequest_RequestHeader{} }
func (m *CMsgHttpRequest_RequestHeader) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpRequest_RequestHeader) ProtoMessage()    {}
func (*CMsgHttpRequest_RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{2, 0}
}

func (m *CMsgHttpRequest_RequestHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgHttpRequest_RequestHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CMsgHttpRequest_QueryParam struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value []byte `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgHttpRequest_QueryParam) Reset()         { *m = CMsgHttpRequest_QueryParam{} }
func (m *CMsgHttpRequest_QueryParam) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpRequest_QueryParam) ProtoMessage()    {}
func (*CMsgHttpRequest_QueryParam) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{2, 1}
}

func (m *CMsgHttpRequest_QueryParam) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgHttpRequest_QueryParam) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CMsgWebAPIRequest struct {
	UNUSEDJobName string           `protobuf:"bytes,1,opt,name=UNUSED_job_name,json=UNUSEDJobName" json:"UNUSED_job_name"`
	InterfaceName string           `protobuf:"bytes,2,opt,name=interface_name,json=interfaceName" json:"interface_name"`
	MethodName    string           `protobuf:"bytes,3,opt,name=method_name,json=methodName" json:"method_name"`
	Version       uint32           `protobuf:"varint,4,opt,name=version" json:"version"`
	ApiKey        *CMsgWebAPIKey   `protobuf:"bytes,5,opt,name=api_key,json=apiKey" json:"api_key,omitempty"`
	Request       *CMsgHttpRequest `protobuf:"bytes,6,opt,name=request" json:"request,omitempty"`
	RoutingAppId  uint32           `protobuf:"varint,7,opt,name=routing_app_id,json=routingAppId" json:"routing_app_id"`
}

func (m *CMsgWebAPIRequest) Reset()                    { *m = CMsgWebAPIRequest{} }
func (m *CMsgWebAPIRequest) String() string            { return proto.CompactTextString(m) }
func (*CMsgWebAPIRequest) ProtoMessage()               {}
func (*CMsgWebAPIRequest) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{3} }

func (m *CMsgWebAPIRequest) GetUNUSEDJobName() string {
	if m != nil {
		return m.UNUSEDJobName
	}
	return ""
}

func (m *CMsgWebAPIRequest) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *CMsgWebAPIRequest) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *CMsgWebAPIRequest) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgWebAPIRequest) GetApiKey() *CMsgWebAPIKey {
	if m != nil {
		return m.ApiKey
	}
	return nil
}

func (m *CMsgWebAPIRequest) GetRequest() *CMsgHttpRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CMsgWebAPIRequest) GetRoutingAppId() uint32 {
	if m != nil {
		return m.RoutingAppId
	}
	return 0
}

type CMsgHttpResponse struct {
	StatusCode uint32                             `protobuf:"varint,1,opt,name=status_code,json=statusCode" json:"status_code"`
	Headers    []*CMsgHttpResponse_ResponseHeader `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	Body       []byte                             `protobuf:"bytes,3,opt,name=body" json:"body"`
}

func (m *CMsgHttpResponse) Reset()                    { *m = CMsgHttpResponse{} }
func (m *CMsgHttpResponse) String() string            { return proto.CompactTextString(m) }
func (*CMsgHttpResponse) ProtoMessage()               {}
func (*CMsgHttpResponse) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{4} }

func (m *CMsgHttpResponse) GetStatusCode() uint32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *CMsgHttpResponse) GetHeaders() []*CMsgHttpResponse_ResponseHeader {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *CMsgHttpResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type CMsgHttpResponse_ResponseHeader struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgHttpResponse_ResponseHeader) Reset()         { *m = CMsgHttpResponse_ResponseHeader{} }
func (m *CMsgHttpResponse_ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*CMsgHttpResponse_ResponseHeader) ProtoMessage()    {}
func (*CMsgHttpResponse_ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{4, 0}
}

func (m *CMsgHttpResponse_ResponseHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgHttpResponse_ResponseHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CMsgAMFindAccounts struct {
	SearchType   uint32 `protobuf:"varint,1,opt,name=search_type,json=searchType" json:"search_type"`
	SearchString string `protobuf:"bytes,2,opt,name=search_string,json=searchString" json:"search_string"`
}

func (m *CMsgAMFindAccounts) Reset()                    { *m = CMsgAMFindAccounts{} }
func (m *CMsgAMFindAccounts) String() string            { return proto.CompactTextString(m) }
func (*CMsgAMFindAccounts) ProtoMessage()               {}
func (*CMsgAMFindAccounts) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{5} }

func (m *CMsgAMFindAccounts) GetSearchType() uint32 {
	if m != nil {
		return m.SearchType
	}
	return 0
}

func (m *CMsgAMFindAccounts) GetSearchString() string {
	if m != nil {
		return m.SearchString
	}
	return ""
}

type CMsgAMFindAccountsResponse struct {
	SteamId []uint64 `protobuf:"fixed64,1,rep,name=steam_id,json=steamId" json:"steam_id,omitempty"`
}

func (m *CMsgAMFindAccountsResponse) Reset()         { *m = CMsgAMFindAccountsResponse{} }
func (m *CMsgAMFindAccountsResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMFindAccountsResponse) ProtoMessage()    {}
func (*CMsgAMFindAccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{6}
}

func (m *CMsgAMFindAccountsResponse) GetSteamId() []uint64 {
	if m != nil {
		return m.SteamId
	}
	return nil
}

type CMsgNotifyWatchdog struct {
	Source           uint32 `protobuf:"varint,1,opt,name=source" json:"source"`
	AlertType        uint32 `protobuf:"varint,2,opt,name=alert_type,json=alertType" json:"alert_type"`
	AlertDestination uint32 `protobuf:"varint,3,opt,name=alert_destination,json=alertDestination" json:"alert_destination"`
	Critical         bool   `protobuf:"varint,4,opt,name=critical" json:"critical"`
	Time             uint32 `protobuf:"varint,5,opt,name=time" json:"time"`
	Appid            uint32 `protobuf:"varint,6,opt,name=appid" json:"appid"`
	Text             string `protobuf:"bytes,7,opt,name=text" json:"text"`
}

func (m *CMsgNotifyWatchdog) Reset()                    { *m = CMsgNotifyWatchdog{} }
func (m *CMsgNotifyWatchdog) String() string            { return proto.CompactTextString(m) }
func (*CMsgNotifyWatchdog) ProtoMessage()               {}
func (*CMsgNotifyWatchdog) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{7} }

func (m *CMsgNotifyWatchdog) GetSource() uint32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetAlertType() uint32 {
	if m != nil {
		return m.AlertType
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetAlertDestination() uint32 {
	if m != nil {
		return m.AlertDestination
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetCritical() bool {
	if m != nil {
		return m.Critical
	}
	return false
}

func (m *CMsgNotifyWatchdog) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CMsgNotifyWatchdog) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type CMsgAMGetLicenses struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
}

func (m *CMsgAMGetLicenses) Reset()                    { *m = CMsgAMGetLicenses{} }
func (m *CMsgAMGetLicenses) String() string            { return proto.CompactTextString(m) }
func (*CMsgAMGetLicenses) ProtoMessage()               {}
func (*CMsgAMGetLicenses) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{8} }

func (m *CMsgAMGetLicenses) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

type CMsgPackageLicense struct {
	PackageId   uint32 `protobuf:"varint,1,opt,name=package_id,json=packageId" json:"package_id"`
	TimeCreated uint32 `protobuf:"varint,2,opt,name=time_created,json=timeCreated" json:"time_created"`
	OwnerId     uint32 `protobuf:"varint,3,opt,name=owner_id,json=ownerId" json:"owner_id"`
}

func (m *CMsgPackageLicense) Reset()                    { *m = CMsgPackageLicense{} }
func (m *CMsgPackageLicense) String() string            { return proto.CompactTextString(m) }
func (*CMsgPackageLicense) ProtoMessage()               {}
func (*CMsgPackageLicense) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{9} }

func (m *CMsgPackageLicense) GetPackageId() uint32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *CMsgPackageLicense) GetTimeCreated() uint32 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *CMsgPackageLicense) GetOwnerId() uint32 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

type CMsgAMGetLicensesResponse struct {
	License []*CMsgPackageLicense `protobuf:"bytes,1,rep,name=license" json:"license,omitempty"`
	Result  uint32                `protobuf:"varint,2,opt,name=result" json:"result"`
}

func (m *CMsgAMGetLicensesResponse) Reset()         { *m = CMsgAMGetLicensesResponse{} }
func (m *CMsgAMGetLicensesResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetLicensesResponse) ProtoMessage()    {}
func (*CMsgAMGetLicensesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{10}
}

func (m *CMsgAMGetLicensesResponse) GetLicense() []*CMsgPackageLicense {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *CMsgAMGetLicensesResponse) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

type CMsgAMGetUserGameStats struct {
	SteamId uint64   `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	GameId  uint64   `protobuf:"fixed64,2,opt,name=game_id,json=gameId" json:"game_id"`
	Stats   []uint32 `protobuf:"varint,3,rep,name=stats" json:"stats,omitempty"`
}

func (m *CMsgAMGetUserGameStats) Reset()         { *m = CMsgAMGetUserGameStats{} }
func (m *CMsgAMGetUserGameStats) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetUserGameStats) ProtoMessage()    {}
func (*CMsgAMGetUserGameStats) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{11}
}

func (m *CMsgAMGetUserGameStats) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgAMGetUserGameStats) GetGameId() uint64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *CMsgAMGetUserGameStats) GetStats() []uint32 {
	if m != nil {
		return m.Stats
	}
	return nil
}

type CMsgAMGetUserGameStatsResponse struct {
	SteamId           uint64                                               `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	GameId            uint64                                               `protobuf:"fixed64,2,opt,name=game_id,json=gameId" json:"game_id"`
	Eresult           *int32                                               `protobuf:"varint,3,opt,name=eresult,def=2" json:"eresult,omitempty"`
	Stats             []*CMsgAMGetUserGameStatsResponse_Stats              `protobuf:"bytes,4,rep,name=stats" json:"stats,omitempty"`
	AchievementBlocks []*CMsgAMGetUserGameStatsResponse_Achievement_Blocks `protobuf:"bytes,5,rep,name=achievement_blocks,json=achievementBlocks" json:"achievement_blocks,omitempty"`
}

func (m *CMsgAMGetUserGameStatsResponse) Reset()         { *m = CMsgAMGetUserGameStatsResponse{} }
func (m *CMsgAMGetUserGameStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetUserGameStatsResponse) ProtoMessage()    {}
func (*CMsgAMGetUserGameStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{12}
}

const Default_CMsgAMGetUserGameStatsResponse_Eresult int32 = 2

func (m *CMsgAMGetUserGameStatsResponse) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse) GetGameId() uint64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMGetUserGameStatsResponse_Eresult
}

func (m *CMsgAMGetUserGameStatsResponse) GetStats() []*CMsgAMGetUserGameStatsResponse_Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *CMsgAMGetUserGameStatsResponse) GetAchievementBlocks() []*CMsgAMGetUserGameStatsResponse_Achievement_Blocks {
	if m != nil {
		return m.AchievementBlocks
	}
	return nil
}

type CMsgAMGetUserGameStatsResponse_Stats struct {
	StatId    uint32 `protobuf:"varint,1,opt,name=stat_id,json=statId" json:"stat_id"`
	StatValue uint32 `protobuf:"varint,2,opt,name=stat_value,json=statValue" json:"stat_value"`
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) Reset()         { *m = CMsgAMGetUserGameStatsResponse_Stats{} }
func (m *CMsgAMGetUserGameStatsResponse_Stats) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGetUserGameStatsResponse_Stats) ProtoMessage()    {}
func (*CMsgAMGetUserGameStatsResponse_Stats) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{12, 0}
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) GetStatId() uint32 {
	if m != nil {
		return m.StatId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) GetStatValue() uint32 {
	if m != nil {
		return m.StatValue
	}
	return 0
}

type CMsgAMGetUserGameStatsResponse_Achievement_Blocks struct {
	AchievementId    uint32 `protobuf:"varint,1,opt,name=achievement_id,json=achievementId" json:"achievement_id"`
	AchievementBitId uint32 `protobuf:"varint,2,opt,name=achievement_bit_id,json=achievementBitId" json:"achievement_bit_id"`
	UnlockTime       uint32 `protobuf:"fixed32,3,opt,name=unlock_time,json=unlockTime" json:"unlock_time"`
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Reset() {
	*m = CMsgAMGetUserGameStatsResponse_Achievement_Blocks{}
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgAMGetUserGameStatsResponse_Achievement_Blocks) ProtoMessage() {}
func (*CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{12, 1}
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) GetAchievementId() uint32 {
	if m != nil {
		return m.AchievementId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) GetAchievementBitId() uint32 {
	if m != nil {
		return m.AchievementBitId
	}
	return 0
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) GetUnlockTime() uint32 {
	if m != nil {
		return m.UnlockTime
	}
	return 0
}

type CMsgGCGetCommandList struct {
	AppId         uint32 `protobuf:"varint,1,opt,name=app_id,json=appId" json:"app_id"`
	CommandPrefix string `protobuf:"bytes,2,opt,name=command_prefix,json=commandPrefix" json:"command_prefix"`
}

func (m *CMsgGCGetCommandList) Reset()         { *m = CMsgGCGetCommandList{} }
func (m *CMsgGCGetCommandList) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetCommandList) ProtoMessage()    {}
func (*CMsgGCGetCommandList) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{13}
}

func (m *CMsgGCGetCommandList) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCGetCommandList) GetCommandPrefix() string {
	if m != nil {
		return m.CommandPrefix
	}
	return ""
}

type CMsgGCGetCommandListResponse struct {
	CommandName []string `protobuf:"bytes,1,rep,name=command_name,json=commandName" json:"command_name,omitempty"`
}

func (m *CMsgGCGetCommandListResponse) Reset()         { *m = CMsgGCGetCommandListResponse{} }
func (m *CMsgGCGetCommandListResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetCommandListResponse) ProtoMessage()    {}
func (*CMsgGCGetCommandListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{14}
}

func (m *CMsgGCGetCommandListResponse) GetCommandName() []string {
	if m != nil {
		return m.CommandName
	}
	return nil
}

type CGCMsgMemCachedGet struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *CGCMsgMemCachedGet) Reset()                    { *m = CGCMsgMemCachedGet{} }
func (m *CGCMsgMemCachedGet) String() string            { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedGet) ProtoMessage()               {}
func (*CGCMsgMemCachedGet) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{15} }

func (m *CGCMsgMemCachedGet) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CGCMsgMemCachedGetResponse struct {
	Values []*CGCMsgMemCachedGetResponse_ValueTag `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *CGCMsgMemCachedGetResponse) Reset()         { *m = CGCMsgMemCachedGetResponse{} }
func (m *CGCMsgMemCachedGetResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedGetResponse) ProtoMessage()    {}
func (*CGCMsgMemCachedGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{16}
}

func (m *CGCMsgMemCachedGetResponse) GetValues() []*CGCMsgMemCachedGetResponse_ValueTag {
	if m != nil {
		return m.Values
	}
	return nil
}

type CGCMsgMemCachedGetResponse_ValueTag struct {
	Found bool   `protobuf:"varint,1,opt,name=found" json:"found"`
	Value []byte `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) Reset()         { *m = CGCMsgMemCachedGetResponse_ValueTag{} }
func (m *CGCMsgMemCachedGetResponse_ValueTag) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedGetResponse_ValueTag) ProtoMessage()    {}
func (*CGCMsgMemCachedGetResponse_ValueTag) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{16, 0}
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CGCMsgMemCachedSet struct {
	Keys []*CGCMsgMemCachedSet_KeyPair `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *CGCMsgMemCachedSet) Reset()                    { *m = CGCMsgMemCachedSet{} }
func (m *CGCMsgMemCachedSet) String() string            { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedSet) ProtoMessage()               {}
func (*CGCMsgMemCachedSet) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{17} }

func (m *CGCMsgMemCachedSet) GetKeys() []*CGCMsgMemCachedSet_KeyPair {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CGCMsgMemCachedSet_KeyPair struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value []byte `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CGCMsgMemCachedSet_KeyPair) Reset()         { *m = CGCMsgMemCachedSet_KeyPair{} }
func (m *CGCMsgMemCachedSet_KeyPair) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedSet_KeyPair) ProtoMessage()    {}
func (*CGCMsgMemCachedSet_KeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{17, 0}
}

func (m *CGCMsgMemCachedSet_KeyPair) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CGCMsgMemCachedSet_KeyPair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type CGCMsgMemCachedDelete struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *CGCMsgMemCachedDelete) Reset()         { *m = CGCMsgMemCachedDelete{} }
func (m *CGCMsgMemCachedDelete) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedDelete) ProtoMessage()    {}
func (*CGCMsgMemCachedDelete) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{18}
}

func (m *CGCMsgMemCachedDelete) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type CGCMsgMemCachedStats struct {
}

func (m *CGCMsgMemCachedStats) Reset()         { *m = CGCMsgMemCachedStats{} }
func (m *CGCMsgMemCachedStats) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedStats) ProtoMessage()    {}
func (*CGCMsgMemCachedStats) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{19}
}

type CGCMsgMemCachedStatsResponse struct {
	CurrConnections uint64 `protobuf:"varint,1,opt,name=curr_connections,json=currConnections" json:"curr_connections"`
	CmdGet          uint64 `protobuf:"varint,2,opt,name=cmd_get,json=cmdGet" json:"cmd_get"`
	CmdSet          uint64 `protobuf:"varint,3,opt,name=cmd_set,json=cmdSet" json:"cmd_set"`
	CmdFlush        uint64 `protobuf:"varint,4,opt,name=cmd_flush,json=cmdFlush" json:"cmd_flush"`
	GetHits         uint64 `protobuf:"varint,5,opt,name=get_hits,json=getHits" json:"get_hits"`
	GetMisses       uint64 `protobuf:"varint,6,opt,name=get_misses,json=getMisses" json:"get_misses"`
	DeleteHits      uint64 `protobuf:"varint,7,opt,name=delete_hits,json=deleteHits" json:"delete_hits"`
	DeleteMisses    uint64 `protobuf:"varint,8,opt,name=delete_misses,json=deleteMisses" json:"delete_misses"`
	BytesRead       uint64 `protobuf:"varint,9,opt,name=bytes_read,json=bytesRead" json:"bytes_read"`
	BytesWritten    uint64 `protobuf:"varint,10,opt,name=bytes_written,json=bytesWritten" json:"bytes_written"`
	LimitMaxbytes   uint64 `protobuf:"varint,11,opt,name=limit_maxbytes,json=limitMaxbytes" json:"limit_maxbytes"`
	CurrItems       uint64 `protobuf:"varint,12,opt,name=curr_items,json=currItems" json:"curr_items"`
	Evictions       uint64 `protobuf:"varint,13,opt,name=evictions" json:"evictions"`
	Bytes           uint64 `protobuf:"varint,14,opt,name=bytes" json:"bytes"`
}

func (m *CGCMsgMemCachedStatsResponse) Reset()         { *m = CGCMsgMemCachedStatsResponse{} }
func (m *CGCMsgMemCachedStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgMemCachedStatsResponse) ProtoMessage()    {}
func (*CGCMsgMemCachedStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{20}
}

func (m *CGCMsgMemCachedStatsResponse) GetCurrConnections() uint64 {
	if m != nil {
		return m.CurrConnections
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCmdGet() uint64 {
	if m != nil {
		return m.CmdGet
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCmdSet() uint64 {
	if m != nil {
		return m.CmdSet
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCmdFlush() uint64 {
	if m != nil {
		return m.CmdFlush
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetGetHits() uint64 {
	if m != nil {
		return m.GetHits
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetGetMisses() uint64 {
	if m != nil {
		return m.GetMisses
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetDeleteHits() uint64 {
	if m != nil {
		return m.DeleteHits
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetDeleteMisses() uint64 {
	if m != nil {
		return m.DeleteMisses
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetLimitMaxbytes() uint64 {
	if m != nil {
		return m.LimitMaxbytes
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetCurrItems() uint64 {
	if m != nil {
		return m.CurrItems
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetEvictions() uint64 {
	if m != nil {
		return m.Evictions
	}
	return 0
}

func (m *CGCMsgMemCachedStatsResponse) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type CGCMsgSQLStats struct {
	SchemaCatalog uint32 `protobuf:"varint,1,opt,name=schema_catalog,json=schemaCatalog" json:"schema_catalog"`
}

func (m *CGCMsgSQLStats) Reset()                    { *m = CGCMsgSQLStats{} }
func (m *CGCMsgSQLStats) String() string            { return proto.CompactTextString(m) }
func (*CGCMsgSQLStats) ProtoMessage()               {}
func (*CGCMsgSQLStats) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{21} }

func (m *CGCMsgSQLStats) GetSchemaCatalog() uint32 {
	if m != nil {
		return m.SchemaCatalog
	}
	return 0
}

type CGCMsgSQLStatsResponse struct {
	Threads                       uint32 `protobuf:"varint,1,opt,name=threads" json:"threads"`
	ThreadsConnected              uint32 `protobuf:"varint,2,opt,name=threads_connected,json=threadsConnected" json:"threads_connected"`
	ThreadsActive                 uint32 `protobuf:"varint,3,opt,name=threads_active,json=threadsActive" json:"threads_active"`
	OperationsSubmitted           uint32 `protobuf:"varint,4,opt,name=operations_submitted,json=operationsSubmitted" json:"operations_submitted"`
	PreparedStatementsExecuted    uint32 `protobuf:"varint,5,opt,name=prepared_statements_executed,json=preparedStatementsExecuted" json:"prepared_statements_executed"`
	NonPreparedStatementsExecuted uint32 `protobuf:"varint,6,opt,name=non_prepared_statements_executed,json=nonPreparedStatementsExecuted" json:"non_prepared_statements_executed"`
	DeadlockRetries               uint32 `protobuf:"varint,7,opt,name=deadlock_retries,json=deadlockRetries" json:"deadlock_retries"`
	OperationsTimedOutInQueue     uint32 `protobuf:"varint,8,opt,name=operations_timed_out_in_queue,json=operationsTimedOutInQueue" json:"operations_timed_out_in_queue"`
	Errors                        uint32 `protobuf:"varint,9,opt,name=errors" json:"errors"`
}

func (m *CGCMsgSQLStatsResponse) Reset()         { *m = CGCMsgSQLStatsResponse{} }
func (m *CGCMsgSQLStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgSQLStatsResponse) ProtoMessage()    {}
func (*CGCMsgSQLStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{22}
}

func (m *CGCMsgSQLStatsResponse) GetThreads() uint32 {
	if m != nil {
		return m.Threads
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetThreadsConnected() uint32 {
	if m != nil {
		return m.ThreadsConnected
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetThreadsActive() uint32 {
	if m != nil {
		return m.ThreadsActive
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetOperationsSubmitted() uint32 {
	if m != nil {
		return m.OperationsSubmitted
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetPreparedStatementsExecuted() uint32 {
	if m != nil {
		return m.PreparedStatementsExecuted
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetNonPreparedStatementsExecuted() uint32 {
	if m != nil {
		return m.NonPreparedStatementsExecuted
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetDeadlockRetries() uint32 {
	if m != nil {
		return m.DeadlockRetries
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetOperationsTimedOutInQueue() uint32 {
	if m != nil {
		return m.OperationsTimedOutInQueue
	}
	return 0
}

func (m *CGCMsgSQLStatsResponse) GetErrors() uint32 {
	if m != nil {
		return m.Errors
	}
	return 0
}

type CMsgAMAddFreeLicense struct {
	Steamid          uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	IpPublic         uint32 `protobuf:"varint,2,opt,name=ip_public,json=ipPublic" json:"ip_public"`
	Packageid        uint32 `protobuf:"varint,3,opt,name=packageid" json:"packageid"`
	StoreCountryCode string `protobuf:"bytes,4,opt,name=store_country_code,json=storeCountryCode" json:"store_country_code"`
}

func (m *CMsgAMAddFreeLicense) Reset()         { *m = CMsgAMAddFreeLicense{} }
func (m *CMsgAMAddFreeLicense) String() string { return proto.CompactTextString(m) }
func (*CMsgAMAddFreeLicense) ProtoMessage()    {}
func (*CMsgAMAddFreeLicense) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{23}
}

func (m *CMsgAMAddFreeLicense) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgAMAddFreeLicense) GetIpPublic() uint32 {
	if m != nil {
		return m.IpPublic
	}
	return 0
}

func (m *CMsgAMAddFreeLicense) GetPackageid() uint32 {
	if m != nil {
		return m.Packageid
	}
	return 0
}

func (m *CMsgAMAddFreeLicense) GetStoreCountryCode() string {
	if m != nil {
		return m.StoreCountryCode
	}
	return ""
}

type CMsgAMAddFreeLicenseResponse struct {
	Eresult              *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
	PurchaseResultDetail int32  `protobuf:"varint,2,opt,name=purchase_result_detail,json=purchaseResultDetail" json:"purchase_result_detail"`
	Transid              uint64 `protobuf:"fixed64,3,opt,name=transid" json:"transid"`
}

func (m *CMsgAMAddFreeLicenseResponse) Reset()         { *m = CMsgAMAddFreeLicenseResponse{} }
func (m *CMsgAMAddFreeLicenseResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMAddFreeLicenseResponse) ProtoMessage()    {}
func (*CMsgAMAddFreeLicenseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{24}
}

const Default_CMsgAMAddFreeLicenseResponse_Eresult int32 = 2

func (m *CMsgAMAddFreeLicenseResponse) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMAddFreeLicenseResponse_Eresult
}

func (m *CMsgAMAddFreeLicenseResponse) GetPurchaseResultDetail() int32 {
	if m != nil {
		return m.PurchaseResultDetail
	}
	return 0
}

func (m *CMsgAMAddFreeLicenseResponse) GetTransid() uint64 {
	if m != nil {
		return m.Transid
	}
	return 0
}

type CGCMsgGetIPLocation struct {
	Ips []uint32 `protobuf:"fixed32,1,rep,name=ips" json:"ips,omitempty"`
}

func (m *CGCMsgGetIPLocation) Reset()         { *m = CGCMsgGetIPLocation{} }
func (m *CGCMsgGetIPLocation) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetIPLocation) ProtoMessage()    {}
func (*CGCMsgGetIPLocation) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{25}
}

func (m *CGCMsgGetIPLocation) GetIps() []uint32 {
	if m != nil {
		return m.Ips
	}
	return nil
}

type CIPLocationInfo struct {
	Ip        uint32  `protobuf:"varint,1,opt,name=ip" json:"ip"`
	Latitude  float32 `protobuf:"fixed32,2,opt,name=latitude" json:"latitude"`
	Longitude float32 `protobuf:"fixed32,3,opt,name=longitude" json:"longitude"`
	Country   string  `protobuf:"bytes,4,opt,name=country" json:"country"`
	State     string  `protobuf:"bytes,5,opt,name=state" json:"state"`
	City      string  `protobuf:"bytes,6,opt,name=city" json:"city"`
}

func (m *CIPLocationInfo) Reset()                    { *m = CIPLocationInfo{} }
func (m *CIPLocationInfo) String() string            { return proto.CompactTextString(m) }
func (*CIPLocationInfo) ProtoMessage()               {}
func (*CIPLocationInfo) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{26} }

func (m *CIPLocationInfo) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *CIPLocationInfo) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *CIPLocationInfo) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *CIPLocationInfo) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *CIPLocationInfo) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *CIPLocationInfo) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

type CGCMsgGetIPLocationResponse struct {
	Infos []*CIPLocationInfo `protobuf:"bytes,1,rep,name=infos" json:"infos,omitempty"`
}

func (m *CGCMsgGetIPLocationResponse) Reset()         { *m = CGCMsgGetIPLocationResponse{} }
func (m *CGCMsgGetIPLocationResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetIPLocationResponse) ProtoMessage()    {}
func (*CGCMsgGetIPLocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{27}
}

func (m *CGCMsgGetIPLocationResponse) GetInfos() []*CIPLocationInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

type CGCMsgSystemStatsSchema struct {
	GcAppId  uint32 `protobuf:"varint,1,opt,name=gc_app_id,json=gcAppId" json:"gc_app_id"`
	SchemaKv []byte `protobuf:"bytes,2,opt,name=schema_kv,json=schemaKv" json:"schema_kv"`
}

func (m *CGCMsgSystemStatsSchema) Reset()         { *m = CGCMsgSystemStatsSchema{} }
func (m *CGCMsgSystemStatsSchema) String() string { return proto.CompactTextString(m) }
func (*CGCMsgSystemStatsSchema) ProtoMessage()    {}
func (*CGCMsgSystemStatsSchema) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{28}
}

func (m *CGCMsgSystemStatsSchema) GetGcAppId() uint32 {
	if m != nil {
		return m.GcAppId
	}
	return 0
}

func (m *CGCMsgSystemStatsSchema) GetSchemaKv() []byte {
	if m != nil {
		return m.SchemaKv
	}
	return nil
}

type CGCMsgGetSystemStats struct {
}

func (m *CGCMsgGetSystemStats) Reset()         { *m = CGCMsgGetSystemStats{} }
func (m *CGCMsgGetSystemStats) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetSystemStats) ProtoMessage()    {}
func (*CGCMsgGetSystemStats) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{29}
}

type CGCMsgGetSystemStatsResponse struct {
	GcAppId            uint32 `protobuf:"varint,1,opt,name=gc_app_id,json=gcAppId" json:"gc_app_id"`
	StatsKv            []byte `protobuf:"bytes,2,opt,name=stats_kv,json=statsKv" json:"stats_kv"`
	ActiveJobs         uint32 `protobuf:"varint,3,opt,name=active_jobs,json=activeJobs" json:"active_jobs"`
	YieldingJobs       uint32 `protobuf:"varint,4,opt,name=yielding_jobs,json=yieldingJobs" json:"yielding_jobs"`
	UserSessions       uint32 `protobuf:"varint,5,opt,name=user_sessions,json=userSessions" json:"user_sessions"`
	GameServerSessions uint32 `protobuf:"varint,6,opt,name=game_server_sessions,json=gameServerSessions" json:"game_server_sessions"`
	Socaches           uint32 `protobuf:"varint,7,opt,name=socaches" json:"socaches"`
	SocachesToUnload   uint32 `protobuf:"varint,8,opt,name=socaches_to_unload,json=socachesToUnload" json:"socaches_to_unload"`
	SocachesLoading    uint32 `protobuf:"varint,9,opt,name=socaches_loading,json=socachesLoading" json:"socaches_loading"`
	WritebackQueue     uint32 `protobuf:"varint,10,opt,name=writeback_queue,json=writebackQueue" json:"writeback_queue"`
	SteamidLocks       uint32 `protobuf:"varint,11,opt,name=steamid_locks,json=steamidLocks" json:"steamid_locks"`
	LogonQueue         uint32 `protobuf:"varint,12,opt,name=logon_queue,json=logonQueue" json:"logon_queue"`
	LogonJobs          uint32 `protobuf:"varint,13,opt,name=logon_jobs,json=logonJobs" json:"logon_jobs"`
}

func (m *CGCMsgGetSystemStatsResponse) Reset()         { *m = CGCMsgGetSystemStatsResponse{} }
func (m *CGCMsgGetSystemStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CGCMsgGetSystemStatsResponse) ProtoMessage()    {}
func (*CGCMsgGetSystemStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{30}
}

func (m *CGCMsgGetSystemStatsResponse) GetGcAppId() uint32 {
	if m != nil {
		return m.GcAppId
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetStatsKv() []byte {
	if m != nil {
		return m.StatsKv
	}
	return nil
}

func (m *CGCMsgGetSystemStatsResponse) GetActiveJobs() uint32 {
	if m != nil {
		return m.ActiveJobs
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetYieldingJobs() uint32 {
	if m != nil {
		return m.YieldingJobs
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetUserSessions() uint32 {
	if m != nil {
		return m.UserSessions
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetGameServerSessions() uint32 {
	if m != nil {
		return m.GameServerSessions
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSocaches() uint32 {
	if m != nil {
		return m.Socaches
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSocachesToUnload() uint32 {
	if m != nil {
		return m.SocachesToUnload
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSocachesLoading() uint32 {
	if m != nil {
		return m.SocachesLoading
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetWritebackQueue() uint32 {
	if m != nil {
		return m.WritebackQueue
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetSteamidLocks() uint32 {
	if m != nil {
		return m.SteamidLocks
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetLogonQueue() uint32 {
	if m != nil {
		return m.LogonQueue
	}
	return 0
}

func (m *CGCMsgGetSystemStatsResponse) GetLogonJobs() uint32 {
	if m != nil {
		return m.LogonJobs
	}
	return 0
}

type CMsgAMSendEmail struct {
	Steamid           uint64                                         `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	EmailMsgType      uint32                                         `protobuf:"varint,2,opt,name=email_msg_type,json=emailMsgType" json:"email_msg_type"`
	EmailFormat       uint32                                         `protobuf:"varint,3,opt,name=email_format,json=emailFormat" json:"email_format"`
	PersonaNameTokens []*CMsgAMSendEmail_PersonaNameReplacementToken `protobuf:"bytes,5,rep,name=persona_name_tokens,json=personaNameTokens" json:"persona_name_tokens,omitempty"`
	SourceGc          uint32                                         `protobuf:"varint,6,opt,name=source_gc,json=sourceGc" json:"source_gc"`
	Tokens            []*CMsgAMSendEmail_ReplacementToken            `protobuf:"bytes,7,rep,name=tokens" json:"tokens,omitempty"`
}

func (m *CMsgAMSendEmail) Reset()                    { *m = CMsgAMSendEmail{} }
func (m *CMsgAMSendEmail) String() string            { return proto.CompactTextString(m) }
func (*CMsgAMSendEmail) ProtoMessage()               {}
func (*CMsgAMSendEmail) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{31} }

func (m *CMsgAMSendEmail) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgAMSendEmail) GetEmailMsgType() uint32 {
	if m != nil {
		return m.EmailMsgType
	}
	return 0
}

func (m *CMsgAMSendEmail) GetEmailFormat() uint32 {
	if m != nil {
		return m.EmailFormat
	}
	return 0
}

func (m *CMsgAMSendEmail) GetPersonaNameTokens() []*CMsgAMSendEmail_PersonaNameReplacementToken {
	if m != nil {
		return m.PersonaNameTokens
	}
	return nil
}

func (m *CMsgAMSendEmail) GetSourceGc() uint32 {
	if m != nil {
		return m.SourceGc
	}
	return 0
}

func (m *CMsgAMSendEmail) GetTokens() []*CMsgAMSendEmail_ReplacementToken {
	if m != nil {
		return m.Tokens
	}
	return nil
}

type CMsgAMSendEmail_ReplacementToken struct {
	TokenName  string `protobuf:"bytes,1,opt,name=token_name,json=tokenName" json:"token_name"`
	TokenValue string `protobuf:"bytes,2,opt,name=token_value,json=tokenValue" json:"token_value"`
}

func (m *CMsgAMSendEmail_ReplacementToken) Reset()         { *m = CMsgAMSendEmail_ReplacementToken{} }
func (m *CMsgAMSendEmail_ReplacementToken) String() string { return proto.CompactTextString(m) }
func (*CMsgAMSendEmail_ReplacementToken) ProtoMessage()    {}
func (*CMsgAMSendEmail_ReplacementToken) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{31, 0}
}

func (m *CMsgAMSendEmail_ReplacementToken) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

func (m *CMsgAMSendEmail_ReplacementToken) GetTokenValue() string {
	if m != nil {
		return m.TokenValue
	}
	return ""
}

type CMsgAMSendEmail_PersonaNameReplacementToken struct {
	Steamid   uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	TokenName string `protobuf:"bytes,2,opt,name=token_name,json=tokenName" json:"token_name"`
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Reset() {
	*m = CMsgAMSendEmail_PersonaNameReplacementToken{}
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgAMSendEmail_PersonaNameReplacementToken) ProtoMessage() {}
func (*CMsgAMSendEmail_PersonaNameReplacementToken) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{31, 1}
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

type CMsgAMSendEmailResponse struct {
	Eresult *uint32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgAMSendEmailResponse) Reset()         { *m = CMsgAMSendEmailResponse{} }
func (m *CMsgAMSendEmailResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgAMSendEmailResponse) ProtoMessage()    {}
func (*CMsgAMSendEmailResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{32}
}

const Default_CMsgAMSendEmailResponse_Eresult uint32 = 2

func (m *CMsgAMSendEmailResponse) GetEresult() uint32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMSendEmailResponse_Eresult
}

type CMsgGCGetEmailTemplate struct {
	AppId        uint32 `protobuf:"varint,1,opt,name=app_id,json=appId" json:"app_id"`
	EmailMsgType uint32 `protobuf:"varint,2,opt,name=email_msg_type,json=emailMsgType" json:"email_msg_type"`
	EmailLang    int32  `protobuf:"varint,3,opt,name=email_lang,json=emailLang" json:"email_lang"`
	EmailFormat  int32  `protobuf:"varint,4,opt,name=email_format,json=emailFormat" json:"email_format"`
}

func (m *CMsgGCGetEmailTemplate) Reset()         { *m = CMsgGCGetEmailTemplate{} }
func (m *CMsgGCGetEmailTemplate) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetEmailTemplate) ProtoMessage()    {}
func (*CMsgGCGetEmailTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{33}
}

func (m *CMsgGCGetEmailTemplate) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCGetEmailTemplate) GetEmailMsgType() uint32 {
	if m != nil {
		return m.EmailMsgType
	}
	return 0
}

func (m *CMsgGCGetEmailTemplate) GetEmailLang() int32 {
	if m != nil {
		return m.EmailLang
	}
	return 0
}

func (m *CMsgGCGetEmailTemplate) GetEmailFormat() int32 {
	if m != nil {
		return m.EmailFormat
	}
	return 0
}

type CMsgGCGetEmailTemplateResponse struct {
	Eresult        *uint32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
	TemplateExists bool    `protobuf:"varint,2,opt,name=template_exists,json=templateExists" json:"template_exists"`
	Template       string  `protobuf:"bytes,3,opt,name=template" json:"template"`
}

func (m *CMsgGCGetEmailTemplateResponse) Reset()         { *m = CMsgGCGetEmailTemplateResponse{} }
func (m *CMsgGCGetEmailTemplateResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetEmailTemplateResponse) ProtoMessage()    {}
func (*CMsgGCGetEmailTemplateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{34}
}

const Default_CMsgGCGetEmailTemplateResponse_Eresult uint32 = 2

func (m *CMsgGCGetEmailTemplateResponse) GetEresult() uint32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCGetEmailTemplateResponse_Eresult
}

func (m *CMsgGCGetEmailTemplateResponse) GetTemplateExists() bool {
	if m != nil {
		return m.TemplateExists
	}
	return false
}

func (m *CMsgGCGetEmailTemplateResponse) GetTemplate() string {
	if m != nil {
		return m.Template
	}
	return ""
}

type CMsgAMGrantGuestPasses2 struct {
	SteamId          uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	PackageId        uint32 `protobuf:"varint,2,opt,name=package_id,json=packageId" json:"package_id"`
	PassesToGrant    int32  `protobuf:"varint,3,opt,name=passes_to_grant,json=passesToGrant" json:"passes_to_grant"`
	DaysToExpiration int32  `protobuf:"varint,4,opt,name=days_to_expiration,json=daysToExpiration" json:"days_to_expiration"`
	Action           int32  `protobuf:"varint,5,opt,name=action" json:"action"`
}

func (m *CMsgAMGrantGuestPasses2) Reset()         { *m = CMsgAMGrantGuestPasses2{} }
func (m *CMsgAMGrantGuestPasses2) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGrantGuestPasses2) ProtoMessage()    {}
func (*CMsgAMGrantGuestPasses2) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{35}
}

func (m *CMsgAMGrantGuestPasses2) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetPackageId() uint32 {
	if m != nil {
		return m.PackageId
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetPassesToGrant() int32 {
	if m != nil {
		return m.PassesToGrant
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetDaysToExpiration() int32 {
	if m != nil {
		return m.DaysToExpiration
	}
	return 0
}

func (m *CMsgAMGrantGuestPasses2) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

type CMsgAMGrantGuestPasses2Response struct {
	Eresult       *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
	PassesGranted *int32 `protobuf:"varint,2,opt,name=passes_granted,json=passesGranted,def=0" json:"passes_granted,omitempty"`
}

func (m *CMsgAMGrantGuestPasses2Response) Reset()         { *m = CMsgAMGrantGuestPasses2Response{} }
func (m *CMsgAMGrantGuestPasses2Response) String() string { return proto.CompactTextString(m) }
func (*CMsgAMGrantGuestPasses2Response) ProtoMessage()    {}
func (*CMsgAMGrantGuestPasses2Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{36}
}

const Default_CMsgAMGrantGuestPasses2Response_Eresult int32 = 2
const Default_CMsgAMGrantGuestPasses2Response_PassesGranted int32 = 0

func (m *CMsgAMGrantGuestPasses2Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgAMGrantGuestPasses2Response_Eresult
}

func (m *CMsgAMGrantGuestPasses2Response) GetPassesGranted() int32 {
	if m != nil && m.PassesGranted != nil {
		return *m.PassesGranted
	}
	return Default_CMsgAMGrantGuestPasses2Response_PassesGranted
}

type CGCSystemMsg_GetAccountDetails struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	Appid   uint32 `protobuf:"varint,2,opt,name=appid" json:"appid"`
}

func (m *CGCSystemMsg_GetAccountDetails) Reset()         { *m = CGCSystemMsg_GetAccountDetails{} }
func (m *CGCSystemMsg_GetAccountDetails) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetAccountDetails) ProtoMessage()    {}
func (*CGCSystemMsg_GetAccountDetails) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{37}
}

func (m *CGCSystemMsg_GetAccountDetails) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

type CGCSystemMsg_GetAccountDetails_Response struct {
	EresultDeprecated      *uint32 `protobuf:"varint,1,opt,name=eresult_deprecated,json=eresultDeprecated,def=2" json:"eresult_deprecated,omitempty"`
	AccountName            string  `protobuf:"bytes,2,opt,name=account_name,json=accountName" json:"account_name"`
	PersonaName            string  `protobuf:"bytes,3,opt,name=persona_name,json=personaName" json:"persona_name"`
	IsProfilePublic        bool    `protobuf:"varint,4,opt,name=is_profile_public,json=isProfilePublic" json:"is_profile_public"`
	IsInventoryPublic      bool    `protobuf:"varint,5,opt,name=is_inventory_public,json=isInventoryPublic" json:"is_inventory_public"`
	IsVacBanned            bool    `protobuf:"varint,7,opt,name=is_vac_banned,json=isVacBanned" json:"is_vac_banned"`
	IsCyberCafe            bool    `protobuf:"varint,8,opt,name=is_cyber_cafe,json=isCyberCafe" json:"is_cyber_cafe"`
	IsSchoolAccount        bool    `protobuf:"varint,9,opt,name=is_school_account,json=isSchoolAccount" json:"is_school_account"`
	IsLimited              bool    `protobuf:"varint,10,opt,name=is_limited,json=isLimited" json:"is_limited"`
	IsSubscribed           bool    `protobuf:"varint,11,opt,name=is_subscribed,json=isSubscribed" json:"is_subscribed"`
	Package                uint32  `protobuf:"varint,12,opt,name=package" json:"package"`
	IsFreeTrialAccount     bool    `protobuf:"varint,13,opt,name=is_free_trial_account,json=isFreeTrialAccount" json:"is_free_trial_account"`
	FreeTrialExpiration    uint32  `protobuf:"varint,14,opt,name=free_trial_expiration,json=freeTrialExpiration" json:"free_trial_expiration"`
	IsLowViolence          bool    `protobuf:"varint,15,opt,name=is_low_violence,json=isLowViolence" json:"is_low_violence"`
	IsAccountLockedDown    bool    `protobuf:"varint,16,opt,name=is_account_locked_down,json=isAccountLockedDown" json:"is_account_locked_down"`
	IsCommunityBanned      bool    `protobuf:"varint,17,opt,name=is_community_banned,json=isCommunityBanned" json:"is_community_banned"`
	IsTradeBanned          bool    `protobuf:"varint,18,opt,name=is_trade_banned,json=isTradeBanned" json:"is_trade_banned"`
	TradeBanExpiration     uint32  `protobuf:"varint,19,opt,name=trade_ban_expiration,json=tradeBanExpiration" json:"trade_ban_expiration"`
	Accountid              uint32  `protobuf:"varint,20,opt,name=accountid" json:"accountid"`
	SuspensionEndTime      uint32  `protobuf:"varint,21,opt,name=suspension_end_time,json=suspensionEndTime" json:"suspension_end_time"`
	Currency               string  `protobuf:"bytes,22,opt,name=currency" json:"currency"`
	SteamLevel             uint32  `protobuf:"varint,23,opt,name=steam_level,json=steamLevel" json:"steam_level"`
	FriendCount            uint32  `protobuf:"varint,24,opt,name=friend_count,json=friendCount" json:"friend_count"`
	AccountCreationTime    uint32  `protobuf:"varint,25,opt,name=account_creation_time,json=accountCreationTime" json:"account_creation_time"`
	IsSteamguardEnabled    bool    `protobuf:"varint,27,opt,name=is_steamguard_enabled,json=isSteamguardEnabled" json:"is_steamguard_enabled"`
	IsPhoneVerified        bool    `protobuf:"varint,28,opt,name=is_phone_verified,json=isPhoneVerified" json:"is_phone_verified"`
	IsTwoFactorAuthEnabled bool    `protobuf:"varint,29,opt,name=is_two_factor_auth_enabled,json=isTwoFactorAuthEnabled" json:"is_two_factor_auth_enabled"`
	TwoFactorEnabledTime   uint32  `protobuf:"varint,30,opt,name=two_factor_enabled_time,json=twoFactorEnabledTime" json:"two_factor_enabled_time"`
	PhoneVerificationTime  uint32  `protobuf:"varint,31,opt,name=phone_verification_time,json=phoneVerificationTime" json:"phone_verification_time"`
	PhoneId                uint64  `protobuf:"varint,33,opt,name=phone_id,json=phoneId" json:"phone_id"`
	IsPhoneIdentifying     bool    `protobuf:"varint,34,opt,name=is_phone_identifying,json=isPhoneIdentifying" json:"is_phone_identifying"`
}

func (m *CGCSystemMsg_GetAccountDetails_Response) Reset() {
	*m = CGCSystemMsg_GetAccountDetails_Response{}
}
func (m *CGCSystemMsg_GetAccountDetails_Response) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetAccountDetails_Response) ProtoMessage()    {}
func (*CGCSystemMsg_GetAccountDetails_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{38}
}

const Default_CGCSystemMsg_GetAccountDetails_Response_EresultDeprecated uint32 = 2

func (m *CGCSystemMsg_GetAccountDetails_Response) GetEresultDeprecated() uint32 {
	if m != nil && m.EresultDeprecated != nil {
		return *m.EresultDeprecated
	}
	return Default_CGCSystemMsg_GetAccountDetails_Response_EresultDeprecated
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPersonaName() string {
	if m != nil {
		return m.PersonaName
	}
	return ""
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsProfilePublic() bool {
	if m != nil {
		return m.IsProfilePublic
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsInventoryPublic() bool {
	if m != nil {
		return m.IsInventoryPublic
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsVacBanned() bool {
	if m != nil {
		return m.IsVacBanned
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsCyberCafe() bool {
	if m != nil {
		return m.IsCyberCafe
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsSchoolAccount() bool {
	if m != nil {
		return m.IsSchoolAccount
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsLimited() bool {
	if m != nil {
		return m.IsLimited
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsSubscribed() bool {
	if m != nil {
		return m.IsSubscribed
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPackage() uint32 {
	if m != nil {
		return m.Package
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsFreeTrialAccount() bool {
	if m != nil {
		return m.IsFreeTrialAccount
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetFreeTrialExpiration() uint32 {
	if m != nil {
		return m.FreeTrialExpiration
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsLowViolence() bool {
	if m != nil {
		return m.IsLowViolence
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsAccountLockedDown() bool {
	if m != nil {
		return m.IsAccountLockedDown
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsCommunityBanned() bool {
	if m != nil {
		return m.IsCommunityBanned
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsTradeBanned() bool {
	if m != nil {
		return m.IsTradeBanned
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetTradeBanExpiration() uint32 {
	if m != nil {
		return m.TradeBanExpiration
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetAccountid() uint32 {
	if m != nil {
		return m.Accountid
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetSuspensionEndTime() uint32 {
	if m != nil {
		return m.SuspensionEndTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetSteamLevel() uint32 {
	if m != nil {
		return m.SteamLevel
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetFriendCount() uint32 {
	if m != nil {
		return m.FriendCount
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetAccountCreationTime() uint32 {
	if m != nil {
		return m.AccountCreationTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsSteamguardEnabled() bool {
	if m != nil {
		return m.IsSteamguardEnabled
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsPhoneVerified() bool {
	if m != nil {
		return m.IsPhoneVerified
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsTwoFactorAuthEnabled() bool {
	if m != nil {
		return m.IsTwoFactorAuthEnabled
	}
	return false
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetTwoFactorEnabledTime() uint32 {
	if m != nil {
		return m.TwoFactorEnabledTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPhoneVerificationTime() uint32 {
	if m != nil {
		return m.PhoneVerificationTime
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetPhoneId() uint64 {
	if m != nil {
		return m.PhoneId
	}
	return 0
}

func (m *CGCSystemMsg_GetAccountDetails_Response) GetIsPhoneIdentifying() bool {
	if m != nil {
		return m.IsPhoneIdentifying
	}
	return false
}

type CMsgGCGetPersonaNames struct {
	Steamids []uint64 `protobuf:"fixed64,1,rep,name=steamids" json:"steamids,omitempty"`
}

func (m *CMsgGCGetPersonaNames) Reset()         { *m = CMsgGCGetPersonaNames{} }
func (m *CMsgGCGetPersonaNames) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPersonaNames) ProtoMessage()    {}
func (*CMsgGCGetPersonaNames) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{39}
}

func (m *CMsgGCGetPersonaNames) GetSteamids() []uint64 {
	if m != nil {
		return m.Steamids
	}
	return nil
}

type CMsgGCGetPersonaNames_Response struct {
	SucceededLookups     []*CMsgGCGetPersonaNames_Response_PersonaName `protobuf:"bytes,1,rep,name=succeeded_lookups,json=succeededLookups" json:"succeeded_lookups,omitempty"`
	FailedLookupSteamids []uint64                                      `protobuf:"fixed64,2,rep,name=failed_lookup_steamids,json=failedLookupSteamids" json:"failed_lookup_steamids,omitempty"`
}

func (m *CMsgGCGetPersonaNames_Response) Reset()         { *m = CMsgGCGetPersonaNames_Response{} }
func (m *CMsgGCGetPersonaNames_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPersonaNames_Response) ProtoMessage()    {}
func (*CMsgGCGetPersonaNames_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{40}
}

func (m *CMsgGCGetPersonaNames_Response) GetSucceededLookups() []*CMsgGCGetPersonaNames_Response_PersonaName {
	if m != nil {
		return m.SucceededLookups
	}
	return nil
}

func (m *CMsgGCGetPersonaNames_Response) GetFailedLookupSteamids() []uint64 {
	if m != nil {
		return m.FailedLookupSteamids
	}
	return nil
}

type CMsgGCGetPersonaNames_Response_PersonaName struct {
	Steamid     uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	PersonaName string `protobuf:"bytes,2,opt,name=persona_name,json=personaName" json:"persona_name"`
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) Reset() {
	*m = CMsgGCGetPersonaNames_Response_PersonaName{}
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgGCGetPersonaNames_Response_PersonaName) ProtoMessage() {}
func (*CMsgGCGetPersonaNames_Response_PersonaName) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{40, 0}
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) GetPersonaName() string {
	if m != nil {
		return m.PersonaName
	}
	return ""
}

type CMsgGCCheckFriendship struct {
	SteamidLeft  uint64 `protobuf:"fixed64,1,opt,name=steamid_left,json=steamidLeft" json:"steamid_left"`
	SteamidRight uint64 `protobuf:"fixed64,2,opt,name=steamid_right,json=steamidRight" json:"steamid_right"`
}

func (m *CMsgGCCheckFriendship) Reset()         { *m = CMsgGCCheckFriendship{} }
func (m *CMsgGCCheckFriendship) String() string { return proto.CompactTextString(m) }
func (*CMsgGCCheckFriendship) ProtoMessage()    {}
func (*CMsgGCCheckFriendship) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{41}
}

func (m *CMsgGCCheckFriendship) GetSteamidLeft() uint64 {
	if m != nil {
		return m.SteamidLeft
	}
	return 0
}

func (m *CMsgGCCheckFriendship) GetSteamidRight() uint64 {
	if m != nil {
		return m.SteamidRight
	}
	return 0
}

type CMsgGCCheckFriendship_Response struct {
	Success         bool `protobuf:"varint,1,opt,name=success" json:"success"`
	FoundFriendship bool `protobuf:"varint,2,opt,name=found_friendship,json=foundFriendship" json:"found_friendship"`
}

func (m *CMsgGCCheckFriendship_Response) Reset()         { *m = CMsgGCCheckFriendship_Response{} }
func (m *CMsgGCCheckFriendship_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCCheckFriendship_Response) ProtoMessage()    {}
func (*CMsgGCCheckFriendship_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{42}
}

func (m *CMsgGCCheckFriendship_Response) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CMsgGCCheckFriendship_Response) GetFoundFriendship() bool {
	if m != nil {
		return m.FoundFriendship
	}
	return false
}

type CMsgGCMsgMasterSetDirectory struct {
	MasterDirIndex uint32                               `protobuf:"varint,1,opt,name=master_dir_index,json=masterDirIndex" json:"master_dir_index"`
	Dir            []*CMsgGCMsgMasterSetDirectory_SubGC `protobuf:"bytes,2,rep,name=dir" json:"dir,omitempty"`
}

func (m *CMsgGCMsgMasterSetDirectory) Reset()         { *m = CMsgGCMsgMasterSetDirectory{} }
func (m *CMsgGCMsgMasterSetDirectory) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetDirectory) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetDirectory) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{43}
}

func (m *CMsgGCMsgMasterSetDirectory) GetMasterDirIndex() uint32 {
	if m != nil {
		return m.MasterDirIndex
	}
	return 0
}

func (m *CMsgGCMsgMasterSetDirectory) GetDir() []*CMsgGCMsgMasterSetDirectory_SubGC {
	if m != nil {
		return m.Dir
	}
	return nil
}

type CMsgGCMsgMasterSetDirectory_SubGC struct {
	DirIndex    uint32 `protobuf:"varint,1,opt,name=dir_index,json=dirIndex" json:"dir_index"`
	Name        string `protobuf:"bytes,2,opt,name=name" json:"name"`
	Box         string `protobuf:"bytes,3,opt,name=box" json:"box"`
	CommandLine string `protobuf:"bytes,4,opt,name=command_line,json=commandLine" json:"command_line"`
	GcBinary    string `protobuf:"bytes,5,opt,name=gc_binary,json=gcBinary" json:"gc_binary"`
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) Reset()         { *m = CMsgGCMsgMasterSetDirectory_SubGC{} }
func (m *CMsgGCMsgMasterSetDirectory_SubGC) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetDirectory_SubGC) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetDirectory_SubGC) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{43, 0}
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetDirIndex() uint32 {
	if m != nil {
		return m.DirIndex
	}
	return 0
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetBox() string {
	if m != nil {
		return m.Box
	}
	return ""
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetCommandLine() string {
	if m != nil {
		return m.CommandLine
	}
	return ""
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) GetGcBinary() string {
	if m != nil {
		return m.GcBinary
	}
	return ""
}

type CMsgGCMsgMasterSetDirectory_Response struct {
	Eresult *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgGCMsgMasterSetDirectory_Response) Reset()         { *m = CMsgGCMsgMasterSetDirectory_Response{} }
func (m *CMsgGCMsgMasterSetDirectory_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetDirectory_Response) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetDirectory_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{44}
}

const Default_CMsgGCMsgMasterSetDirectory_Response_Eresult int32 = 2

func (m *CMsgGCMsgMasterSetDirectory_Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCMsgMasterSetDirectory_Response_Eresult
}

type CMsgGCMsgWebAPIJobRequestForwardResponse struct {
	DirIndex uint32 `protobuf:"varint,1,opt,name=dir_index,json=dirIndex" json:"dir_index"`
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Reset() {
	*m = CMsgGCMsgWebAPIJobRequestForwardResponse{}
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgWebAPIJobRequestForwardResponse) ProtoMessage()    {}
func (*CMsgGCMsgWebAPIJobRequestForwardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{45}
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) GetDirIndex() uint32 {
	if m != nil {
		return m.DirIndex
	}
	return 0
}

type CGCSystemMsg_GetPurchaseTrust_Request struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) Reset()         { *m = CGCSystemMsg_GetPurchaseTrust_Request{} }
func (m *CGCSystemMsg_GetPurchaseTrust_Request) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetPurchaseTrust_Request) ProtoMessage()    {}
func (*CGCSystemMsg_GetPurchaseTrust_Request) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{46}
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

type CGCSystemMsg_GetPurchaseTrust_Response struct {
	HasPriorPurchaseHistory   bool   `protobuf:"varint,1,opt,name=has_prior_purchase_history,json=hasPriorPurchaseHistory" json:"has_prior_purchase_history"`
	HasNoRecentPasswordResets bool   `protobuf:"varint,2,opt,name=has_no_recent_password_resets,json=hasNoRecentPasswordResets" json:"has_no_recent_password_resets"`
	IsWalletCashTrusted       bool   `protobuf:"varint,3,opt,name=is_wallet_cash_trusted,json=isWalletCashTrusted" json:"is_wallet_cash_trusted"`
	TimeAllTrusted            uint32 `protobuf:"varint,4,opt,name=time_all_trusted,json=timeAllTrusted" json:"time_all_trusted"`
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) Reset() {
	*m = CGCSystemMsg_GetPurchaseTrust_Response{}
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) String() string { return proto.CompactTextString(m) }
func (*CGCSystemMsg_GetPurchaseTrust_Response) ProtoMessage()    {}
func (*CGCSystemMsg_GetPurchaseTrust_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{47}
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetHasPriorPurchaseHistory() bool {
	if m != nil {
		return m.HasPriorPurchaseHistory
	}
	return false
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetHasNoRecentPasswordResets() bool {
	if m != nil {
		return m.HasNoRecentPasswordResets
	}
	return false
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetIsWalletCashTrusted() bool {
	if m != nil {
		return m.IsWalletCashTrusted
	}
	return false
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) GetTimeAllTrusted() uint32 {
	if m != nil {
		return m.TimeAllTrusted
	}
	return 0
}

type CMsgGCHAccountVacStatusChange struct {
	SteamId           uint64 `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	AppId             uint32 `protobuf:"varint,2,opt,name=app_id,json=appId" json:"app_id"`
	RtimeVacbanStarts uint32 `protobuf:"varint,3,opt,name=rtime_vacban_starts,json=rtimeVacbanStarts" json:"rtime_vacban_starts"`
	IsBannedNow       bool   `protobuf:"varint,4,opt,name=is_banned_now,json=isBannedNow" json:"is_banned_now"`
	IsBannedFuture    bool   `protobuf:"varint,5,opt,name=is_banned_future,json=isBannedFuture" json:"is_banned_future"`
}

func (m *CMsgGCHAccountVacStatusChange) Reset()         { *m = CMsgGCHAccountVacStatusChange{} }
func (m *CMsgGCHAccountVacStatusChange) String() string { return proto.CompactTextString(m) }
func (*CMsgGCHAccountVacStatusChange) ProtoMessage()    {}
func (*CMsgGCHAccountVacStatusChange) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{48}
}

func (m *CMsgGCHAccountVacStatusChange) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgGCHAccountVacStatusChange) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCHAccountVacStatusChange) GetRtimeVacbanStarts() uint32 {
	if m != nil {
		return m.RtimeVacbanStarts
	}
	return 0
}

func (m *CMsgGCHAccountVacStatusChange) GetIsBannedNow() bool {
	if m != nil {
		return m.IsBannedNow
	}
	return false
}

func (m *CMsgGCHAccountVacStatusChange) GetIsBannedFuture() bool {
	if m != nil {
		return m.IsBannedFuture
	}
	return false
}

type CMsgGCGetPartnerAccountLink struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
}

func (m *CMsgGCGetPartnerAccountLink) Reset()         { *m = CMsgGCGetPartnerAccountLink{} }
func (m *CMsgGCGetPartnerAccountLink) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPartnerAccountLink) ProtoMessage()    {}
func (*CMsgGCGetPartnerAccountLink) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{49}
}

func (m *CMsgGCGetPartnerAccountLink) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

type CMsgGCGetPartnerAccountLink_Response struct {
	Pwid    uint32 `protobuf:"varint,1,opt,name=pwid" json:"pwid"`
	Nexonid uint32 `protobuf:"varint,2,opt,name=nexonid" json:"nexonid"`
}

func (m *CMsgGCGetPartnerAccountLink_Response) Reset()         { *m = CMsgGCGetPartnerAccountLink_Response{} }
func (m *CMsgGCGetPartnerAccountLink_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCGetPartnerAccountLink_Response) ProtoMessage()    {}
func (*CMsgGCGetPartnerAccountLink_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{50}
}

func (m *CMsgGCGetPartnerAccountLink_Response) GetPwid() uint32 {
	if m != nil {
		return m.Pwid
	}
	return 0
}

func (m *CMsgGCGetPartnerAccountLink_Response) GetNexonid() uint32 {
	if m != nil {
		return m.Nexonid
	}
	return 0
}

type CMsgGCRoutingInfo struct {
	DirIndex      []uint32                         `protobuf:"varint,1,rep,name=dir_index,json=dirIndex" json:"dir_index,omitempty"`
	Method        *CMsgGCRoutingInfo_RoutingMethod `protobuf:"varint,2,opt,name=method,enum=CMsgGCRoutingInfo_RoutingMethod,def=0" json:"method,omitempty"`
	Fallback      *CMsgGCRoutingInfo_RoutingMethod `protobuf:"varint,3,opt,name=fallback,enum=CMsgGCRoutingInfo_RoutingMethod,def=1" json:"fallback,omitempty"`
	ProtobufField uint32                           `protobuf:"varint,4,opt,name=protobuf_field,json=protobufField" json:"protobuf_field"`
	WebapiParam   string                           `protobuf:"bytes,5,opt,name=webapi_param,json=webapiParam" json:"webapi_param"`
}

func (m *CMsgGCRoutingInfo) Reset()                    { *m = CMsgGCRoutingInfo{} }
func (m *CMsgGCRoutingInfo) String() string            { return proto.CompactTextString(m) }
func (*CMsgGCRoutingInfo) ProtoMessage()               {}
func (*CMsgGCRoutingInfo) Descriptor() ([]byte, []int) { return fileDescriptorSteammessages, []int{51} }

const Default_CMsgGCRoutingInfo_Method CMsgGCRoutingInfo_RoutingMethod = CMsgGCRoutingInfo_RANDOM
const Default_CMsgGCRoutingInfo_Fallback CMsgGCRoutingInfo_RoutingMethod = CMsgGCRoutingInfo_DISCARD

func (m *CMsgGCRoutingInfo) GetDirIndex() []uint32 {
	if m != nil {
		return m.DirIndex
	}
	return nil
}

func (m *CMsgGCRoutingInfo) GetMethod() CMsgGCRoutingInfo_RoutingMethod {
	if m != nil && m.Method != nil {
		return *m.Method
	}
	return Default_CMsgGCRoutingInfo_Method
}

func (m *CMsgGCRoutingInfo) GetFallback() CMsgGCRoutingInfo_RoutingMethod {
	if m != nil && m.Fallback != nil {
		return *m.Fallback
	}
	return Default_CMsgGCRoutingInfo_Fallback
}

func (m *CMsgGCRoutingInfo) GetProtobufField() uint32 {
	if m != nil {
		return m.ProtobufField
	}
	return 0
}

func (m *CMsgGCRoutingInfo) GetWebapiParam() string {
	if m != nil {
		return m.WebapiParam
	}
	return ""
}

type CMsgGCMsgMasterSetWebAPIRouting struct {
	Entries []*CMsgGCMsgMasterSetWebAPIRouting_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) Reset()         { *m = CMsgGCMsgMasterSetWebAPIRouting{} }
func (m *CMsgGCMsgMasterSetWebAPIRouting) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetWebAPIRouting) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetWebAPIRouting) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{52}
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) GetEntries() []*CMsgGCMsgMasterSetWebAPIRouting_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type CMsgGCMsgMasterSetWebAPIRouting_Entry struct {
	InterfaceName string             `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName" json:"interface_name"`
	MethodName    string             `protobuf:"bytes,2,opt,name=method_name,json=methodName" json:"method_name"`
	Routing       *CMsgGCRoutingInfo `protobuf:"bytes,3,opt,name=routing" json:"routing,omitempty"`
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Reset()         { *m = CMsgGCMsgMasterSetWebAPIRouting_Entry{} }
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetWebAPIRouting_Entry) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetWebAPIRouting_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{52, 0}
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) GetRouting() *CMsgGCRoutingInfo {
	if m != nil {
		return m.Routing
	}
	return nil
}

type CMsgGCMsgMasterSetClientMsgRouting struct {
	Entries []*CMsgGCMsgMasterSetClientMsgRouting_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) Reset()         { *m = CMsgGCMsgMasterSetClientMsgRouting{} }
func (m *CMsgGCMsgMasterSetClientMsgRouting) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetClientMsgRouting) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetClientMsgRouting) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{53}
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) GetEntries() []*CMsgGCMsgMasterSetClientMsgRouting_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type CMsgGCMsgMasterSetClientMsgRouting_Entry struct {
	MsgType uint32             `protobuf:"varint,1,opt,name=msg_type,json=msgType" json:"msg_type"`
	Routing *CMsgGCRoutingInfo `protobuf:"bytes,2,opt,name=routing" json:"routing,omitempty"`
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Reset() {
	*m = CMsgGCMsgMasterSetClientMsgRouting_Entry{}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetClientMsgRouting_Entry) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetClientMsgRouting_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{53, 0}
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) GetMsgType() uint32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) GetRouting() *CMsgGCRoutingInfo {
	if m != nil {
		return m.Routing
	}
	return nil
}

type CMsgGCMsgMasterSetWebAPIRouting_Response struct {
	Eresult *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Reset() {
	*m = CMsgGCMsgMasterSetWebAPIRouting_Response{}
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgMasterSetWebAPIRouting_Response) ProtoMessage()    {}
func (*CMsgGCMsgMasterSetWebAPIRouting_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{54}
}

const Default_CMsgGCMsgMasterSetWebAPIRouting_Response_Eresult int32 = 2

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCMsgMasterSetWebAPIRouting_Response_Eresult
}

type CMsgGCMsgMasterSetClientMsgRouting_Response struct {
	Eresult *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Reset() {
	*m = CMsgGCMsgMasterSetClientMsgRouting_Response{}
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgGCMsgMasterSetClientMsgRouting_Response) ProtoMessage() {}
func (*CMsgGCMsgMasterSetClientMsgRouting_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{55}
}

const Default_CMsgGCMsgMasterSetClientMsgRouting_Response_Eresult int32 = 2

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CMsgGCMsgMasterSetClientMsgRouting_Response_Eresult
}

type CMsgGCMsgSetOptions struct {
	Options         []CMsgGCMsgSetOptions_Option        `protobuf:"varint,1,rep,name=options,enum=CMsgGCMsgSetOptions_Option" json:"options,omitempty"`
	ClientMsgRanges []*CMsgGCMsgSetOptions_MessageRange `protobuf:"bytes,2,rep,name=client_msg_ranges,json=clientMsgRanges" json:"client_msg_ranges,omitempty"`
}

func (m *CMsgGCMsgSetOptions) Reset()         { *m = CMsgGCMsgSetOptions{} }
func (m *CMsgGCMsgSetOptions) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgSetOptions) ProtoMessage()    {}
func (*CMsgGCMsgSetOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{56}
}

func (m *CMsgGCMsgSetOptions) GetOptions() []CMsgGCMsgSetOptions_Option {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *CMsgGCMsgSetOptions) GetClientMsgRanges() []*CMsgGCMsgSetOptions_MessageRange {
	if m != nil {
		return m.ClientMsgRanges
	}
	return nil
}

type CMsgGCMsgSetOptions_MessageRange struct {
	Low  uint32 `protobuf:"varint,1,req,name=low" json:"low"`
	High uint32 `protobuf:"varint,2,req,name=high" json:"high"`
}

func (m *CMsgGCMsgSetOptions_MessageRange) Reset()         { *m = CMsgGCMsgSetOptions_MessageRange{} }
func (m *CMsgGCMsgSetOptions_MessageRange) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMsgSetOptions_MessageRange) ProtoMessage()    {}
func (*CMsgGCMsgSetOptions_MessageRange) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{56, 0}
}

func (m *CMsgGCMsgSetOptions_MessageRange) GetLow() uint32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *CMsgGCMsgSetOptions_MessageRange) GetHigh() uint32 {
	if m != nil {
		return m.High
	}
	return 0
}

type CMsgGCHUpdateSession struct {
	SteamId       uint64                             `protobuf:"fixed64,1,opt,name=steam_id,json=steamId" json:"steam_id"`
	AppId         uint32                             `protobuf:"varint,2,opt,name=app_id,json=appId" json:"app_id"`
	Online        bool                               `protobuf:"varint,3,opt,name=online" json:"online"`
	ServerSteamId uint64                             `protobuf:"fixed64,4,opt,name=server_steam_id,json=serverSteamId" json:"server_steam_id"`
	ServerAddr    uint32                             `protobuf:"varint,5,opt,name=server_addr,json=serverAddr" json:"server_addr"`
	ServerPort    uint32                             `protobuf:"varint,6,opt,name=server_port,json=serverPort" json:"server_port"`
	OsType        uint32                             `protobuf:"varint,7,opt,name=os_type,json=osType" json:"os_type"`
	ClientAddr    uint32                             `protobuf:"varint,8,opt,name=client_addr,json=clientAddr" json:"client_addr"`
	ExtraFields   []*CMsgGCHUpdateSession_ExtraField `protobuf:"bytes,9,rep,name=extra_fields,json=extraFields" json:"extra_fields,omitempty"`
}

func (m *CMsgGCHUpdateSession) Reset()         { *m = CMsgGCHUpdateSession{} }
func (m *CMsgGCHUpdateSession) String() string { return proto.CompactTextString(m) }
func (*CMsgGCHUpdateSession) ProtoMessage()    {}
func (*CMsgGCHUpdateSession) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{57}
}

func (m *CMsgGCHUpdateSession) GetSteamId() uint64 {
	if m != nil {
		return m.SteamId
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *CMsgGCHUpdateSession) GetServerSteamId() uint64 {
	if m != nil {
		return m.ServerSteamId
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetServerAddr() uint32 {
	if m != nil {
		return m.ServerAddr
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetOsType() uint32 {
	if m != nil {
		return m.OsType
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetClientAddr() uint32 {
	if m != nil {
		return m.ClientAddr
	}
	return 0
}

func (m *CMsgGCHUpdateSession) GetExtraFields() []*CMsgGCHUpdateSession_ExtraField {
	if m != nil {
		return m.ExtraFields
	}
	return nil
}

type CMsgGCHUpdateSession_ExtraField struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *CMsgGCHUpdateSession_ExtraField) Reset()         { *m = CMsgGCHUpdateSession_ExtraField{} }
func (m *CMsgGCHUpdateSession_ExtraField) String() string { return proto.CompactTextString(m) }
func (*CMsgGCHUpdateSession_ExtraField) ProtoMessage()    {}
func (*CMsgGCHUpdateSession_ExtraField) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{57, 0}
}

func (m *CMsgGCHUpdateSession_ExtraField) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CMsgGCHUpdateSession_ExtraField) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type CMsgNotificationOfSuspiciousActivity struct {
	Steamid           uint64                                                      `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	Appid             uint32                                                      `protobuf:"varint,2,opt,name=appid" json:"appid"`
	MultipleInstances *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances `protobuf:"bytes,3,opt,name=multiple_instances,json=multipleInstances" json:"multiple_instances,omitempty"`
}

func (m *CMsgNotificationOfSuspiciousActivity) Reset()         { *m = CMsgNotificationOfSuspiciousActivity{} }
func (m *CMsgNotificationOfSuspiciousActivity) String() string { return proto.CompactTextString(m) }
func (*CMsgNotificationOfSuspiciousActivity) ProtoMessage()    {}
func (*CMsgNotificationOfSuspiciousActivity) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{58}
}

func (m *CMsgNotificationOfSuspiciousActivity) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgNotificationOfSuspiciousActivity) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CMsgNotificationOfSuspiciousActivity) GetMultipleInstances() *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
	if m != nil {
		return m.MultipleInstances
	}
	return nil
}

type CMsgNotificationOfSuspiciousActivity_MultipleGameInstances struct {
	AppInstanceCount uint32   `protobuf:"varint,1,opt,name=app_instance_count,json=appInstanceCount" json:"app_instance_count"`
	OtherSteamids    []uint64 `protobuf:"fixed64,2,rep,name=other_steamids,json=otherSteamids" json:"other_steamids,omitempty"`
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Reset() {
	*m = CMsgNotificationOfSuspiciousActivity_MultipleGameInstances{}
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) String() string {
	return proto.CompactTextString(m)
}
func (*CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) ProtoMessage() {}
func (*CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Descriptor() ([]byte, []int) {
	return fileDescriptorSteammessages, []int{58, 0}
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) GetAppInstanceCount() uint32 {
	if m != nil {
		return m.AppInstanceCount
	}
	return 0
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) GetOtherSteamids() []uint64 {
	if m != nil {
		return m.OtherSteamids
	}
	return nil
}

var E_KeyField = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         60000,
	Name:          "key_field",
	Tag:           "varint,60000,opt,name=key_field,json=keyField,def=0",
	Filename:      "steammessages.proto",
}

var E_MsgpoolSoftLimit = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*int32)(nil),
	Field:         60000,
	Name:          "msgpool_soft_limit",
	Tag:           "varint,60000,opt,name=msgpool_soft_limit,json=msgpoolSoftLimit,def=32",
	Filename:      "steammessages.proto",
}

var E_MsgpoolHardLimit = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf.MessageOptions)(nil),
	ExtensionType: (*int32)(nil),
	Field:         60001,
	Name:          "msgpool_hard_limit",
	Tag:           "varint,60001,opt,name=msgpool_hard_limit,json=msgpoolHardLimit,def=384",
	Filename:      "steammessages.proto",
}

func init() {
	proto.RegisterType((*CMsgProtoBufHeader)(nil), "CMsgProtoBufHeader")
	proto.RegisterType((*CMsgWebAPIKey)(nil), "CMsgWebAPIKey")
	proto.RegisterType((*CMsgHttpRequest)(nil), "CMsgHttpRequest")
	proto.RegisterType((*CMsgHttpRequest_RequestHeader)(nil), "CMsgHttpRequest.RequestHeader")
	proto.RegisterType((*CMsgHttpRequest_QueryParam)(nil), "CMsgHttpRequest.QueryParam")
	proto.RegisterType((*CMsgWebAPIRequest)(nil), "CMsgWebAPIRequest")
	proto.RegisterType((*CMsgHttpResponse)(nil), "CMsgHttpResponse")
	proto.RegisterType((*CMsgHttpResponse_ResponseHeader)(nil), "CMsgHttpResponse.ResponseHeader")
	proto.RegisterType((*CMsgAMFindAccounts)(nil), "CMsgAMFindAccounts")
	proto.RegisterType((*CMsgAMFindAccountsResponse)(nil), "CMsgAMFindAccountsResponse")
	proto.RegisterType((*CMsgNotifyWatchdog)(nil), "CMsgNotifyWatchdog")
	proto.RegisterType((*CMsgAMGetLicenses)(nil), "CMsgAMGetLicenses")
	proto.RegisterType((*CMsgPackageLicense)(nil), "CMsgPackageLicense")
	proto.RegisterType((*CMsgAMGetLicensesResponse)(nil), "CMsgAMGetLicensesResponse")
	proto.RegisterType((*CMsgAMGetUserGameStats)(nil), "CMsgAMGetUserGameStats")
	proto.RegisterType((*CMsgAMGetUserGameStatsResponse)(nil), "CMsgAMGetUserGameStatsResponse")
	proto.RegisterType((*CMsgAMGetUserGameStatsResponse_Stats)(nil), "CMsgAMGetUserGameStatsResponse.Stats")
	proto.RegisterType((*CMsgAMGetUserGameStatsResponse_Achievement_Blocks)(nil), "CMsgAMGetUserGameStatsResponse.Achievement_Blocks")
	proto.RegisterType((*CMsgGCGetCommandList)(nil), "CMsgGCGetCommandList")
	proto.RegisterType((*CMsgGCGetCommandListResponse)(nil), "CMsgGCGetCommandListResponse")
	proto.RegisterType((*CGCMsgMemCachedGet)(nil), "CGCMsgMemCachedGet")
	proto.RegisterType((*CGCMsgMemCachedGetResponse)(nil), "CGCMsgMemCachedGetResponse")
	proto.RegisterType((*CGCMsgMemCachedGetResponse_ValueTag)(nil), "CGCMsgMemCachedGetResponse.ValueTag")
	proto.RegisterType((*CGCMsgMemCachedSet)(nil), "CGCMsgMemCachedSet")
	proto.RegisterType((*CGCMsgMemCachedSet_KeyPair)(nil), "CGCMsgMemCachedSet.KeyPair")
	proto.RegisterType((*CGCMsgMemCachedDelete)(nil), "CGCMsgMemCachedDelete")
	proto.RegisterType((*CGCMsgMemCachedStats)(nil), "CGCMsgMemCachedStats")
	proto.RegisterType((*CGCMsgMemCachedStatsResponse)(nil), "CGCMsgMemCachedStatsResponse")
	proto.RegisterType((*CGCMsgSQLStats)(nil), "CGCMsgSQLStats")
	proto.RegisterType((*CGCMsgSQLStatsResponse)(nil), "CGCMsgSQLStatsResponse")
	proto.RegisterType((*CMsgAMAddFreeLicense)(nil), "CMsgAMAddFreeLicense")
	proto.RegisterType((*CMsgAMAddFreeLicenseResponse)(nil), "CMsgAMAddFreeLicenseResponse")
	proto.RegisterType((*CGCMsgGetIPLocation)(nil), "CGCMsgGetIPLocation")
	proto.RegisterType((*CIPLocationInfo)(nil), "CIPLocationInfo")
	proto.RegisterType((*CGCMsgGetIPLocationResponse)(nil), "CGCMsgGetIPLocationResponse")
	proto.RegisterType((*CGCMsgSystemStatsSchema)(nil), "CGCMsgSystemStatsSchema")
	proto.RegisterType((*CGCMsgGetSystemStats)(nil), "CGCMsgGetSystemStats")
	proto.RegisterType((*CGCMsgGetSystemStatsResponse)(nil), "CGCMsgGetSystemStatsResponse")
	proto.RegisterType((*CMsgAMSendEmail)(nil), "CMsgAMSendEmail")
	proto.RegisterType((*CMsgAMSendEmail_ReplacementToken)(nil), "CMsgAMSendEmail.ReplacementToken")
	proto.RegisterType((*CMsgAMSendEmail_PersonaNameReplacementToken)(nil), "CMsgAMSendEmail.PersonaNameReplacementToken")
	proto.RegisterType((*CMsgAMSendEmailResponse)(nil), "CMsgAMSendEmailResponse")
	proto.RegisterType((*CMsgGCGetEmailTemplate)(nil), "CMsgGCGetEmailTemplate")
	proto.RegisterType((*CMsgGCGetEmailTemplateResponse)(nil), "CMsgGCGetEmailTemplateResponse")
	proto.RegisterType((*CMsgAMGrantGuestPasses2)(nil), "CMsgAMGrantGuestPasses2")
	proto.RegisterType((*CMsgAMGrantGuestPasses2Response)(nil), "CMsgAMGrantGuestPasses2Response")
	proto.RegisterType((*CGCSystemMsg_GetAccountDetails)(nil), "CGCSystemMsg_GetAccountDetails")
	proto.RegisterType((*CGCSystemMsg_GetAccountDetails_Response)(nil), "CGCSystemMsg_GetAccountDetails_Response")
	proto.RegisterType((*CMsgGCGetPersonaNames)(nil), "CMsgGCGetPersonaNames")
	proto.RegisterType((*CMsgGCGetPersonaNames_Response)(nil), "CMsgGCGetPersonaNames_Response")
	proto.RegisterType((*CMsgGCGetPersonaNames_Response_PersonaName)(nil), "CMsgGCGetPersonaNames_Response.PersonaName")
	proto.RegisterType((*CMsgGCCheckFriendship)(nil), "CMsgGCCheckFriendship")
	proto.RegisterType((*CMsgGCCheckFriendship_Response)(nil), "CMsgGCCheckFriendship_Response")
	proto.RegisterType((*CMsgGCMsgMasterSetDirectory)(nil), "CMsgGCMsgMasterSetDirectory")
	proto.RegisterType((*CMsgGCMsgMasterSetDirectory_SubGC)(nil), "CMsgGCMsgMasterSetDirectory.SubGC")
	proto.RegisterType((*CMsgGCMsgMasterSetDirectory_Response)(nil), "CMsgGCMsgMasterSetDirectory_Response")
	proto.RegisterType((*CMsgGCMsgWebAPIJobRequestForwardResponse)(nil), "CMsgGCMsgWebAPIJobRequestForwardResponse")
	proto.RegisterType((*CGCSystemMsg_GetPurchaseTrust_Request)(nil), "CGCSystemMsg_GetPurchaseTrust_Request")
	proto.RegisterType((*CGCSystemMsg_GetPurchaseTrust_Response)(nil), "CGCSystemMsg_GetPurchaseTrust_Response")
	proto.RegisterType((*CMsgGCHAccountVacStatusChange)(nil), "CMsgGCHAccountVacStatusChange")
	proto.RegisterType((*CMsgGCGetPartnerAccountLink)(nil), "CMsgGCGetPartnerAccountLink")
	proto.RegisterType((*CMsgGCGetPartnerAccountLink_Response)(nil), "CMsgGCGetPartnerAccountLink_Response")
	proto.RegisterType((*CMsgGCRoutingInfo)(nil), "CMsgGCRoutingInfo")
	proto.RegisterType((*CMsgGCMsgMasterSetWebAPIRouting)(nil), "CMsgGCMsgMasterSetWebAPIRouting")
	proto.RegisterType((*CMsgGCMsgMasterSetWebAPIRouting_Entry)(nil), "CMsgGCMsgMasterSetWebAPIRouting.Entry")
	proto.RegisterType((*CMsgGCMsgMasterSetClientMsgRouting)(nil), "CMsgGCMsgMasterSetClientMsgRouting")
	proto.RegisterType((*CMsgGCMsgMasterSetClientMsgRouting_Entry)(nil), "CMsgGCMsgMasterSetClientMsgRouting.Entry")
	proto.RegisterType((*CMsgGCMsgMasterSetWebAPIRouting_Response)(nil), "CMsgGCMsgMasterSetWebAPIRouting_Response")
	proto.RegisterType((*CMsgGCMsgMasterSetClientMsgRouting_Response)(nil), "CMsgGCMsgMasterSetClientMsgRouting_Response")
	proto.RegisterType((*CMsgGCMsgSetOptions)(nil), "CMsgGCMsgSetOptions")
	proto.RegisterType((*CMsgGCMsgSetOptions_MessageRange)(nil), "CMsgGCMsgSetOptions.MessageRange")
	proto.RegisterType((*CMsgGCHUpdateSession)(nil), "CMsgGCHUpdateSession")
	proto.RegisterType((*CMsgGCHUpdateSession_ExtraField)(nil), "CMsgGCHUpdateSession.ExtraField")
	proto.RegisterType((*CMsgNotificationOfSuspiciousActivity)(nil), "CMsgNotificationOfSuspiciousActivity")
	proto.RegisterType((*CMsgNotificationOfSuspiciousActivity_MultipleGameInstances)(nil), "CMsgNotificationOfSuspiciousActivity.MultipleGameInstances")
	proto.RegisterEnum("GCProtoBufMsgSrc", GCProtoBufMsgSrc_name, GCProtoBufMsgSrc_value)
	proto.RegisterEnum("CMsgGCRoutingInfo_RoutingMethod", CMsgGCRoutingInfo_RoutingMethod_name, CMsgGCRoutingInfo_RoutingMethod_value)
	proto.RegisterEnum("CMsgGCMsgSetOptions_Option", CMsgGCMsgSetOptions_Option_name, CMsgGCMsgSetOptions_Option_value)
	proto.RegisterExtension(E_KeyField)
	proto.RegisterExtension(E_MsgpoolSoftLimit)
	proto.RegisterExtension(E_MsgpoolHardLimit)
}
func (m *CMsgProtoBufHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgProtoBufHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.ClientSteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ClientSessionId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SourceAppId))
	if m.JobIdSource != nil {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Steammessages(dAtA, i, uint64(*m.JobIdSource))
	}
	if m.JobIdTarget != nil {
		dAtA[i] = 0x59
		i++
		i = encodeFixed64Steammessages(dAtA, i, uint64(*m.JobIdTarget))
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TargetJobName)))
	i += copy(dAtA[i:], m.TargetJobName)
	if m.Eresult != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.ErrorMessage)))
	i += copy(dAtA[i:], m.ErrorMessage)
	if m.GcMsgSrc != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.GcMsgSrc))
	}
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0xc
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GcDirIndexSource))
	return i, nil
}

func (m *CMsgWebAPIKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgWebAPIKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Status))
	}
	if m.AccountId != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.AccountId))
	}
	if m.PublisherGroupId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.PublisherGroupId))
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.KeyId))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	return i, nil
}

func (m *CMsgHttpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RequestMethod))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Hostname)))
	i += copy(dAtA[i:], m.Hostname)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Url)))
	i += copy(dAtA[i:], m.Url)
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GetParams) > 0 {
		for _, msg := range m.GetParams {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PostParams) > 0 {
		for _, msg := range m.PostParams {
			dAtA[i] = 0x32
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Body != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AbsoluteTimeout))
	return i, nil
}

func (m *CMsgHttpRequest_RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpRequest_RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CMsgHttpRequest_QueryParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpRequest_QueryParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *CMsgWebAPIRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgWebAPIRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.UNUSEDJobName)))
	i += copy(dAtA[i:], m.UNUSEDJobName)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.InterfaceName)))
	i += copy(dAtA[i:], m.InterfaceName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.MethodName)))
	i += copy(dAtA[i:], m.MethodName)
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Version))
	if m.ApiKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.ApiKey.Size()))
		n1, err := m.ApiKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Request != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.Request.Size()))
		n2, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RoutingAppId))
	return i, nil
}

func (m *CMsgHttpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.StatusCode))
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Body != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *CMsgHttpResponse_ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgHttpResponse_ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CMsgAMFindAccounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMFindAccounts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SearchType))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.SearchString)))
	i += copy(dAtA[i:], m.SearchString)
	return i, nil
}

func (m *CMsgAMFindAccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMFindAccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SteamId) > 0 {
		for _, num := range m.SteamId {
			dAtA[i] = 0x9
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	return i, nil
}

func (m *CMsgNotifyWatchdog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgNotifyWatchdog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Source))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AlertType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AlertDestination))
	dAtA[i] = 0x20
	i++
	if m.Critical {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Time))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Appid))
	dAtA[i] = 0x3a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}

func (m *CMsgAMGetLicenses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetLicenses) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	return i, nil
}

func (m *CMsgPackageLicense) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgPackageLicense) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PackageId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TimeCreated))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OwnerId))
	return i, nil
}

func (m *CMsgAMGetLicensesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetLicensesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.License) > 0 {
		for _, msg := range m.License {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Result))
	return i, nil
}

func (m *CMsgAMGetUserGameStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.SteamId))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.GameId))
	if len(m.Stats) > 0 {
		for _, num := range m.Stats {
			dAtA[i] = 0x18
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CMsgAMGetUserGameStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.SteamId))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.GameId))
	if m.Eresult != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AchievementBlocks) > 0 {
		for _, msg := range m.AchievementBlocks {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.StatId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.StatValue))
	return i, nil
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AchievementId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AchievementBitId))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Steammessages(dAtA, i, uint32(m.UnlockTime))
	return i, nil
}

func (m *CMsgGCGetCommandList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetCommandList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.CommandPrefix)))
	i += copy(dAtA[i:], m.CommandPrefix)
	return i, nil
}

func (m *CMsgGCGetCommandListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetCommandListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommandName) > 0 {
		for _, s := range m.CommandName {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Found {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *CGCMsgMemCachedSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedSet_KeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedSet_KeyPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *CGCMsgMemCachedDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CGCMsgMemCachedStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CGCMsgMemCachedStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgMemCachedStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CurrConnections))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmdGet))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmdSet))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CmdFlush))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GetHits))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GetMisses))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DeleteHits))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DeleteMisses))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.BytesRead))
	dAtA[i] = 0x50
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.BytesWritten))
	dAtA[i] = 0x58
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LimitMaxbytes))
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.CurrItems))
	dAtA[i] = 0x68
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Evictions))
	dAtA[i] = 0x70
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Bytes))
	return i, nil
}

func (m *CGCMsgSQLStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgSQLStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SchemaCatalog))
	return i, nil
}

func (m *CGCMsgSQLStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgSQLStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Threads))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ThreadsConnected))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ThreadsActive))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OperationsSubmitted))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PreparedStatementsExecuted))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.NonPreparedStatementsExecuted))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DeadlockRetries))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OperationsTimedOutInQueue))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Errors))
	return i, nil
}

func (m *CMsgAMAddFreeLicense) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMAddFreeLicense) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.IpPublic))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Packageid))
	dAtA[i] = 0x22
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.StoreCountryCode)))
	i += copy(dAtA[i:], m.StoreCountryCode)
	return i, nil
}

func (m *CMsgAMAddFreeLicenseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMAddFreeLicenseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PurchaseResultDetail))
	dAtA[i] = 0x19
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Transid))
	return i, nil
}

func (m *CGCMsgGetIPLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetIPLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ips) > 0 {
		for _, num := range m.Ips {
			dAtA[i] = 0xd
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
		}
	}
	return i, nil
}

func (m *CIPLocationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CIPLocationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Ip))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Steammessages(dAtA, i, uint32(math.Float32bits(float32(m.Latitude))))
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Steammessages(dAtA, i, uint32(math.Float32bits(float32(m.Longitude))))
	dAtA[i] = 0x22
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Country)))
	i += copy(dAtA[i:], m.Country)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.State)))
	i += copy(dAtA[i:], m.State)
	dAtA[i] = 0x32
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.City)))
	i += copy(dAtA[i:], m.City)
	return i, nil
}

func (m *CGCMsgGetIPLocationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetIPLocationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CGCMsgSystemStatsSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgSystemStatsSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GcAppId))
	if m.SchemaKv != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.SchemaKv)))
		i += copy(dAtA[i:], m.SchemaKv)
	}
	return i, nil
}

func (m *CGCMsgGetSystemStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetSystemStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CGCMsgGetSystemStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCMsgGetSystemStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GcAppId))
	if m.StatsKv != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(len(m.StatsKv)))
		i += copy(dAtA[i:], m.StatsKv)
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ActiveJobs))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.YieldingJobs))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.UserSessions))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.GameServerSessions))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Socaches))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SocachesToUnload))
	dAtA[i] = 0x48
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SocachesLoading))
	dAtA[i] = 0x50
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.WritebackQueue))
	dAtA[i] = 0x58
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SteamidLocks))
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LogonQueue))
	dAtA[i] = 0x68
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.LogonJobs))
	return i, nil
}

func (m *CMsgAMSendEmail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailMsgType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailFormat))
	if len(m.PersonaNameTokens) > 0 {
		for _, msg := range m.PersonaNameTokens {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SourceGc))
	if len(m.Tokens) > 0 {
		for _, msg := range m.Tokens {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgAMSendEmail_ReplacementToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmail_ReplacementToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TokenName)))
	i += copy(dAtA[i:], m.TokenName)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TokenValue)))
	i += copy(dAtA[i:], m.TokenValue)
	return i, nil
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.TokenName)))
	i += copy(dAtA[i:], m.TokenName)
	return i, nil
}

func (m *CMsgAMSendEmailResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMSendEmailResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCGetEmailTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetEmailTemplate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailMsgType))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailLang))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.EmailFormat))
	return i, nil
}

func (m *CMsgGCGetEmailTemplateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetEmailTemplateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	dAtA[i] = 0x10
	i++
	if m.TemplateExists {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Template)))
	i += copy(dAtA[i:], m.Template)
	return i, nil
}

func (m *CMsgAMGrantGuestPasses2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGrantGuestPasses2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.SteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PackageId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PassesToGrant))
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DaysToExpiration))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Action))
	return i, nil
}

func (m *CMsgAMGrantGuestPasses2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAMGrantGuestPasses2Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	if m.PassesGranted != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.PassesGranted))
	}
	return i, nil
}

func (m *CGCSystemMsg_GetAccountDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetAccountDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Appid))
	return i, nil
}

func (m *CGCSystemMsg_GetAccountDetails_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetAccountDetails_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EresultDeprecated != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.EresultDeprecated))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.AccountName)))
	i += copy(dAtA[i:], m.AccountName)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.PersonaName)))
	i += copy(dAtA[i:], m.PersonaName)
	dAtA[i] = 0x20
	i++
	if m.IsProfilePublic {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.IsInventoryPublic {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.IsVacBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.IsCyberCafe {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.IsSchoolAccount {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x50
	i++
	if m.IsLimited {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x58
	i++
	if m.IsSubscribed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x60
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Package))
	dAtA[i] = 0x68
	i++
	if m.IsFreeTrialAccount {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.FreeTrialExpiration))
	dAtA[i] = 0x78
	i++
	if m.IsLowViolence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	if m.IsAccountLockedDown {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	if m.IsCommunityBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	if m.IsTradeBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TradeBanExpiration))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Accountid))
	dAtA[i] = 0xa8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SuspensionEndTime))
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Currency)))
	i += copy(dAtA[i:], m.Currency)
	dAtA[i] = 0xb8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.SteamLevel))
	dAtA[i] = 0xc0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.FriendCount))
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AccountCreationTime))
	dAtA[i] = 0xd8
	i++
	dAtA[i] = 0x1
	i++
	if m.IsSteamguardEnabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xe0
	i++
	dAtA[i] = 0x1
	i++
	if m.IsPhoneVerified {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xe8
	i++
	dAtA[i] = 0x1
	i++
	if m.IsTwoFactorAuthEnabled {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0xf0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TwoFactorEnabledTime))
	dAtA[i] = 0xf8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PhoneVerificationTime))
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.PhoneId))
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x2
	i++
	if m.IsPhoneIdentifying {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCGetPersonaNames) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPersonaNames) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Steamids) > 0 {
		for _, num := range m.Steamids {
			dAtA[i] = 0x9
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	return i, nil
}

func (m *CMsgGCGetPersonaNames_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPersonaNames_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SucceededLookups) > 0 {
		for _, msg := range m.SucceededLookups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FailedLookupSteamids) > 0 {
		for _, num := range m.FailedLookupSteamids {
			dAtA[i] = 0x11
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	return i, nil
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.PersonaName)))
	i += copy(dAtA[i:], m.PersonaName)
	return i, nil
}

func (m *CMsgGCCheckFriendship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCCheckFriendship) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.SteamidLeft))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.SteamidRight))
	return i, nil
}

func (m *CMsgGCCheckFriendship_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCCheckFriendship_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Success {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	if m.FoundFriendship {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCMsgMasterSetDirectory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetDirectory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.MasterDirIndex))
	if len(m.Dir) > 0 {
		for _, msg := range m.Dir {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DirIndex))
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Box)))
	i += copy(dAtA[i:], m.Box)
	dAtA[i] = 0x22
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.CommandLine)))
	i += copy(dAtA[i:], m.CommandLine)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.GcBinary)))
	i += copy(dAtA[i:], m.GcBinary)
	return i, nil
}

func (m *CMsgGCMsgMasterSetDirectory_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetDirectory_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.DirIndex))
	return i, nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	return i, nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.HasPriorPurchaseHistory {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x10
	i++
	if m.HasNoRecentPasswordResets {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	if m.IsWalletCashTrusted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.TimeAllTrusted))
	return i, nil
}

func (m *CMsgGCHAccountVacStatusChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCHAccountVacStatusChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.SteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.RtimeVacbanStarts))
	dAtA[i] = 0x20
	i++
	if m.IsBannedNow {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.IsBannedFuture {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCGetPartnerAccountLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPartnerAccountLink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	return i, nil
}

func (m *CMsgGCGetPartnerAccountLink_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCGetPartnerAccountLink_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Pwid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Nexonid))
	return i, nil
}

func (m *CMsgGCRoutingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCRoutingInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DirIndex) > 0 {
		for _, num := range m.DirIndex {
			dAtA[i] = 0x8
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(num))
		}
	}
	if m.Method != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Method))
	}
	if m.Fallback != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Fallback))
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ProtobufField))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.WebapiParam)))
	i += copy(dAtA[i:], m.WebapiParam)
	return i, nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.InterfaceName)))
	i += copy(dAtA[i:], m.InterfaceName)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.MethodName)))
	i += copy(dAtA[i:], m.MethodName)
	if m.Routing != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.Routing.Size()))
		n3, err := m.Routing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.MsgType))
	if m.Routing != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.Routing.Size()))
		n4, err := m.Routing.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CMsgGCMsgSetOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgSetOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Options) > 0 {
		for _, num := range m.Options {
			dAtA[i] = 0x8
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(num))
		}
	}
	if len(m.ClientMsgRanges) > 0 {
		for _, msg := range m.ClientMsgRanges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCMsgSetOptions_MessageRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMsgSetOptions_MessageRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Low))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.High))
	return i, nil
}

func (m *CMsgGCHUpdateSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCHUpdateSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.SteamId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppId))
	dAtA[i] = 0x18
	i++
	if m.Online {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x21
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.ServerSteamId))
	dAtA[i] = 0x28
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ServerAddr))
	dAtA[i] = 0x30
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ServerPort))
	dAtA[i] = 0x38
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.OsType))
	dAtA[i] = 0x40
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.ClientAddr))
	if len(m.ExtraFields) > 0 {
		for _, msg := range m.ExtraFields {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintSteammessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CMsgGCHUpdateSession_ExtraField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCHUpdateSession_ExtraField) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *CMsgNotificationOfSuspiciousActivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgNotificationOfSuspiciousActivity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Steammessages(dAtA, i, uint64(m.Steamid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.Appid))
	if m.MultipleInstances != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSteammessages(dAtA, i, uint64(m.MultipleInstances.Size()))
		n5, err := m.MultipleInstances.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintSteammessages(dAtA, i, uint64(m.AppInstanceCount))
	if len(m.OtherSteamids) > 0 {
		for _, num := range m.OtherSteamids {
			dAtA[i] = 0x11
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	return i, nil
}

func encodeFixed64Steammessages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Steammessages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSteammessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CMsgProtoBufHeader) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.ClientSessionId))
	n += 1 + sovSteammessages(uint64(m.SourceAppId))
	if m.JobIdSource != nil {
		n += 9
	}
	if m.JobIdTarget != nil {
		n += 9
	}
	l = len(m.TargetJobName)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	l = len(m.ErrorMessage)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.GcMsgSrc != nil {
		n += 2 + sovSteammessages(uint64(*m.GcMsgSrc))
	}
	n += 2 + sovSteammessages(uint64(m.GcDirIndexSource))
	return n
}

func (m *CMsgWebAPIKey) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovSteammessages(uint64(*m.Status))
	}
	if m.AccountId != nil {
		n += 1 + sovSteammessages(uint64(*m.AccountId))
	}
	if m.PublisherGroupId != nil {
		n += 1 + sovSteammessages(uint64(*m.PublisherGroupId))
	}
	n += 1 + sovSteammessages(uint64(m.KeyId))
	l = len(m.Domain)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgHttpRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.RequestMethod))
	l = len(m.Hostname)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Url)
	n += 1 + l + sovSteammessages(uint64(l))
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.GetParams) > 0 {
		for _, e := range m.GetParams {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.PostParams) > 0 {
		for _, e := range m.PostParams {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	n += 1 + sovSteammessages(uint64(m.AbsoluteTimeout))
	return n
}

func (m *CMsgHttpRequest_RequestHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgHttpRequest_QueryParam) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgWebAPIRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.UNUSEDJobName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.InterfaceName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.MethodName)
	n += 1 + l + sovSteammessages(uint64(l))
	n += 1 + sovSteammessages(uint64(m.Version))
	if m.ApiKey != nil {
		l = m.ApiKey.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	n += 1 + sovSteammessages(uint64(m.RoutingAppId))
	return n
}

func (m *CMsgHttpResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.StatusCode))
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgHttpResponse_ResponseHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMFindAccounts) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.SearchType))
	l = len(m.SearchString)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMFindAccountsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.SteamId) > 0 {
		n += 9 * len(m.SteamId)
	}
	return n
}

func (m *CMsgNotifyWatchdog) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Source))
	n += 1 + sovSteammessages(uint64(m.AlertType))
	n += 1 + sovSteammessages(uint64(m.AlertDestination))
	n += 2
	n += 1 + sovSteammessages(uint64(m.Time))
	n += 1 + sovSteammessages(uint64(m.Appid))
	l = len(m.Text)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMGetLicenses) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgPackageLicense) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.PackageId))
	n += 1 + sovSteammessages(uint64(m.TimeCreated))
	n += 1 + sovSteammessages(uint64(m.OwnerId))
	return n
}

func (m *CMsgAMGetLicensesResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.License) > 0 {
		for _, e := range m.License {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	n += 1 + sovSteammessages(uint64(m.Result))
	return n
}

func (m *CMsgAMGetUserGameStats) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 9
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			n += 1 + sovSteammessages(uint64(e))
		}
	}
	return n
}

func (m *CMsgAMGetUserGameStatsResponse) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 9
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.AchievementBlocks) > 0 {
		for _, e := range m.AchievementBlocks {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgAMGetUserGameStatsResponse_Stats) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.StatId))
	n += 1 + sovSteammessages(uint64(m.StatValue))
	return n
}

func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AchievementId))
	n += 1 + sovSteammessages(uint64(m.AchievementBitId))
	n += 5
	return n
}

func (m *CMsgGCGetCommandList) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AppId))
	l = len(m.CommandPrefix)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCGetCommandListResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.CommandName) > 0 {
		for _, s := range m.CommandName {
			l = len(s)
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedGet) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedGetResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedGetResponse_ValueTag) Size() (n int) {
	var l int
	_ = l
	n += 2
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CGCMsgMemCachedSet) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedSet_KeyPair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CGCMsgMemCachedDelete) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgMemCachedStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CGCMsgMemCachedStatsResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.CurrConnections))
	n += 1 + sovSteammessages(uint64(m.CmdGet))
	n += 1 + sovSteammessages(uint64(m.CmdSet))
	n += 1 + sovSteammessages(uint64(m.CmdFlush))
	n += 1 + sovSteammessages(uint64(m.GetHits))
	n += 1 + sovSteammessages(uint64(m.GetMisses))
	n += 1 + sovSteammessages(uint64(m.DeleteHits))
	n += 1 + sovSteammessages(uint64(m.DeleteMisses))
	n += 1 + sovSteammessages(uint64(m.BytesRead))
	n += 1 + sovSteammessages(uint64(m.BytesWritten))
	n += 1 + sovSteammessages(uint64(m.LimitMaxbytes))
	n += 1 + sovSteammessages(uint64(m.CurrItems))
	n += 1 + sovSteammessages(uint64(m.Evictions))
	n += 1 + sovSteammessages(uint64(m.Bytes))
	return n
}

func (m *CGCMsgSQLStats) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.SchemaCatalog))
	return n
}

func (m *CGCMsgSQLStatsResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Threads))
	n += 1 + sovSteammessages(uint64(m.ThreadsConnected))
	n += 1 + sovSteammessages(uint64(m.ThreadsActive))
	n += 1 + sovSteammessages(uint64(m.OperationsSubmitted))
	n += 1 + sovSteammessages(uint64(m.PreparedStatementsExecuted))
	n += 1 + sovSteammessages(uint64(m.NonPreparedStatementsExecuted))
	n += 1 + sovSteammessages(uint64(m.DeadlockRetries))
	n += 1 + sovSteammessages(uint64(m.OperationsTimedOutInQueue))
	n += 1 + sovSteammessages(uint64(m.Errors))
	return n
}

func (m *CMsgAMAddFreeLicense) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.IpPublic))
	n += 1 + sovSteammessages(uint64(m.Packageid))
	l = len(m.StoreCountryCode)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMAddFreeLicenseResponse) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	n += 1 + sovSteammessages(uint64(m.PurchaseResultDetail))
	n += 9
	return n
}

func (m *CGCMsgGetIPLocation) Size() (n int) {
	var l int
	_ = l
	if len(m.Ips) > 0 {
		n += 5 * len(m.Ips)
	}
	return n
}

func (m *CIPLocationInfo) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Ip))
	n += 5
	n += 5
	l = len(m.Country)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.State)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.City)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CGCMsgGetIPLocationResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CGCMsgSystemStatsSchema) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.GcAppId))
	if m.SchemaKv != nil {
		l = len(m.SchemaKv)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CGCMsgGetSystemStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CGCMsgGetSystemStatsResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.GcAppId))
	if m.StatsKv != nil {
		l = len(m.StatsKv)
		n += 1 + l + sovSteammessages(uint64(l))
	}
	n += 1 + sovSteammessages(uint64(m.ActiveJobs))
	n += 1 + sovSteammessages(uint64(m.YieldingJobs))
	n += 1 + sovSteammessages(uint64(m.UserSessions))
	n += 1 + sovSteammessages(uint64(m.GameServerSessions))
	n += 1 + sovSteammessages(uint64(m.Socaches))
	n += 1 + sovSteammessages(uint64(m.SocachesToUnload))
	n += 1 + sovSteammessages(uint64(m.SocachesLoading))
	n += 1 + sovSteammessages(uint64(m.WritebackQueue))
	n += 1 + sovSteammessages(uint64(m.SteamidLocks))
	n += 1 + sovSteammessages(uint64(m.LogonQueue))
	n += 1 + sovSteammessages(uint64(m.LogonJobs))
	return n
}

func (m *CMsgAMSendEmail) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.EmailMsgType))
	n += 1 + sovSteammessages(uint64(m.EmailFormat))
	if len(m.PersonaNameTokens) > 0 {
		for _, e := range m.PersonaNameTokens {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	n += 1 + sovSteammessages(uint64(m.SourceGc))
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgAMSendEmail_ReplacementToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.TokenName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.TokenValue)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Size() (n int) {
	var l int
	_ = l
	n += 9
	l = len(m.TokenName)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMSendEmailResponse) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCGetEmailTemplate) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AppId))
	n += 1 + sovSteammessages(uint64(m.EmailMsgType))
	n += 1 + sovSteammessages(uint64(m.EmailLang))
	n += 1 + sovSteammessages(uint64(m.EmailFormat))
	return n
}

func (m *CMsgGCGetEmailTemplateResponse) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	n += 2
	l = len(m.Template)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgAMGrantGuestPasses2) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.PackageId))
	n += 1 + sovSteammessages(uint64(m.PassesToGrant))
	n += 1 + sovSteammessages(uint64(m.DaysToExpiration))
	n += 1 + sovSteammessages(uint64(m.Action))
	return n
}

func (m *CMsgAMGrantGuestPasses2Response) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	if m.PassesGranted != nil {
		n += 1 + sovSteammessages(uint64(*m.PassesGranted))
	}
	return n
}

func (m *CGCSystemMsg_GetAccountDetails) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.Appid))
	return n
}

func (m *CGCSystemMsg_GetAccountDetails_Response) Size() (n int) {
	var l int
	_ = l
	if m.EresultDeprecated != nil {
		n += 1 + sovSteammessages(uint64(*m.EresultDeprecated))
	}
	l = len(m.AccountName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.PersonaName)
	n += 1 + l + sovSteammessages(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 1 + sovSteammessages(uint64(m.Package))
	n += 2
	n += 1 + sovSteammessages(uint64(m.FreeTrialExpiration))
	n += 2
	n += 3
	n += 3
	n += 3
	n += 2 + sovSteammessages(uint64(m.TradeBanExpiration))
	n += 2 + sovSteammessages(uint64(m.Accountid))
	n += 2 + sovSteammessages(uint64(m.SuspensionEndTime))
	l = len(m.Currency)
	n += 2 + l + sovSteammessages(uint64(l))
	n += 2 + sovSteammessages(uint64(m.SteamLevel))
	n += 2 + sovSteammessages(uint64(m.FriendCount))
	n += 2 + sovSteammessages(uint64(m.AccountCreationTime))
	n += 3
	n += 3
	n += 3
	n += 2 + sovSteammessages(uint64(m.TwoFactorEnabledTime))
	n += 2 + sovSteammessages(uint64(m.PhoneVerificationTime))
	n += 2 + sovSteammessages(uint64(m.PhoneId))
	n += 3
	return n
}

func (m *CMsgGCGetPersonaNames) Size() (n int) {
	var l int
	_ = l
	if len(m.Steamids) > 0 {
		n += 9 * len(m.Steamids)
	}
	return n
}

func (m *CMsgGCGetPersonaNames_Response) Size() (n int) {
	var l int
	_ = l
	if len(m.SucceededLookups) > 0 {
		for _, e := range m.SucceededLookups {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	if len(m.FailedLookupSteamids) > 0 {
		n += 9 * len(m.FailedLookupSteamids)
	}
	return n
}

func (m *CMsgGCGetPersonaNames_Response_PersonaName) Size() (n int) {
	var l int
	_ = l
	n += 9
	l = len(m.PersonaName)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCCheckFriendship) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 9
	return n
}

func (m *CMsgGCCheckFriendship_Response) Size() (n int) {
	var l int
	_ = l
	n += 2
	n += 2
	return n
}

func (m *CMsgGCMsgMasterSetDirectory) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.MasterDirIndex))
	if len(m.Dir) > 0 {
		for _, e := range m.Dir {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgMasterSetDirectory_SubGC) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.DirIndex))
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Box)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.CommandLine)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.GcBinary)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCMsgMasterSetDirectory_Response) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.DirIndex))
	return n
}

func (m *CGCSystemMsg_GetPurchaseTrust_Request) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CGCSystemMsg_GetPurchaseTrust_Response) Size() (n int) {
	var l int
	_ = l
	n += 2
	n += 2
	n += 2
	n += 1 + sovSteammessages(uint64(m.TimeAllTrusted))
	return n
}

func (m *CMsgGCHAccountVacStatusChange) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.AppId))
	n += 1 + sovSteammessages(uint64(m.RtimeVacbanStarts))
	n += 2
	n += 2
	return n
}

func (m *CMsgGCGetPartnerAccountLink) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgGCGetPartnerAccountLink_Response) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Pwid))
	n += 1 + sovSteammessages(uint64(m.Nexonid))
	return n
}

func (m *CMsgGCRoutingInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.DirIndex) > 0 {
		for _, e := range m.DirIndex {
			n += 1 + sovSteammessages(uint64(e))
		}
	}
	if m.Method != nil {
		n += 1 + sovSteammessages(uint64(*m.Method))
	}
	if m.Fallback != nil {
		n += 1 + sovSteammessages(uint64(*m.Fallback))
	}
	n += 1 + sovSteammessages(uint64(m.ProtobufField))
	l = len(m.WebapiParam)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgGCMsgMasterSetWebAPIRouting) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Size() (n int) {
	var l int
	_ = l
	l = len(m.InterfaceName)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.MethodName)
	n += 1 + l + sovSteammessages(uint64(l))
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgGCMsgMasterSetClientMsgRouting) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.MsgType))
	if m.Routing != nil {
		l = m.Routing.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovSteammessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CMsgGCMsgSetOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			n += 1 + sovSteammessages(uint64(e))
		}
	}
	if len(m.ClientMsgRanges) > 0 {
		for _, e := range m.ClientMsgRanges {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCMsgSetOptions_MessageRange) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.Low))
	n += 1 + sovSteammessages(uint64(m.High))
	return n
}

func (m *CMsgGCHUpdateSession) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.AppId))
	n += 2
	n += 9
	n += 1 + sovSteammessages(uint64(m.ServerAddr))
	n += 1 + sovSteammessages(uint64(m.ServerPort))
	n += 1 + sovSteammessages(uint64(m.OsType))
	n += 1 + sovSteammessages(uint64(m.ClientAddr))
	if len(m.ExtraFields) > 0 {
		for _, e := range m.ExtraFields {
			l = e.Size()
			n += 1 + l + sovSteammessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgGCHUpdateSession_ExtraField) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSteammessages(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovSteammessages(uint64(l))
	return n
}

func (m *CMsgNotificationOfSuspiciousActivity) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 1 + sovSteammessages(uint64(m.Appid))
	if m.MultipleInstances != nil {
		l = m.MultipleInstances.Size()
		n += 1 + l + sovSteammessages(uint64(l))
	}
	return n
}

func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSteammessages(uint64(m.AppInstanceCount))
	if len(m.OtherSteamids) > 0 {
		n += 9 * len(m.OtherSteamids)
	}
	return n
}

func sovSteammessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSteammessages(x uint64) (n int) {
	return sovSteammessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CMsgProtoBufHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgProtoBufHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgProtoBufHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSteamId", wireType)
			}
			m.ClientSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ClientSteamId = uint64(dAtA[iNdEx-8])
			m.ClientSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.ClientSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.ClientSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.ClientSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.ClientSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.ClientSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.ClientSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSessionId", wireType)
			}
			m.ClientSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSessionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAppId", wireType)
			}
			m.SourceAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceAppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIdSource", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.JobIdSource = &v
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIdTarget", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.JobIdTarget = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetJobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetJobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcMsgSrc", wireType)
			}
			var v GCProtoBufMsgSrc
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (GCProtoBufMsgSrc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GcMsgSrc = &v
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcDirIndexSource", wireType)
			}
			m.GcDirIndexSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcDirIndexSource |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgWebAPIKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgWebAPIKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgWebAPIKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccountId = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherGroupId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublisherGroupId = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgHttpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgHttpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMethod", wireType)
			}
			m.RequestMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestMethod |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &CMsgHttpRequest_RequestHeader{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GetParams = append(m.GetParams, &CMsgHttpRequest_QueryParam{})
			if err := m.GetParams[len(m.GetParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostParams = append(m.PostParams, &CMsgHttpRequest_QueryParam{})
			if err := m.PostParams[len(m.PostParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsoluteTimeout", wireType)
			}
			m.AbsoluteTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbsoluteTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpRequest_RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpRequest_QueryParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgWebAPIRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgWebAPIRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgWebAPIRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UNUSEDJobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UNUSEDJobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiKey == nil {
				m.ApiKey = &CMsgWebAPIKey{}
			}
			if err := m.ApiKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &CMsgHttpRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingAppId", wireType)
			}
			m.RoutingAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoutingAppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgHttpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgHttpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &CMsgHttpResponse_ResponseHeader{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgHttpResponse_ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMFindAccounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMFindAccounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMFindAccounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchType", wireType)
			}
			m.SearchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SearchType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMFindAccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMFindAccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMFindAccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.SteamId = append(m.SteamId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.SteamId = append(m.SteamId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgNotifyWatchdog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgNotifyWatchdog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgNotifyWatchdog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertType", wireType)
			}
			m.AlertType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertDestination", wireType)
			}
			m.AlertDestination = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertDestination |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Critical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Critical = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetLicenses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetLicenses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetLicenses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgPackageLicense) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgPackageLicense: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgPackageLicense: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCreated", wireType)
			}
			m.TimeCreated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCreated |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetLicensesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetLicensesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetLicensesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.License = append(m.License, &CMsgPackageLicense{})
			if err := m.License[len(m.License)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.GameId = uint64(dAtA[iNdEx-8])
			m.GameId |= uint64(dAtA[iNdEx-7]) << 8
			m.GameId |= uint64(dAtA[iNdEx-6]) << 16
			m.GameId |= uint64(dAtA[iNdEx-5]) << 24
			m.GameId |= uint64(dAtA[iNdEx-4]) << 32
			m.GameId |= uint64(dAtA[iNdEx-3]) << 40
			m.GameId |= uint64(dAtA[iNdEx-2]) << 48
			m.GameId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Stats = append(m.Stats, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteammessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Stats = append(m.Stats, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGetUserGameStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.GameId = uint64(dAtA[iNdEx-8])
			m.GameId |= uint64(dAtA[iNdEx-7]) << 8
			m.GameId |= uint64(dAtA[iNdEx-6]) << 16
			m.GameId |= uint64(dAtA[iNdEx-5]) << 24
			m.GameId |= uint64(dAtA[iNdEx-4]) << 32
			m.GameId |= uint64(dAtA[iNdEx-3]) << 40
			m.GameId |= uint64(dAtA[iNdEx-2]) << 48
			m.GameId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &CMsgAMGetUserGameStatsResponse_Stats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementBlocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementBlocks = append(m.AchievementBlocks, &CMsgAMGetUserGameStatsResponse_Achievement_Blocks{})
			if err := m.AchievementBlocks[len(m.AchievementBlocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStatsResponse_Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatId", wireType)
			}
			m.StatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatValue", wireType)
			}
			m.StatValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatValue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGetUserGameStatsResponse_Achievement_Blocks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Achievement_Blocks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Achievement_Blocks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementId", wireType)
			}
			m.AchievementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AchievementId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementBitId", wireType)
			}
			m.AchievementBitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AchievementBitId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTime", wireType)
			}
			m.UnlockTime = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.UnlockTime = uint32(dAtA[iNdEx-4])
			m.UnlockTime |= uint32(dAtA[iNdEx-3]) << 8
			m.UnlockTime |= uint32(dAtA[iNdEx-2]) << 16
			m.UnlockTime |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetCommandList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetCommandList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetCommandList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetCommandListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetCommandListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetCommandListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandName = append(m.CommandName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedGet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedGet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CGCMsgMemCachedGetResponse_ValueTag{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedGetResponse_ValueTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &CGCMsgMemCachedSet_KeyPair{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedSet_KeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgMemCachedStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgMemCachedStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgMemCachedStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrConnections", wireType)
			}
			m.CurrConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrConnections |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdGet", wireType)
			}
			m.CmdGet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdGet |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdSet", wireType)
			}
			m.CmdSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdSet |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdFlush", wireType)
			}
			m.CmdFlush = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdFlush |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetHits", wireType)
			}
			m.GetHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetHits |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetMisses", wireType)
			}
			m.GetMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetMisses |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteHits", wireType)
			}
			m.DeleteHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteHits |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteMisses", wireType)
			}
			m.DeleteMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteMisses |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitMaxbytes", wireType)
			}
			m.LimitMaxbytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitMaxbytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrItems", wireType)
			}
			m.CurrItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrItems |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evictions", wireType)
			}
			m.Evictions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Evictions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgSQLStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgSQLStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgSQLStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaCatalog", wireType)
			}
			m.SchemaCatalog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaCatalog |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgSQLStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgSQLStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgSQLStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threads |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadsConnected", wireType)
			}
			m.ThreadsConnected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadsConnected |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadsActive", wireType)
			}
			m.ThreadsActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadsActive |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsSubmitted", wireType)
			}
			m.OperationsSubmitted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationsSubmitted |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparedStatementsExecuted", wireType)
			}
			m.PreparedStatementsExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparedStatementsExecuted |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonPreparedStatementsExecuted", wireType)
			}
			m.NonPreparedStatementsExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NonPreparedStatementsExecuted |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadlockRetries", wireType)
			}
			m.DeadlockRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadlockRetries |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsTimedOutInQueue", wireType)
			}
			m.OperationsTimedOutInQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationsTimedOutInQueue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMAddFreeLicense) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicense: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicense: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPublic", wireType)
			}
			m.IpPublic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPublic |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packageid", wireType)
			}
			m.Packageid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Packageid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreCountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreCountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMAddFreeLicenseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicenseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMAddFreeLicenseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseResultDetail", wireType)
			}
			m.PurchaseResultDetail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurchaseResultDetail |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transid", wireType)
			}
			m.Transid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Transid = uint64(dAtA[iNdEx-8])
			m.Transid |= uint64(dAtA[iNdEx-7]) << 8
			m.Transid |= uint64(dAtA[iNdEx-6]) << 16
			m.Transid |= uint64(dAtA[iNdEx-5]) << 24
			m.Transid |= uint64(dAtA[iNdEx-4]) << 32
			m.Transid |= uint64(dAtA[iNdEx-3]) << 40
			m.Transid |= uint64(dAtA[iNdEx-2]) << 48
			m.Transid |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetIPLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetIPLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetIPLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				m.Ips = append(m.Ips, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					m.Ips = append(m.Ips, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ips", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CIPLocationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CIPLocationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CIPLocationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetIPLocationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetIPLocationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetIPLocationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &CIPLocationInfo{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgSystemStatsSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgSystemStatsSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgSystemStatsSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcAppId", wireType)
			}
			m.GcAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcAppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaKv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaKv = append(m.SchemaKv[:0], dAtA[iNdEx:postIndex]...)
			if m.SchemaKv == nil {
				m.SchemaKv = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetSystemStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetSystemStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetSystemStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCMsgGetSystemStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCMsgGetSystemStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCMsgGetSystemStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcAppId", wireType)
			}
			m.GcAppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcAppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsKv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatsKv = append(m.StatsKv[:0], dAtA[iNdEx:postIndex]...)
			if m.StatsKv == nil {
				m.StatsKv = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveJobs", wireType)
			}
			m.ActiveJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveJobs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldingJobs", wireType)
			}
			m.YieldingJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YieldingJobs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSessions", wireType)
			}
			m.UserSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameServerSessions", wireType)
			}
			m.GameServerSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameServerSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Socaches", wireType)
			}
			m.Socaches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Socaches |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocachesToUnload", wireType)
			}
			m.SocachesToUnload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SocachesToUnload |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocachesLoading", wireType)
			}
			m.SocachesLoading = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SocachesLoading |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritebackQueue", wireType)
			}
			m.WritebackQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WritebackQueue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamidLocks", wireType)
			}
			m.SteamidLocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SteamidLocks |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogonQueue", wireType)
			}
			m.LogonQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogonQueue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogonJobs", wireType)
			}
			m.LogonJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogonJobs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMSendEmail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMSendEmail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailMsgType", wireType)
			}
			m.EmailMsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailMsgType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailFormat", wireType)
			}
			m.EmailFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailFormat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonaNameTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonaNameTokens = append(m.PersonaNameTokens, &CMsgAMSendEmail_PersonaNameReplacementToken{})
			if err := m.PersonaNameTokens[len(m.PersonaNameTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGc", wireType)
			}
			m.SourceGc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceGc |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, &CMsgAMSendEmail_ReplacementToken{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmail_ReplacementToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplacementToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplacementToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmail_PersonaNameReplacementToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonaNameReplacementToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonaNameReplacementToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMSendEmailResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMSendEmailResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMSendEmailResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetEmailTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailMsgType", wireType)
			}
			m.EmailMsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailMsgType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailLang", wireType)
			}
			m.EmailLang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailLang |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailFormat", wireType)
			}
			m.EmailFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailFormat |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetEmailTemplateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetEmailTemplateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TemplateExists = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Template = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGrantGuestPasses2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageId", wireType)
			}
			m.PackageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PackageId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassesToGrant", wireType)
			}
			m.PassesToGrant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassesToGrant |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaysToExpiration", wireType)
			}
			m.DaysToExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DaysToExpiration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAMGrantGuestPasses2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAMGrantGuestPasses2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassesGranted", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassesGranted = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetAccountDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetAccountDetails_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetAccountDetails_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EresultDeprecated", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EresultDeprecated = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProfilePublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProfilePublic = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInventoryPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInventoryPublic = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVacBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVacBanned = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCyberCafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCyberCafe = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSchoolAccount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSchoolAccount = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLimited = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubscribed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubscribed = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			m.Package = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Package |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFreeTrialAccount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFreeTrialAccount = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTrialExpiration", wireType)
			}
			m.FreeTrialExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTrialExpiration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLowViolence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLowViolence = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAccountLockedDown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAccountLockedDown = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCommunityBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCommunityBanned = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTradeBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTradeBanned = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeBanExpiration", wireType)
			}
			m.TradeBanExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradeBanExpiration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accountid", wireType)
			}
			m.Accountid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accountid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuspensionEndTime", wireType)
			}
			m.SuspensionEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuspensionEndTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamLevel", wireType)
			}
			m.SteamLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SteamLevel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendCount", wireType)
			}
			m.FriendCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountCreationTime", wireType)
			}
			m.AccountCreationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountCreationTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSteamguardEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSteamguardEnabled = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPhoneVerified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPhoneVerified = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTwoFactorAuthEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTwoFactorAuthEnabled = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwoFactorEnabledTime", wireType)
			}
			m.TwoFactorEnabledTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TwoFactorEnabledTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneVerificationTime", wireType)
			}
			m.PhoneVerificationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhoneVerificationTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneId", wireType)
			}
			m.PhoneId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhoneId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPhoneIdentifying", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPhoneIdentifying = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPersonaNames) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.Steamids = append(m.Steamids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.Steamids = append(m.Steamids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPersonaNames_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPersonaNames_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SucceededLookups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SucceededLookups = append(m.SucceededLookups, &CMsgGCGetPersonaNames_Response_PersonaName{})
			if err := m.SucceededLookups[len(m.SucceededLookups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.FailedLookupSteamids = append(m.FailedLookupSteamids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.FailedLookupSteamids = append(m.FailedLookupSteamids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedLookupSteamids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPersonaNames_Response_PersonaName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonaName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonaName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCCheckFriendship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamidLeft", wireType)
			}
			m.SteamidLeft = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamidLeft = uint64(dAtA[iNdEx-8])
			m.SteamidLeft |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamidLeft |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamidLeft |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamidLeft |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamidLeft |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamidLeft |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamidLeft |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamidRight", wireType)
			}
			m.SteamidRight = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamidRight = uint64(dAtA[iNdEx-8])
			m.SteamidRight |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamidRight |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamidRight |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamidRight |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamidRight |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamidRight |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamidRight |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCCheckFriendship_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCCheckFriendship_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundFriendship", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FoundFriendship = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetDirectory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterDirIndex", wireType)
			}
			m.MasterDirIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MasterDirIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dir = append(m.Dir, &CMsgGCMsgMasterSetDirectory_SubGC{})
			if err := m.Dir[len(m.Dir)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetDirectory_SubGC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubGC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubGC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirIndex", wireType)
			}
			m.DirIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Box", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Box = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandLine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandLine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcBinary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcBinary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetDirectory_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetDirectory_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgWebAPIJobRequestForwardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgWebAPIJobRequestForwardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgWebAPIJobRequestForwardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirIndex", wireType)
			}
			m.DirIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetPurchaseTrust_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCSystemMsg_GetPurchaseTrust_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCSystemMsg_GetPurchaseTrust_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPriorPurchaseHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPriorPurchaseHistory = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasNoRecentPasswordResets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasNoRecentPasswordResets = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWalletCashTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWalletCashTrusted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeAllTrusted", wireType)
			}
			m.TimeAllTrusted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeAllTrusted |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCHAccountVacStatusChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCHAccountVacStatusChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCHAccountVacStatusChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtimeVacbanStarts", wireType)
			}
			m.RtimeVacbanStarts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RtimeVacbanStarts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBannedNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBannedNow = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBannedFuture", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBannedFuture = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPartnerAccountLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCGetPartnerAccountLink_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCGetPartnerAccountLink_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pwid", wireType)
			}
			m.Pwid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pwid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexonid", wireType)
			}
			m.Nexonid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nexonid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCRoutingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCRoutingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCRoutingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DirIndex = append(m.DirIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteammessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DirIndex = append(m.DirIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DirIndex", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var v CMsgGCRoutingInfo_RoutingMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CMsgGCRoutingInfo_RoutingMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Method = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fallback", wireType)
			}
			var v CMsgGCRoutingInfo_RoutingMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CMsgGCRoutingInfo_RoutingMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fallback = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtobufField", wireType)
			}
			m.ProtobufField = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtobufField |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebapiParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebapiParam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetWebAPIRouting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CMsgGCMsgMasterSetWebAPIRouting_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &CMsgGCRoutingInfo{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetClientMsgRouting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &CMsgGCMsgMasterSetClientMsgRouting_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routing == nil {
				m.Routing = &CMsgGCRoutingInfo{}
			}
			if err := m.Routing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetWebAPIRouting_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetWebAPIRouting_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgMasterSetClientMsgRouting_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgMasterSetClientMsgRouting_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgSetOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMsgSetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMsgSetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v CMsgGCMsgSetOptions_Option
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CMsgGCMsgSetOptions_Option(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Options = append(m.Options, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CMsgGCMsgSetOptions_Option
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSteammessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CMsgGCMsgSetOptions_Option(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Options = append(m.Options, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientMsgRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientMsgRanges = append(m.ClientMsgRanges, &CMsgGCMsgSetOptions_MessageRange{})
			if err := m.ClientMsgRanges[len(m.ClientMsgRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMsgSetOptions_MessageRange) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			m.High = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.High |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("low")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("high")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCHUpdateSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCHUpdateSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCHUpdateSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamId", wireType)
			}
			m.SteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SteamId = uint64(dAtA[iNdEx-8])
			m.SteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.SteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.SteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.SteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.SteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.SteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.SteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSteamId", wireType)
			}
			m.ServerSteamId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ServerSteamId = uint64(dAtA[iNdEx-8])
			m.ServerSteamId |= uint64(dAtA[iNdEx-7]) << 8
			m.ServerSteamId |= uint64(dAtA[iNdEx-6]) << 16
			m.ServerSteamId |= uint64(dAtA[iNdEx-5]) << 24
			m.ServerSteamId |= uint64(dAtA[iNdEx-4]) << 32
			m.ServerSteamId |= uint64(dAtA[iNdEx-3]) << 40
			m.ServerSteamId |= uint64(dAtA[iNdEx-2]) << 48
			m.ServerSteamId |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddr", wireType)
			}
			m.ServerAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsType", wireType)
			}
			m.OsType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddr", wireType)
			}
			m.ClientAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientAddr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraFields = append(m.ExtraFields, &CMsgGCHUpdateSession_ExtraField{})
			if err := m.ExtraFields[len(m.ExtraFields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCHUpdateSession_ExtraField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgNotificationOfSuspiciousActivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgNotificationOfSuspiciousActivity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgNotificationOfSuspiciousActivity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSteammessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultipleInstances == nil {
				m.MultipleInstances = &CMsgNotificationOfSuspiciousActivity_MultipleGameInstances{}
			}
			if err := m.MultipleInstances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgNotificationOfSuspiciousActivity_MultipleGameInstances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultipleGameInstances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultipleGameInstances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppInstanceCount", wireType)
			}
			m.AppInstanceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppInstanceCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.OtherSteamids = append(m.OtherSteamids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSteammessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.OtherSteamids = append(m.OtherSteamids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherSteamids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSteammessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSteammessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSteammessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSteammessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSteammessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSteammessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSteammessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSteammessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSteammessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSteammessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("steammessages.proto", fileDescriptorSteammessages) }

var fileDescriptorSteammessages = []byte{
	// 5024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x7b, 0xcb, 0x6f, 0x5b, 0x49,
	0x76, 0xb7, 0x49, 0xbd, 0x0f, 0x45, 0x89, 0xba, 0x92, 0x6d, 0x5a, 0x7e, 0xc9, 0xb7, 0xc7, 0x63,
	0x75, 0xdb, 0x43, 0xbb, 0xdd, 0x7e, 0x8d, 0xa6, 0x07, 0x5f, 0xd3, 0x94, 0x44, 0xb3, 0x5b, 0x94,
	0xd5, 0xa4, 0xec, 0xfe, 0x02, 0x04, 0x73, 0xa7, 0x78, 0x6f, 0x91, 0xac, 0x16, 0x79, 0xef, 0xed,
	0xaa, 0xa2, 0x64, 0xee, 0x3a, 0x09, 0x30, 0xe8, 0xd9, 0x04, 0xd9, 0x0d, 0x10, 0x04, 0xb3, 0x6c,
	0x04, 0x59, 0x24, 0xc8, 0x66, 0x16, 0x01, 0xb2, 0x48, 0x66, 0xd3, 0x59, 0x04, 0xc8, 0x22, 0x40,
	0x76, 0xc9, 0xa4, 0xb3, 0x0e, 0xf2, 0x0f, 0x04, 0x48, 0x50, 0xaf, 0xcb, 0xba, 0xa4, 0x6c, 0x39,
	0xdd, 0x2b, 0x5d, 0x9e, 0xdf, 0x39, 0xa7, 0x4e, 0x55, 0x9d, 0x3a, 0xe7, 0xd4, 0x43, 0xb0, 0xca,
	0x38, 0x46, 0xfd, 0x3e, 0x66, 0x0c, 0x75, 0x30, 0x2b, 0xc5, 0x34, 0xe2, 0xd1, 0xfa, 0x46, 0x27,
	0x8a, 0x3a, 0x3d, 0x7c, 0x57, 0xfe, 0x6a, 0x0d, 0xda, 0x77, 0x03, 0xcc, 0x7c, 0x4a, 0x62, 0x1e,
	0x51, 0xc5, 0xe1, 0xfe, 0xe9, 0x34, 0x38, 0x95, 0x3a, 0xeb, 0x1c, 0x88, 0x5f, 0x4f, 0x07, 0xed,
	0x67, 0x18, 0x05, 0x98, 0x3a, 0x77, 0x60, 0xd9, 0xef, 0x11, 0x1c, 0x72, 0x4f, 0xaa, 0xf5, 0x48,
	0x50, 0xcc, 0x6c, 0x64, 0x36, 0x67, 0x9f, 0x4e, 0x7f, 0xf3, 0xaf, 0xd7, 0xcf, 0x35, 0xf2, 0x0a,
	0x6c, 0x0a, 0xac, 0x16, 0x38, 0xf7, 0x60, 0xc5, 0x70, 0x63, 0xc6, 0x48, 0x14, 0x0a, 0xfe, 0xec,
	0x46, 0x66, 0x73, 0x46, 0xf3, 0x6b, 0x65, 0x4d, 0x85, 0xd6, 0x02, 0x67, 0x13, 0xf2, 0x2c, 0x1a,
	0x50, 0x1f, 0x7b, 0x28, 0x8e, 0x05, 0xf7, 0xd4, 0x46, 0x66, 0x33, 0xaf, 0xb9, 0x73, 0x0a, 0x2a,
	0xc7, 0x71, 0x2d, 0x70, 0x9e, 0x40, 0xfe, 0xf3, 0xa8, 0xe5, 0x91, 0xc0, 0x53, 0xd4, 0x22, 0x08,
	0x3b, 0xb6, 0xd6, 0xde, 0x7f, 0xf2, 0xe0, 0xc1, 0xa3, 0xc7, 0x0f, 0x1e, 0xdc, 0x7b, 0xfc, 0xc1,
	0xe3, 0x7b, 0x3f, 0x7e, 0xf8, 0xf0, 0xfd, 0x47, 0xef, 0x3f, 0x6c, 0xe4, 0x3e, 0x8f, 0x5a, 0xb5,
	0xa0, 0x29, 0x19, 0x2d, 0x49, 0x8e, 0x68, 0x07, 0xf3, 0x62, 0xee, 0x4c, 0xc9, 0x43, 0xc9, 0x28,
	0x7a, 0xaf, 0x44, 0x3c, 0xa1, 0x20, 0x44, 0x7d, 0x5c, 0x5c, 0xdc, 0xc8, 0x6c, 0x2e, 0x98, 0xde,
	0x2b, 0xf0, 0xe3, 0xa8, 0xb5, 0x8f, 0xfa, 0xd8, 0xb9, 0x0c, 0x73, 0x98, 0x62, 0x36, 0xe8, 0xf1,
	0x62, 0x5e, 0xf4, 0x79, 0x2b, 0x73, 0xbf, 0x61, 0x28, 0xce, 0xbb, 0x90, 0xc7, 0x94, 0x46, 0xd4,
	0xd3, 0x33, 0x53, 0x5c, 0xb2, 0x14, 0x2d, 0x4a, 0xa8, 0xae, 0x10, 0x67, 0x1f, 0xa0, 0xe3, 0x7b,
	0x7d, 0xd6, 0xf1, 0x18, 0xf5, 0x8b, 0xdf, 0x88, 0xf1, 0x5e, 0xba, 0xbf, 0x52, 0xaa, 0x56, 0xcc,
	0xdc, 0xd4, 0x59, 0xa7, 0x49, 0xfd, 0xad, 0x2b, 0xe3, 0x14, 0xef, 0x45, 0xc8, 0x62, 0xec, 0x93,
	0x36, 0xc1, 0x41, 0x63, 0xbe, 0xe3, 0x2b, 0xaa, 0xf3, 0x00, 0x56, 0x3b, 0xbe, 0x17, 0x10, 0xea,
	0x91, 0x30, 0xc0, 0xaf, 0xcc, 0xf8, 0xfd, 0x43, 0xc6, 0x1a, 0xea, 0x42, 0xc7, 0xdf, 0x26, 0xb4,
	0x26, 0x70, 0x35, 0x6a, 0x5b, 0xf0, 0xe5, 0xd7, 0x57, 0xbf, 0xcc, 0x7e, 0xf5, 0xf5, 0xd5, 0x2f,
	0xe7, 0xdd, 0xbf, 0xc9, 0x40, 0x5e, 0x38, 0xc7, 0x67, 0xb8, 0x55, 0x3e, 0xa8, 0x7d, 0x82, 0x87,
	0xce, 0x65, 0x98, 0x65, 0x1c, 0xf1, 0x01, 0x93, 0xee, 0x90, 0xdf, 0x9a, 0xba, 0xff, 0xf0, 0x61,
	0x43, 0x93, 0x9c, 0x0d, 0x00, 0xe4, 0xfb, 0xd1, 0x20, 0xe4, 0x66, 0xfe, 0xf3, 0x5b, 0x99, 0x7b,
	0x8d, 0x05, 0x4d, 0xac, 0x05, 0xce, 0x5d, 0x70, 0xe2, 0x41, 0xab, 0x47, 0x58, 0x17, 0x53, 0xaf,
	0x43, 0xa3, 0xc1, 0x68, 0xee, 0x05, 0x67, 0x21, 0x01, 0xab, 0x02, 0xab, 0x05, 0xa2, 0xbd, 0x23,
	0x3c, 0x14, 0x4c, 0xd3, 0x96, 0xd5, 0x33, 0x47, 0x78, 0x58, 0x0b, 0x9c, 0x2b, 0x30, 0x1b, 0x44,
	0x7d, 0x44, 0xc2, 0xe2, 0x8c, 0x35, 0xa8, 0x9a, 0xe6, 0xfe, 0xe1, 0x34, 0x2c, 0x0b, 0xe3, 0x9f,
	0x71, 0x1e, 0x37, 0xf0, 0x17, 0x03, 0xcc, 0xb8, 0x73, 0x1b, 0x96, 0xa8, 0xfa, 0xf4, 0xfa, 0x98,
	0x77, 0x23, 0xe5, 0xd5, 0x46, 0x6d, 0x5e, 0x63, 0x75, 0x09, 0x39, 0x1b, 0x30, 0xdf, 0x8d, 0x18,
	0x97, 0xd3, 0x9f, 0xb5, 0x1a, 0x48, 0xa8, 0xce, 0x05, 0x98, 0x1a, 0xd0, 0x9e, 0xb4, 0xdf, 0x80,
	0x82, 0xe0, 0x3c, 0x81, 0xb9, 0xae, 0x5c, 0x47, 0xac, 0x38, 0xbd, 0x31, 0xb5, 0x99, 0xbb, 0x7f,
	0xad, 0x34, 0x66, 0x49, 0x49, 0xff, 0x55, 0xcb, 0xad, 0x61, 0xd8, 0x9d, 0x2d, 0x00, 0xe1, 0x76,
	0x31, 0xa2, 0xa8, 0xcf, 0x8a, 0x33, 0x52, 0xf8, 0xf2, 0x84, 0xf0, 0xa7, 0x03, 0x4c, 0x87, 0x07,
	0x82, 0xa7, 0xb1, 0xd0, 0xc1, 0x5c, 0x7e, 0x31, 0xe7, 0x43, 0xc8, 0xc5, 0x11, 0x4b, 0x84, 0x67,
	0xcf, 0x16, 0x06, 0xc1, 0xaf, 0xa5, 0x8b, 0x30, 0xdd, 0x8a, 0x82, 0x61, 0x71, 0x6e, 0x23, 0xb3,
	0xb9, 0xa8, 0x3b, 0x23, 0x29, 0xce, 0x5d, 0x28, 0xa0, 0x16, 0x8b, 0x7a, 0x03, 0x8e, 0x3d, 0x4e,
	0xfa, 0x38, 0x1a, 0xf0, 0xe2, 0xbc, 0x35, 0x6c, 0xcb, 0x06, 0x3d, 0x54, 0xe0, 0xfa, 0x0e, 0xe4,
	0x53, 0xdd, 0x13, 0xba, 0xe5, 0x28, 0x66, 0xac, 0x81, 0x92, 0x14, 0x67, 0x1d, 0x66, 0x8e, 0x51,
	0x6f, 0x90, 0x1e, 0x60, 0x45, 0x5a, 0x7f, 0x0a, 0x30, 0xb2, 0xf5, 0x6d, 0x75, 0x2c, 0xa6, 0x74,
	0xb8, 0xbf, 0xc9, 0xc2, 0xca, 0xc8, 0x83, 0x8d, 0x1b, 0xdc, 0x81, 0xe5, 0x17, 0xfb, 0x2f, 0x9a,
	0x3b, 0xdb, 0xa3, 0xf5, 0x6d, 0xab, 0xcd, 0x2b, 0xd0, 0xac, 0xef, 0xdb, 0xb0, 0x44, 0x42, 0x8e,
	0x69, 0x1b, 0xf9, 0xd8, 0x9b, 0xf0, 0x86, 0x7c, 0x82, 0x49, 0xe6, 0x9b, 0x90, 0x53, 0x9e, 0xa5,
	0x38, 0x6d, 0xd7, 0x00, 0x05, 0x48, 0xb6, 0x6b, 0x30, 0x77, 0x8c, 0xa9, 0x08, 0x86, 0x29, 0xc7,
	0x36, 0x44, 0xe7, 0x16, 0xcc, 0xa1, 0x98, 0x78, 0x47, 0x78, 0x28, 0x7d, 0x3b, 0x77, 0x7f, 0xa9,
	0x94, 0x5a, 0x88, 0x8d, 0x59, 0x14, 0x13, 0xb1, 0x20, 0xdf, 0x83, 0x39, 0xed, 0xb5, 0xc5, 0x59,
	0xc9, 0x58, 0x18, 0x9f, 0xf0, 0x86, 0x61, 0x70, 0xde, 0x83, 0x25, 0x1a, 0x0d, 0x38, 0x09, 0x3b,
	0x26, 0xea, 0xce, 0x59, 0x6d, 0x2f, 0x6a, 0x4c, 0x86, 0x5d, 0xf7, 0x5f, 0x32, 0x50, 0x18, 0x29,
	0x62, 0x71, 0x14, 0x32, 0xd9, 0x39, 0xb5, 0xd4, 0x3d, 0x3f, 0x0a, 0x70, 0x6a, 0xed, 0x80, 0x02,
	0x2a, 0x51, 0x80, 0x9d, 0xad, 0x91, 0xfb, 0x67, 0xa5, 0x13, 0x6e, 0x94, 0xc6, 0x55, 0x95, 0xcc,
	0xc7, 0xf8, 0x02, 0x30, 0x6e, 0x38, 0x35, 0xee, 0x86, 0xeb, 0xbb, 0xb0, 0x94, 0x16, 0xfa, 0x6e,
	0x6e, 0xe5, 0xb6, 0x55, 0xc2, 0x2b, 0xd7, 0x77, 0x49, 0x18, 0x94, 0x55, 0x68, 0x62, 0xb2, 0x6b,
	0x18, 0x51, 0xbf, 0xeb, 0xf1, 0x61, 0x3c, 0xde, 0x35, 0x09, 0x1c, 0x0e, 0x63, 0x2c, 0xc2, 0xb9,
	0x66, 0x63, 0x9c, 0x92, 0xb0, 0x93, 0x6a, 0x60, 0x51, 0x41, 0x4d, 0x89, 0xb8, 0x8f, 0x61, 0x7d,
	0xb2, 0x9d, 0x64, 0x28, 0x2f, 0xc1, 0xbc, 0x95, 0x59, 0xa7, 0x36, 0x67, 0x1b, 0x73, 0x4c, 0x65,
	0x53, 0xf7, 0xbf, 0x33, 0xca, 0xc2, 0xfd, 0x88, 0x93, 0xf6, 0xf0, 0x33, 0xc4, 0xfd, 0x6e, 0x10,
	0x75, 0x44, 0xb4, 0xd3, 0x11, 0xdc, 0x36, 0x4e, 0xd3, 0x9c, 0x77, 0x00, 0x50, 0x0f, 0x53, 0xae,
	0xcc, 0xcf, 0x5a, 0x1c, 0x0b, 0x92, 0x2e, 0xad, 0x7f, 0x1f, 0x56, 0x14, 0x53, 0x80, 0x19, 0x27,
	0x21, 0xe2, 0xc2, 0xff, 0xec, 0xcc, 0x5b, 0x90, 0xf0, 0xf6, 0x08, 0x15, 0x41, 0xd0, 0xa7, 0x84,
	0x13, 0x1f, 0xf5, 0xa4, 0xa7, 0xce, 0x9b, 0x20, 0x68, 0xa8, 0x62, 0x16, 0x44, 0x54, 0x90, 0x7e,
	0x6a, 0xf4, 0x48, 0x8a, 0x98, 0x05, 0x14, 0xc7, 0x24, 0x90, 0x9e, 0x99, 0xc4, 0x6e, 0x49, 0x92,
	0x52, 0xf8, 0x15, 0x97, 0x1e, 0x98, 0xcc, 0x9d, 0xa0, 0xb8, 0x1f, 0xa8, 0x15, 0x5b, 0xae, 0x57,
	0x31, 0xdf, 0x23, 0x3e, 0x0e, 0x19, 0x66, 0x62, 0xbd, 0xc8, 0xe1, 0x19, 0xab, 0x43, 0x0c, 0xd1,
	0xfd, 0x23, 0x3d, 0x66, 0x07, 0xc8, 0x3f, 0x42, 0x1d, 0xac, 0xe5, 0xc4, 0xa8, 0xc4, 0x8a, 0x62,
	0x2a, 0x98, 0x64, 0x54, 0x34, 0xbd, 0x16, 0x38, 0xb7, 0x60, 0x51, 0x98, 0xeb, 0xf9, 0x14, 0x23,
	0x8e, 0x83, 0xd4, 0xe0, 0xe5, 0x04, 0x52, 0x51, 0x80, 0x73, 0x1d, 0xe6, 0xa3, 0x93, 0x10, 0xd3,
	0xf1, 0x7a, 0x65, 0x4e, 0x52, 0x6b, 0x81, 0xdb, 0x85, 0x4b, 0x13, 0xa6, 0x27, 0x33, 0xfe, 0x23,
	0x98, 0xeb, 0x29, 0x9a, 0x9c, 0xf0, 0xdc, 0xfd, 0xd5, 0xd2, 0xa4, 0xc5, 0x0d, 0xc3, 0x23, 0xa6,
	0x5b, 0x17, 0x15, 0xb6, 0x3d, 0x9a, 0xe6, 0x86, 0x70, 0x21, 0x69, 0xe9, 0x05, 0xc3, 0xb4, 0x8a,
	0xfa, 0xb8, 0xc9, 0x11, 0x67, 0xc2, 0xc8, 0x53, 0x4b, 0x36, 0xe3, 0x5e, 0xce, 0x55, 0x98, 0xeb,
	0xa0, 0x3e, 0x36, 0x29, 0xda, 0xe0, 0xb3, 0x82, 0x58, 0x0b, 0x9c, 0x35, 0x98, 0x11, 0x4b, 0x99,
	0x15, 0xa7, 0x36, 0xa6, 0x36, 0xf3, 0x0d, 0xf5, 0xc3, 0xfd, 0xe5, 0x34, 0x5c, 0x3b, 0xbd, 0xc1,
	0xa4, 0x7f, 0xdf, 0xb7, 0x61, 0xab, 0x8c, 0x9a, 0x9a, 0x28, 0xa3, 0x7e, 0x62, 0xac, 0x52, 0xf9,
	0xf4, 0x66, 0xe9, 0xcd, 0xc6, 0x94, 0xd4, 0x2f, 0x25, 0xe3, 0x20, 0x70, 0x90, 0xdf, 0x25, 0xf8,
	0x18, 0xf7, 0x45, 0x8d, 0xda, 0xea, 0x45, 0xfe, 0x91, 0x49, 0xae, 0xf7, 0xcf, 0xd2, 0x54, 0xb6,
	0x24, 0x9f, 0x4a, 0xc9, 0xc6, 0x8a, 0xa5, 0x4d, 0x91, 0xd6, 0x3f, 0x81, 0x19, 0x35, 0xfc, 0x57,
	0x85, 0xa3, 0x22, 0x3e, 0xee, 0x6e, 0xb2, 0x44, 0xaa, 0x05, 0xc2, 0x21, 0x25, 0x3c, 0x8a, 0x4e,
	0x89, 0x43, 0x0a, 0xfa, 0x4b, 0x99, 0xf8, 0xfe, 0x2c, 0x03, 0xce, 0x64, 0xb3, 0x22, 0x0f, 0xd9,
	0xdd, 0x18, 0x6b, 0x21, 0x6f, 0x61, 0xb5, 0xc0, 0xb9, 0x3f, 0xd6, 0x67, 0x32, 0xaa, 0xc9, 0x92,
	0xb5, 0x6e, 0xf5, 0x82, 0x08, 0x99, 0x9b, 0x90, 0x1b, 0x84, 0xa2, 0x2d, 0x99, 0xe6, 0xe5, 0x2c,
	0xcc, 0x99, 0x18, 0xa8, 0x00, 0x91, 0xe1, 0xdd, 0x9f, 0xc3, 0x9a, 0x18, 0xb3, 0x6a, 0xa5, 0x8a,
	0x79, 0x25, 0xea, 0xf7, 0x51, 0x18, 0xec, 0x11, 0xc6, 0x45, 0xad, 0xa6, 0xd3, 0x4a, 0x66, 0x6c,
	0xbd, 0xd7, 0x02, 0x61, 0xbc, 0xaf, 0x78, 0xbd, 0x98, 0xe2, 0x36, 0x79, 0x95, 0x4e, 0xa2, 0x1a,
	0x3b, 0x90, 0x90, 0x5b, 0x86, 0x2b, 0xa7, 0xb5, 0x90, 0xb8, 0xda, 0x0d, 0x58, 0x34, 0xca, 0x74,
	0x02, 0x98, 0xda, 0x5c, 0x68, 0xe4, 0x34, 0x4d, 0x24, 0x58, 0x77, 0x13, 0x9c, 0x4a, 0x55, 0x28,
	0xa9, 0xe3, 0x7e, 0x05, 0xf9, 0x5d, 0x1c, 0x54, 0x31, 0x77, 0x1c, 0x98, 0x3e, 0xc2, 0x43, 0xa6,
	0x05, 0xe4, 0xb7, 0xfb, 0xeb, 0x0c, 0xac, 0x4f, 0xb2, 0x26, 0x6d, 0x7d, 0x08, 0xb3, 0x72, 0xb2,
	0x98, 0x5e, 0xb5, 0x3f, 0x28, 0xbd, 0x9e, 0xb9, 0x24, 0xe7, 0xef, 0x10, 0x75, 0x1a, 0x5a, 0x66,
	0xfd, 0x29, 0xcc, 0x1b, 0x9a, 0x08, 0x87, 0xed, 0x68, 0x10, 0xaa, 0xe1, 0x31, 0x71, 0x54, 0x91,
	0xde, 0x58, 0xc3, 0xfc, 0x22, 0x33, 0xd1, 0x97, 0x26, 0xe6, 0xce, 0x5d, 0xab, 0x2f, 0xb2, 0xce,
	0x9b, 0x60, 0x29, 0x7d, 0x82, 0x87, 0x07, 0x88, 0x50, 0xd5, 0xd1, 0xf5, 0xff, 0x07, 0x73, 0x9a,
	0xf0, 0x1d, 0x8b, 0xa9, 0xdb, 0x70, 0x7e, 0xac, 0x91, 0x6d, 0xdc, 0xc3, 0x1c, 0x9f, 0x3a, 0xac,
	0x17, 0x60, 0x6d, 0xdc, 0x22, 0x19, 0x49, 0xfe, 0x62, 0x1a, 0xae, 0x9c, 0x06, 0x24, 0x03, 0x7e,
	0x17, 0x0a, 0xfe, 0x80, 0x52, 0xcf, 0x8f, 0xc2, 0x10, 0xfb, 0x22, 0x09, 0xa9, 0xcd, 0xc6, 0x74,
	0xb2, 0x97, 0x1c, 0x50, 0x5a, 0x19, 0x81, 0x62, 0xc9, 0xf9, 0xfd, 0xc0, 0x13, 0x3b, 0xbc, 0xac,
	0xc5, 0x37, 0xeb, 0xf7, 0xe5, 0x9c, 0x6b, 0x98, 0x61, 0x15, 0x57, 0x6c, 0x58, 0x0c, 0xe3, 0x0d,
	0x58, 0x10, 0x70, 0xbb, 0x37, 0x60, 0x5d, 0x99, 0xe1, 0xa6, 0x93, 0x0c, 0xd7, 0x0f, 0x76, 0x05,
	0x55, 0x44, 0x36, 0x51, 0x94, 0x77, 0x09, 0x67, 0x32, 0xcb, 0x19, 0x8e, 0xb9, 0x0e, 0xe6, 0xcf,
	0x08, 0x67, 0x62, 0x55, 0x0b, 0x86, 0x3e, 0x61, 0x0c, 0x33, 0x99, 0xed, 0x0c, 0x8b, 0x28, 0xcf,
	0xeb, 0x92, 0x2c, 0x56, 0x57, 0x20, 0x87, 0x4b, 0x29, 0x9a, 0xb3, 0xb8, 0x40, 0x01, 0x52, 0xd7,
	0xbb, 0x90, 0xd7, 0x6c, 0x5a, 0xdd, 0xbc, 0xc5, 0xb8, 0xa8, 0x20, 0xad, 0xf1, 0x1d, 0x80, 0xd6,
	0x90, 0x63, 0xe6, 0x51, 0x8c, 0x82, 0xe2, 0x82, 0xdd, 0xac, 0xa4, 0x37, 0x30, 0x0a, 0x84, 0x3e,
	0xc5, 0x74, 0x42, 0x09, 0xe7, 0x38, 0x94, 0xfb, 0xe7, 0x44, 0x9f, 0x84, 0x3e, 0x53, 0x88, 0x58,
	0xa3, 0x3d, 0xd2, 0x27, 0xdc, 0xeb, 0xa3, 0x57, 0x12, 0x90, 0x3b, 0x66, 0xc3, 0x9b, 0x97, 0x58,
	0x5d, 0x43, 0xa2, 0x71, 0x39, 0x4d, 0x84, 0xe3, 0x3e, 0x93, 0xdb, 0xe3, 0xa4, 0x71, 0x41, 0xaf,
	0x09, 0xb2, 0xe3, 0xc2, 0x02, 0x3e, 0x26, 0x7a, 0x12, 0xf3, 0x36, 0x4f, 0x42, 0x16, 0x1e, 0xa7,
	0x1a, 0x5b, 0xb2, 0x70, 0x45, 0x72, 0x7f, 0x0a, 0x4b, 0xca, 0x57, 0x9a, 0x9f, 0xee, 0xa9, 0xf8,
	0x7a, 0x1b, 0x96, 0x98, 0xdf, 0xc5, 0x7d, 0xe4, 0xf9, 0x88, 0xa3, 0x5e, 0xd4, 0x49, 0x07, 0x41,
	0x85, 0x55, 0x14, 0xe4, 0xfe, 0xcf, 0x14, 0x5c, 0x48, 0xcb, 0x27, 0x5e, 0x76, 0x0d, 0xe6, 0x78,
	0x57, 0x8c, 0x1b, 0x4b, 0x29, 0x30, 0x44, 0x51, 0x2a, 0xe9, 0x4f, 0xe3, 0x88, 0x63, 0x95, 0x41,
	0x41, 0xc3, 0x15, 0x83, 0x0a, 0xd3, 0x8c, 0x08, 0xf2, 0x39, 0x39, 0xc6, 0xa9, 0x22, 0x21, 0xaf,
	0xb1, 0xb2, 0x84, 0x9c, 0xc7, 0xb0, 0x16, 0xc5, 0x98, 0xca, 0x22, 0x8b, 0x79, 0x6c, 0xd0, 0xea,
	0x8b, 0x39, 0x48, 0x6f, 0x73, 0x57, 0x47, 0x1c, 0x4d, 0xc3, 0xe0, 0xec, 0xc2, 0x95, 0x98, 0xe2,
	0x18, 0x51, 0x1c, 0x78, 0x22, 0x65, 0xc8, 0xf8, 0xcd, 0x3c, 0xfc, 0x0a, 0xfb, 0x03, 0xa1, 0xc0,
	0x2e, 0xc3, 0xd6, 0x0d, 0x67, 0x33, 0x61, 0xdc, 0xd1, 0x7c, 0x4e, 0x1d, 0x36, 0xc2, 0x28, 0xf4,
	0xde, 0xa8, 0xcb, 0xae, 0xdb, 0xae, 0x86, 0x51, 0x78, 0xf0, 0x7a, 0x75, 0x77, 0xa1, 0x10, 0x60,
	0x14, 0xc8, 0xec, 0x41, 0x31, 0xa7, 0x04, 0xb3, 0xd4, 0xee, 0x62, 0xd9, 0xa0, 0x0d, 0x05, 0x3a,
	0xbb, 0x70, 0xd5, 0x1a, 0x00, 0x91, 0x70, 0x02, 0x2f, 0x1a, 0x70, 0x8f, 0x84, 0xde, 0x17, 0x03,
	0x3c, 0xc0, 0xa9, 0x2d, 0xe6, 0xa5, 0x11, 0xab, 0x48, 0x41, 0xc1, 0xf3, 0x01, 0xaf, 0x85, 0x9f,
	0x0a, 0x36, 0x51, 0x27, 0xc9, 0x53, 0x14, 0x26, 0x17, 0x40, 0x92, 0x6f, 0x15, 0xcd, 0xfd, 0xeb,
	0x8c, 0x4a, 0x56, 0xe5, 0x7a, 0x39, 0x08, 0x76, 0x29, 0x4e, 0x2a, 0xc3, 0x33, 0x0a, 0x4a, 0x11,
	0x16, 0x48, 0xec, 0xc9, 0xf3, 0x08, 0x3f, 0x35, 0xef, 0xf3, 0x24, 0x3e, 0x90, 0x54, 0xe1, 0xdc,
	0xba, 0x88, 0x1c, 0xab, 0x07, 0x47, 0x64, 0x91, 0x86, 0x19, 0x8f, 0x28, 0xf6, 0x64, 0xf9, 0x4f,
	0x87, 0x6a, 0xe3, 0x34, 0x6d, 0x85, 0xdd, 0x82, 0xc4, 0x2b, 0x0a, 0x16, 0xdb, 0x27, 0xf7, 0x57,
	0x19, 0x95, 0xfe, 0xc6, 0x6d, 0x4e, 0x7c, 0xd7, 0xaa, 0x94, 0x32, 0x13, 0x95, 0xd2, 0x16, 0x5c,
	0x88, 0x07, 0xd4, 0xef, 0x22, 0x86, 0x3d, 0x45, 0xf2, 0x02, 0xcc, 0x11, 0xe9, 0xa5, 0x0e, 0xe4,
	0xd6, 0x0c, 0x4f, 0x43, 0xb2, 0x6c, 0x4b, 0x0e, 0xb9, 0x28, 0x28, 0x0a, 0x99, 0xee, 0x4f, 0x32,
	0x28, 0x9a, 0xe8, 0xde, 0x82, 0x55, 0xb5, 0x9c, 0xaa, 0x98, 0xd7, 0x0e, 0xf6, 0x22, 0x5f, 0xed,
	0x11, 0x0a, 0x30, 0x45, 0x62, 0x15, 0xfd, 0xe7, 0x1a, 0xe2, 0xd3, 0xfd, 0x6d, 0x06, 0x96, 0x2b,
	0x23, 0x8e, 0x5a, 0xd8, 0x8e, 0x9c, 0x35, 0xc8, 0x92, 0x38, 0xb5, 0xd8, 0xb2, 0x24, 0x16, 0xfb,
	0x8b, 0x1e, 0xe2, 0x84, 0x0f, 0x02, 0x95, 0x72, 0xb2, 0x66, 0x98, 0x0d, 0x55, 0x0c, 0x73, 0x2f,
	0x0a, 0x3b, 0x8a, 0x65, 0xca, 0x62, 0x19, 0x91, 0x85, 0xe1, 0x7a, 0x80, 0x53, 0x63, 0x6b, 0x88,
	0x22, 0xc6, 0x48, 0xff, 0x4e, 0x1d, 0x14, 0x29, 0x92, 0xc8, 0x85, 0x3e, 0xe1, 0x43, 0xe9, 0xec,
	0x49, 0x2e, 0x14, 0x14, 0x77, 0x07, 0x2e, 0x9f, 0xd2, 0xdd, 0x64, 0x1a, 0x7e, 0x08, 0x33, 0x24,
	0x6c, 0x47, 0x26, 0x03, 0x17, 0x4a, 0x63, 0x3d, 0x6e, 0x28, 0xd8, 0xfd, 0x19, 0x5c, 0xd4, 0x41,
	0x68, 0xc8, 0x38, 0xee, 0xcb, 0x38, 0xd4, 0x94, 0x71, 0xca, 0xd9, 0x80, 0x85, 0x8e, 0xef, 0x9d,
	0x52, 0x35, 0xcd, 0x75, 0x7c, 0x75, 0xfc, 0x79, 0x03, 0x16, 0x74, 0xbc, 0x3b, 0x3a, 0x4e, 0xe5,
	0xe4, 0x79, 0x45, 0xfe, 0xe4, 0x78, 0x94, 0x69, 0xab, 0x98, 0x5b, 0x4d, 0xb8, 0xbf, 0x4d, 0x32,
	0x6d, 0x1a, 0x48, 0x3a, 0x70, 0x76, 0xeb, 0xb2, 0xa6, 0x47, 0x9c, 0x8d, 0x37, 0x2e, 0x6b, 0x5c,
	0xf6, 0xc9, 0xb1, 0x48, 0x6a, 0x2a, 0xd6, 0x79, 0x9f, 0x47, 0x2d, 0x96, 0x5a, 0x05, 0xa0, 0x80,
	0x8f, 0xa3, 0x96, 0x4c, 0x6a, 0x43, 0x82, 0x7b, 0x01, 0x09, 0x3b, 0x8a, 0xd1, 0x0e, 0x73, 0x8b,
	0x06, 0x32, 0xac, 0x03, 0x86, 0xa9, 0x39, 0x49, 0x66, 0xa9, 0x80, 0xb6, 0x28, 0x20, 0x7d, 0x8a,
	0xcc, 0x9c, 0x47, 0xb0, 0x26, 0x37, 0x14, 0x0c, 0xd3, 0x63, 0x5b, 0xc2, 0x0e, 0x5b, 0x8e, 0xe0,
	0x68, 0x4a, 0x86, 0x44, 0x6e, 0x03, 0xe6, 0x59, 0xe4, 0x8b, 0xd2, 0x23, 0x1d, 0xa3, 0x12, 0xaa,
	0x5c, 0xb6, 0xfa, 0xdb, 0xe3, 0x91, 0x27, 0x8a, 0x5f, 0x14, 0xa4, 0x22, 0x52, 0xc1, 0xe0, 0x87,
	0xd1, 0x0b, 0x89, 0x8a, 0x08, 0x98, 0xc8, 0x08, 0x02, 0x09, 0x3b, 0xa9, 0x90, 0xb4, 0x6c, 0xd0,
	0x3d, 0x05, 0x3a, 0x3f, 0x82, 0x65, 0x91, 0x93, 0x71, 0x0b, 0xf9, 0x47, 0x3a, 0xe6, 0x81, 0xc5,
	0xbf, 0x94, 0x80, 0x2a, 0xd0, 0xbd, 0x0b, 0x79, 0x1d, 0x9c, 0x3c, 0xb5, 0x81, 0xc9, 0xd9, 0x03,
	0xa3, 0xa1, 0x3d, 0xb9, 0x53, 0xb8, 0x09, 0xb9, 0x5e, 0xd4, 0x89, 0x4c, 0x24, 0x5d, 0xb4, 0x67,
	0x45, 0x02, 0x4a, 0xe3, 0x3b, 0xa0, 0x7e, 0xa9, 0x29, 0xc9, 0xdb, 0x11, 0x4c, 0xd2, 0xc5, 0x7c,
	0xb8, 0xbf, 0xd0, 0xc7, 0xa8, 0xe5, 0x7a, 0x13, 0x87, 0xc1, 0x4e, 0x5f, 0xc7, 0x89, 0x37, 0x06,
	0xcf, 0xf7, 0x60, 0x09, 0x0b, 0x46, 0x79, 0x98, 0x3d, 0x71, 0x20, 0xb1, 0x28, 0xb1, 0x3a, 0xeb,
	0xc8, 0x33, 0x89, 0x5b, 0xa0, 0x7e, 0x7b, 0xed, 0x88, 0xf6, 0x11, 0x4f, 0x5f, 0x04, 0x48, 0x64,
	0x57, 0x02, 0xce, 0xef, 0xc3, 0x6a, 0x8c, 0x29, 0x8b, 0x42, 0x24, 0x8b, 0x7e, 0x8f, 0x47, 0x47,
	0x38, 0x34, 0xdb, 0xb8, 0x3b, 0xa5, 0x31, 0x1b, 0x4b, 0x07, 0x8a, 0x57, 0x6c, 0x06, 0x1a, 0x38,
	0xee, 0x21, 0x5f, 0x26, 0xac, 0x43, 0x21, 0xd4, 0x58, 0x89, 0x47, 0xa0, 0xa4, 0x30, 0xb9, 0xce,
	0xd4, 0x85, 0x44, 0xc7, 0x4f, 0x39, 0xd0, 0xbc, 0x22, 0x57, 0x7d, 0xe7, 0xc7, 0x30, 0xab, 0xdb,
	0x9c, 0x93, 0x6d, 0xde, 0x98, 0x68, 0x73, 0xa2, 0x21, 0x2d, 0xb0, 0xfe, 0x33, 0x28, 0x8c, 0x63,
	0x62, 0xf4, 0x25, 0x3a, 0x79, 0xfe, 0xb8, 0x20, 0xe9, 0xe6, 0x38, 0x51, 0x31, 0x4d, 0x1e, 0x67,
	0x29, 0x69, 0xb5, 0x63, 0x6c, 0xc1, 0xe5, 0x37, 0xf4, 0xf7, 0xcc, 0xf9, 0x4a, 0x9b, 0x92, 0x3d,
	0xd5, 0x14, 0xf7, 0x11, 0x5c, 0x1c, 0xeb, 0xef, 0xeb, 0x12, 0x52, 0xde, 0x4e, 0x48, 0xee, 0x5f,
	0x65, 0xd4, 0x59, 0x85, 0xdc, 0xcd, 0x49, 0xb9, 0x43, 0xdc, 0x8f, 0x7b, 0x22, 0xf4, 0xbe, 0x71,
	0xc7, 0xf8, 0x7f, 0x71, 0xa2, 0x77, 0x00, 0x14, 0x6f, 0x0f, 0x85, 0x1d, 0x75, 0x7c, 0x90, 0x14,
	0x9a, 0x82, 0xbe, 0x87, 0xc2, 0xce, 0x84, 0xa7, 0x4d, 0x5b, 0x6c, 0xb6, 0xa7, 0xb9, 0x7f, 0x9c,
	0x51, 0x87, 0x1d, 0x93, 0x16, 0xbf, 0x55, 0x8f, 0xc5, 0xc2, 0xe6, 0x5a, 0xc0, 0xc3, 0xaf, 0x08,
	0xe3, 0x4c, 0x9a, 0x6e, 0xb6, 0x7c, 0x4b, 0x06, 0xdc, 0x91, 0x98, 0x08, 0x47, 0x86, 0x92, 0x3a,
	0x2f, 0x4e, 0xa8, 0xee, 0xbf, 0x65, 0xcc, 0xd8, 0x57, 0x29, 0x0a, 0x79, 0x75, 0x80, 0x19, 0x3f,
	0x40, 0x62, 0x0f, 0x70, 0xff, 0xec, 0x63, 0x97, 0xf4, 0x19, 0x58, 0xf6, 0xf4, 0x33, 0xb0, 0x3b,
	0xb0, 0x1c, 0x4b, 0x85, 0x22, 0xdc, 0x75, 0x44, 0x23, 0xa9, 0x51, 0xcc, 0x2b, 0xf0, 0x30, 0x92,
	0xed, 0x8b, 0xf0, 0x18, 0xa0, 0xa1, 0xe4, 0xc5, 0xaf, 0x62, 0xa2, 0x2a, 0xb3, 0xd4, 0x78, 0x16,
	0x04, 0x7e, 0x18, 0xed, 0x24, 0xa8, 0xa8, 0xd3, 0x90, 0xac, 0xf8, 0x65, 0x40, 0x37, 0x7c, 0x9a,
	0xe6, 0x76, 0xe1, 0xfa, 0x6b, 0x3a, 0xf8, 0x76, 0x55, 0xcf, 0x26, 0x2c, 0x69, 0xfb, 0xa5, 0xf1,
	0xba, 0x56, 0x9f, 0xd9, 0xca, 0xdc, 0x33, 0xb6, 0x57, 0x15, 0xdd, 0xed, 0xc2, 0xb5, 0x4a, 0xb5,
	0xa2, 0xd2, 0x61, 0x9d, 0x75, 0xbc, 0x2a, 0xe6, 0xfa, 0x70, 0x56, 0x15, 0x41, 0x67, 0x9e, 0x35,
	0x8e, 0x8e, 0x35, 0xb3, 0x13, 0xc7, 0x9a, 0xea, 0xf6, 0x2c, 0xf3, 0xd5, 0xd7, 0x57, 0xbf, 0x9c,
	0x76, 0x7f, 0xb5, 0x08, 0xb7, 0xde, 0xdc, 0x94, 0x97, 0x74, 0xee, 0x1e, 0x38, 0x38, 0xa9, 0xd6,
	0x62, 0x8a, 0x7d, 0x79, 0x12, 0x99, 0xb8, 0xd6, 0x8a, 0x06, 0xb7, 0x13, 0x4c, 0x78, 0xb3, 0xb9,
	0x6c, 0x9b, 0x58, 0xb5, 0x39, 0x8d, 0xc8, 0x10, 0x72, 0x0b, 0x16, 0xed, 0xb8, 0x99, 0x72, 0xb1,
	0x9c, 0x15, 0x08, 0x9d, 0x7b, 0xb0, 0x42, 0x98, 0x17, 0xd3, 0xa8, 0x4d, 0x7a, 0xd8, 0x94, 0xbe,
	0xf6, 0x99, 0xef, 0x32, 0x61, 0x07, 0x0a, 0xd5, 0x15, 0xf0, 0x03, 0x58, 0x25, 0xcc, 0x23, 0xe1,
	0x31, 0x0e, 0x79, 0x44, 0x87, 0x46, 0x66, 0xc6, 0x92, 0x59, 0x21, 0xac, 0x66, 0x70, 0x2d, 0xb5,
	0x09, 0x79, 0xc2, 0xbc, 0x63, 0xe4, 0x7b, 0x2d, 0x14, 0x86, 0x58, 0xdd, 0x42, 0x18, 0xfe, 0x1c,
	0x61, 0x2f, 0x91, 0xff, 0x54, 0x02, 0x9a, 0xd3, 0x1f, 0xb6, 0x30, 0xf5, 0x7c, 0xd4, 0x56, 0x7b,
	0x02, 0x8b, 0xb3, 0x22, 0x90, 0x0a, 0x6a, 0x1b, 0xdb, 0x99, 0xdf, 0x8d, 0xa2, 0x9e, 0xa7, 0x7b,
	0x2f, 0xb3, 0xaf, 0x65, 0x7b, 0x53, 0xa2, 0x7a, 0x06, 0xc4, 0xb2, 0x20, 0xcc, 0x93, 0x7b, 0x5a,
	0x1c, 0xc8, 0xc4, 0x6b, 0x58, 0x17, 0x08, 0xdb, 0x53, 0x64, 0x91, 0x73, 0x89, 0xdc, 0x9d, 0x31,
	0x9f, 0x92, 0x16, 0x0e, 0x64, 0xce, 0x35, 0x7c, 0x8b, 0x44, 0x6c, 0xcb, 0x34, 0x22, 0xbc, 0x46,
	0x2f, 0xa7, 0x54, 0xbe, 0x35, 0x44, 0xe7, 0x31, 0x9c, 0x27, 0xcc, 0x6b, 0x53, 0x8c, 0x3d, 0x4e,
	0x09, 0x1a, 0x59, 0x99, 0xb7, 0x54, 0x3a, 0x84, 0x89, 0x82, 0xff, 0x50, 0x30, 0x18, 0x43, 0x9f,
	0xc0, 0x79, 0x4b, 0xca, 0x5a, 0x6f, 0x4b, 0xf6, 0x56, 0xb1, 0x6d, 0xc4, 0xac, 0x25, 0x77, 0x07,
	0x96, 0x45, 0x17, 0xa3, 0x13, 0xef, 0x98, 0x44, 0x3d, 0x1c, 0xfa, 0xb8, 0xb8, 0x6c, 0x35, 0x96,
	0x27, 0x6c, 0x2f, 0x3a, 0x79, 0xa9, 0x21, 0xe7, 0xc7, 0x70, 0x81, 0x30, 0x63, 0x95, 0x2c, 0x31,
	0x70, 0xe0, 0x05, 0xd1, 0x49, 0x58, 0x2c, 0x58, 0x42, 0xab, 0x84, 0x69, 0xc3, 0xf6, 0x24, 0xc7,
	0x76, 0x74, 0x12, 0x6a, 0x3f, 0xf0, 0xa3, 0x7e, 0x7f, 0x10, 0x12, 0x3e, 0x34, 0xf3, 0xba, 0x92,
	0xf6, 0x83, 0x8a, 0xc1, 0xf5, 0xec, 0x2a, 0xf3, 0x38, 0x45, 0x01, 0x36, 0x12, 0x4e, 0xda, 0xbc,
	0x43, 0x81, 0x69, 0xee, 0x47, 0xb0, 0x96, 0xb0, 0xda, 0xa3, 0xb0, 0x6a, 0x17, 0x7b, 0x5c, 0x0b,
	0x58, 0x83, 0xe0, 0x82, 0xb9, 0x7f, 0x26, 0x41, 0x71, 0x2d, 0x75, 0x2f, 0x62, 0xc8, 0xc2, 0x7e,
	0x36, 0x60, 0x31, 0x0e, 0xe5, 0xdb, 0x05, 0x1c, 0x06, 0xea, 0x00, 0xf4, 0xbc, 0xc5, 0xbd, 0x32,
	0x62, 0xd8, 0x09, 0x03, 0xb1, 0x09, 0x95, 0x57, 0x23, 0x03, 0x4a, 0x71, 0xe8, 0x0f, 0x8b, 0x17,
	0xec, 0xb8, 0x6d, 0xa8, 0xea, 0xbe, 0x4c, 0xc4, 0xe6, 0x1e, 0x3e, 0xc6, 0xbd, 0xe2, 0xc5, 0xf4,
	0x7d, 0x19, 0x46, 0xfd, 0x3d, 0x41, 0x17, 0x2b, 0xb4, 0x4d, 0x89, 0x68, 0x56, 0x79, 0x44, 0xd1,
	0x2e, 0x81, 0x14, 0x52, 0x31, 0xae, 0x60, 0xe6, 0x47, 0x5e, 0x56, 0x08, 0x6b, 0xa5, 0xa5, 0x97,
	0x6c, 0x57, 0xd0, 0x2c, 0x15, 0xcd, 0x21, 0x6d, 0x7d, 0x22, 0xbd, 0x4f, 0xb6, 0xd9, 0x19, 0x20,
	0x1a, 0x78, 0x38, 0x44, 0xad, 0x1e, 0x0e, 0x8a, 0x97, 0xd3, 0x73, 0xdb, 0x4c, 0x38, 0x76, 0x14,
	0x83, 0x89, 0x0a, 0xdd, 0x28, 0xc4, 0xde, 0x31, 0xa6, 0xf2, 0x91, 0x41, 0xf1, 0xca, 0x58, 0x54,
	0x10, 0xe8, 0x4b, 0x0d, 0x3a, 0x1f, 0xc1, 0xba, 0x98, 0xd7, 0x93, 0xc8, 0x6b, 0x23, 0x9f, 0x47,
	0xd4, 0x43, 0x03, 0xde, 0x4d, 0x1a, 0xbc, 0x6a, 0x89, 0x5e, 0x20, 0xec, 0xf0, 0x24, 0xda, 0x95,
	0x5c, 0xe5, 0x01, 0xef, 0x9a, 0x36, 0x7f, 0x02, 0x17, 0x2d, 0x71, 0x2d, 0xa9, 0x7a, 0x7a, 0xcd,
	0xea, 0xe9, 0x1a, 0x37, 0xc2, 0x5a, 0x50, 0x76, 0xf5, 0x43, 0xb8, 0x68, 0x5b, 0xeb, 0x5b, 0xc3,
	0x74, 0xdd, 0x12, 0x3e, 0x1f, 0x8f, 0x8c, 0xf6, 0x47, 0x03, 0x75, 0x1d, 0xe6, 0x95, 0x34, 0x09,
	0x8a, 0x37, 0xec, 0xb3, 0x3e, 0x49, 0xad, 0x49, 0x3f, 0x4c, 0xc6, 0x83, 0x04, 0x38, 0xe4, 0xa4,
	0x3d, 0x14, 0xa5, 0xbe, 0x9b, 0x5e, 0xc6, 0x07, 0x8a, 0x3d, 0xc1, 0x53, 0x99, 0xe1, 0x03, 0x38,
	0x9f, 0xd4, 0x17, 0x56, 0xdd, 0xc6, 0x9c, 0x75, 0x9d, 0xcc, 0x49, 0xc0, 0xf4, 0xad, 0x60, 0xf2,
	0xdb, 0xfd, 0x2a, 0x6b, 0x55, 0x25, 0xb6, 0xd4, 0x28, 0x8b, 0xfc, 0x7f, 0x58, 0x61, 0x03, 0xdf,
	0xc7, 0x38, 0xc0, 0x62, 0x93, 0x10, 0x1d, 0x0d, 0x62, 0xb3, 0x3b, 0xbd, 0x5d, 0x7a, 0xb3, 0x6c,
	0xaa, 0x5e, 0x2e, 0x24, 0x5a, 0xf6, 0x94, 0x12, 0xe7, 0x01, 0x5c, 0x68, 0x23, 0xd2, 0x4b, 0xd4,
	0x7a, 0x89, 0x99, 0x59, 0x69, 0xe6, 0x9a, 0x42, 0x15, 0x7b, 0x53, 0x63, 0xeb, 0x2f, 0x21, 0x67,
	0xa9, 0x3d, 0x33, 0xb1, 0x8e, 0x67, 0xaa, 0xec, 0x6b, 0x32, 0x95, 0x7b, 0x64, 0xc6, 0xaf, 0xd2,
	0xc5, 0xfe, 0xd1, 0xae, 0x5c, 0x21, 0xac, 0x4b, 0x62, 0xa1, 0x21, 0xd9, 0x23, 0xe1, 0x36, 0x4f,
	0x35, 0x93, 0x33, 0x5b, 0x24, 0xdc, 0xe6, 0xf6, 0x66, 0x8a, 0x92, 0x4e, 0x97, 0xa7, 0x6e, 0xa4,
	0x8c, 0x8e, 0x86, 0x40, 0xdc, 0x2f, 0xcc, 0xb0, 0x8f, 0x35, 0xe6, 0xd9, 0x67, 0x89, 0x72, 0xc0,
	0x18, 0x4b, 0x1d, 0xed, 0x1b, 0xa2, 0xd8, 0x19, 0xca, 0x53, 0x7e, 0xaf, 0x9d, 0x08, 0xa7, 0x0a,
	0xc2, 0x65, 0x89, 0x8e, 0x34, 0xbb, 0x7f, 0x99, 0x85, 0xcb, 0xaa, 0xcd, 0x3a, 0xeb, 0xd4, 0x11,
	0xe3, 0x62, 0xf3, 0xca, 0xb7, 0x09, 0xc5, 0xc2, 0xd9, 0x87, 0x4e, 0x09, 0x0a, 0x7d, 0x49, 0x1d,
	0xbd, 0xee, 0x49, 0x55, 0xd0, 0x4b, 0x0a, 0x35, 0x2f, 0x7b, 0x9c, 0x07, 0x30, 0x15, 0x10, 0xaa,
	0x2f, 0xe3, 0xdd, 0xd2, 0x1b, 0x54, 0x97, 0x9a, 0x83, 0x56, 0xb5, 0xd2, 0x10, 0xec, 0xeb, 0x7f,
	0x9e, 0x81, 0x19, 0xf9, 0x53, 0x6c, 0x8e, 0x4e, 0x6f, 0x68, 0x3e, 0x30, 0x4d, 0x98, 0x1b, 0x85,
	0xec, 0xc4, 0x8d, 0xc2, 0x05, 0x98, 0x6a, 0x45, 0xaf, 0xd2, 0x8f, 0x64, 0x5a, 0xd1, 0x2b, 0x31,
	0x57, 0xe6, 0x12, 0xa7, 0x47, 0xc2, 0xf4, 0xa1, 0x98, 0xb9, 0xca, 0xd9, 0x23, 0x21, 0x16, 0xad,
	0x77, 0x7c, 0xaf, 0x45, 0x42, 0x44, 0x87, 0xa9, 0x03, 0x9c, 0xf9, 0x8e, 0xff, 0x54, 0x52, 0xdd,
	0x0a, 0xfc, 0xe0, 0x0d, 0x9d, 0xf2, 0xde, 0xaa, 0x86, 0x74, 0xeb, 0xb0, 0x99, 0x28, 0x51, 0x0f,
	0x2d, 0x3e, 0x8e, 0x5a, 0xfa, 0x11, 0xc5, 0x6e, 0x44, 0x4f, 0x10, 0x0d, 0xac, 0x1b, 0xa8, 0xb3,
	0x46, 0xc4, 0xad, 0xc2, 0xcd, 0xf1, 0xea, 0xef, 0x40, 0x1f, 0xba, 0x1d, 0xd2, 0x01, 0xe3, 0x9e,
	0x79, 0x8d, 0x72, 0xd6, 0xdd, 0xf6, 0xaf, 0xb3, 0xf0, 0xc3, 0xb3, 0x34, 0x69, 0xb3, 0xca, 0xb0,
	0xde, 0x45, 0xa2, 0x86, 0x23, 0x11, 0xf5, 0x92, 0x63, 0xc0, 0x2e, 0x61, 0x62, 0x18, 0x52, 0xce,
	0x79, 0xb1, 0x8b, 0xd8, 0x81, 0x60, 0x33, 0x9a, 0x9e, 0x29, 0x26, 0x67, 0x17, 0xae, 0x0a, 0x15,
	0x61, 0xe4, 0x51, 0xec, 0xe3, 0x90, 0x7b, 0xa2, 0x7c, 0x3e, 0x89, 0x68, 0xe0, 0x51, 0xcc, 0xf0,
	0xd8, 0x56, 0xe6, 0x52, 0x17, 0xb1, 0xfd, 0xa8, 0x21, 0x19, 0x0f, 0x34, 0x5f, 0x43, 0xb2, 0xe9,
	0x72, 0xe2, 0x04, 0xf5, 0x7a, 0x98, 0x7b, 0x3e, 0x62, 0x5d, 0x8f, 0x0b, 0x5b, 0xb1, 0x3a, 0x5a,
	0xb4, 0x52, 0xce, 0x67, 0x92, 0xa5, 0x82, 0x58, 0xf7, 0x50, 0x31, 0x08, 0xf7, 0x96, 0x17, 0xf2,
	0xa8, 0xd7, 0x4b, 0x84, 0xec, 0x03, 0xa3, 0x25, 0x81, 0x96, 0x7b, 0x3d, 0xcd, 0xef, 0xfe, 0x67,
	0x06, 0xae, 0xaa, 0x99, 0x7b, 0xa6, 0x6b, 0x93, 0x97, 0xc8, 0x6f, 0xaa, 0xf7, 0x28, 0x5d, 0x14,
	0x76, 0xde, 0xe2, 0x6e, 0x7a, 0xb4, 0x13, 0xcd, 0x4e, 0xee, 0x44, 0x1f, 0xc0, 0x2a, 0x95, 0x06,
	0x1d, 0x23, 0x5f, 0x54, 0x1f, 0x8c, 0x23, 0xca, 0xd3, 0x87, 0x5d, 0x2b, 0x92, 0xe1, 0xa5, 0xc4,
	0x9b, 0x12, 0xd6, 0xc5, 0xab, 0x2a, 0x6c, 0xbc, 0x30, 0x3a, 0x49, 0x95, 0xd2, 0x39, 0xc2, 0x54,
	0x5d, 0xb3, 0x1f, 0x9d, 0x88, 0xfe, 0x8e, 0x38, 0xdb, 0x03, 0x3e, 0xa0, 0x38, 0x55, 0x43, 0x2f,
	0x19, 0xe6, 0x5d, 0x89, 0xb9, 0x3f, 0x35, 0xd1, 0xa1, 0x2a, 0xdf, 0x7e, 0xf1, 0x10, 0x53, 0x53,
	0x93, 0x91, 0xf0, 0xe8, 0x4c, 0x7f, 0xfa, 0xb9, 0x59, 0x2c, 0xa7, 0x8a, 0x8f, 0x9c, 0xa9, 0x08,
	0xd3, 0xf1, 0xc9, 0xd8, 0xde, 0x5c, 0x52, 0x44, 0x0b, 0x21, 0x7e, 0x15, 0x85, 0x63, 0xc3, 0x65,
	0x88, 0xee, 0x1f, 0x4c, 0xa9, 0x37, 0x1c, 0xd5, 0x4a, 0x43, 0xbd, 0x29, 0x92, 0x07, 0xc0, 0x97,
	0xd3, 0x6b, 0x66, 0x6a, 0x33, 0x6f, 0xc5, 0x8f, 0x8f, 0x60, 0x56, 0xbf, 0xc8, 0xcb, 0xca, 0x77,
	0x8f, 0x1b, 0xa5, 0x09, 0x05, 0x25, 0xfd, 0xad, 0x9e, 0xe7, 0x6d, 0xcd, 0x36, 0xca, 0xfb, 0xdb,
	0xcf, 0xeb, 0x0d, 0x2d, 0xe7, 0xec, 0xc0, 0x7c, 0x1b, 0xf5, 0x7a, 0x2d, 0xe4, 0x1f, 0xc9, 0xa9,
	0x79, 0x1b, 0x1d, 0x73, 0xdb, 0xb5, 0x66, 0xa5, 0xdc, 0xd8, 0x6e, 0x24, 0xa2, 0xce, 0x6d, 0x58,
	0x32, 0xaf, 0x65, 0xbd, 0x36, 0xc1, 0xbd, 0xb4, 0xeb, 0xe5, 0x0d, 0xb6, 0x2b, 0x20, 0x11, 0xc3,
	0x4e, 0x70, 0x0b, 0xc5, 0x44, 0x3d, 0xba, 0x4b, 0x45, 0xa7, 0x9c, 0x42, 0xe4, 0xeb, 0x35, 0x37,
	0x86, 0x7c, 0xaa, 0x65, 0x07, 0x40, 0xdb, 0x5f, 0x38, 0xe7, 0xe4, 0xc0, 0xd8, 0x51, 0xc8, 0x38,
	0x0e, 0x2c, 0x55, 0xf6, 0x6a, 0x3b, 0xfb, 0x87, 0x5e, 0xf3, 0x70, 0xa7, 0x5c, 0xaf, 0x6d, 0x17,
	0xb2, 0xce, 0x25, 0x38, 0x7f, 0xd0, 0x78, 0x7e, 0xf8, 0xfc, 0xe9, 0x8b, 0x5d, 0x6f, 0xb7, 0xb6,
	0xb3, 0xb7, 0xed, 0xbd, 0xa8, 0xed, 0x1f, 0x3e, 0x7a, 0x50, 0x98, 0x72, 0x2e, 0xc2, 0xea, 0x67,
	0x3b, 0x4f, 0xcb, 0x07, 0x35, 0xef, 0xa0, 0xdc, 0x28, 0xd7, 0x0d, 0x30, 0xed, 0xfe, 0x57, 0x46,
	0x6d, 0xa9, 0xd3, 0x31, 0x51, 0xbf, 0x83, 0x53, 0xa6, 0x38, 0x1f, 0xc1, 0x1c, 0x0e, 0xd5, 0x5d,
	0x8d, 0xaa, 0x12, 0x7e, 0x58, 0x3a, 0x43, 0xa4, 0xb4, 0x13, 0x72, 0x3a, 0x6c, 0x18, 0xb1, 0xf5,
	0x5f, 0x66, 0x60, 0x46, 0x92, 0x4e, 0x79, 0x25, 0x97, 0x79, 0xeb, 0x57, 0x72, 0xd9, 0xd7, 0xbc,
	0x92, 0xbb, 0x03, 0x73, 0xfa, 0x51, 0x9a, 0x9c, 0xd1, 0xdc, 0x7d, 0x67, 0x72, 0x46, 0x1b, 0x86,
	0xc5, 0xfd, 0xbb, 0x0c, 0xb8, 0x93, 0xe6, 0x57, 0xe4, 0xcb, 0xe3, 0x3a, 0xeb, 0x98, 0x4e, 0x57,
	0xc6, 0x3b, 0xfd, 0x6e, 0xe9, 0x6c, 0xa9, 0xf1, 0x7e, 0xbf, 0x34, 0xdd, 0xbe, 0x0e, 0xf3, 0xc9,
	0xf9, 0x54, 0xea, 0x08, 0xbd, 0xaf, 0x8f, 0xa6, 0xac, 0x3e, 0x64, 0xcf, 0xee, 0x43, 0xd5, 0xca,
	0x41, 0xa7, 0xcf, 0xc0, 0x5b, 0x26, 0xb3, 0x8f, 0xe1, 0xf6, 0xd9, 0xbd, 0x7a, 0x4b, 0x5d, 0xff,
	0x98, 0x85, 0xd5, 0x44, 0x59, 0x13, 0xf3, 0xe7, 0xb1, 0xba, 0xb9, 0x7d, 0x08, 0x73, 0x51, 0x6c,
	0x2e, 0xe8, 0xa7, 0x36, 0x97, 0xf4, 0x63, 0xd3, 0x31, 0xb6, 0x92, 0xfa, 0xdb, 0x30, 0xbc, 0x4e,
	0x3d, 0x79, 0x2d, 0x2e, 0x46, 0x8e, 0x8a, 0x00, 0x6d, 0x1e, 0x0a, 0xde, 0x38, 0x55, 0x81, 0x7e,
	0x20, 0xdd, 0x10, 0x9c, 0xe6, 0x29, 0xb9, 0xe8, 0x84, 0x94, 0x5c, 0xff, 0x08, 0x16, 0x6d, 0x06,
	0x51, 0x6f, 0xf4, 0xa2, 0x93, 0x62, 0x66, 0x23, 0x9b, 0x4c, 0x86, 0x20, 0x88, 0x70, 0xd6, 0x25,
	0x9d, 0x6e, 0x31, 0x6b, 0x01, 0x92, 0xe2, 0x86, 0x30, 0xab, 0x9a, 0x72, 0x8a, 0xb0, 0xb6, 0xff,
	0xfc, 0xb0, 0xb6, 0xfb, 0x7b, 0xde, 0x8b, 0xe6, 0x4e, 0xc3, 0x6b, 0xee, 0x34, 0x9b, 0xb5, 0xe7,
	0xfb, 0xcd, 0xc2, 0x39, 0x67, 0x1d, 0x2e, 0x68, 0xa4, 0xb9, 0xd3, 0x78, 0x69, 0x63, 0x19, 0xb1,
	0x06, 0x35, 0x56, 0xae, 0x3c, 0xab, 0xed, 0xbc, 0xdc, 0xa9, 0xef, 0xec, 0x1f, 0x36, 0x0b, 0x59,
	0xe7, 0x3c, 0xac, 0x68, 0xe0, 0x65, 0xb9, 0xe2, 0x95, 0x2b, 0x87, 0xb5, 0xe7, 0xfb, 0x85, 0x29,
	0xf7, 0x6f, 0xa7, 0xcc, 0x0b, 0x9a, 0x67, 0x2f, 0xe2, 0x00, 0x71, 0xac, 0x6f, 0x26, 0xbe, 0x67,
	0x9a, 0xba, 0x02, 0xb3, 0x51, 0x28, 0x4b, 0x29, 0x3b, 0xc3, 0x6a, 0x9a, 0xd8, 0x6d, 0x9b, 0x7b,
	0x12, 0xd3, 0xc4, 0xb4, 0xfd, 0xa2, 0x5f, 0x81, 0xe6, 0x45, 0xbf, 0x7c, 0x0e, 0x29, 0xb9, 0x51,
	0x10, 0xd0, 0xd4, 0x1d, 0x0c, 0x28, 0xa0, 0x1c, 0x04, 0xd4, 0x62, 0x8b, 0x23, 0xca, 0x53, 0xe7,
	0xe6, 0x9a, 0xed, 0x20, 0xa2, 0xf2, 0x09, 0x46, 0xc4, 0xd4, 0x1a, 0xb1, 0xef, 0x5b, 0x66, 0x23,
	0x26, 0x97, 0xc8, 0x4d, 0xc8, 0x69, 0x87, 0x90, 0x8d, 0xd9, 0xd7, 0x2c, 0xa0, 0x00, 0xd9, 0x58,
	0x05, 0x16, 0xf1, 0x2b, 0x4e, 0x91, 0x0a, 0xcb, 0xac, 0xb8, 0x60, 0xbd, 0x2d, 0x1d, 0x1f, 0xca,
	0xd2, 0x8e, 0xe0, 0x94, 0x41, 0xba, 0x91, 0xc3, 0xc9, 0x37, 0x5b, 0x7f, 0x0a, 0x30, 0x82, 0xbe,
	0xe3, 0x0b, 0xd2, 0xbf, 0xcf, 0xaa, 0x0c, 0x2a, 0x1f, 0x68, 0xea, 0xcd, 0xe3, 0xf3, 0x76, 0x73,
	0xc0, 0x62, 0xe2, 0x93, 0x68, 0xa0, 0xae, 0xf8, 0x09, 0x1f, 0x7e, 0x9f, 0x93, 0x44, 0xe7, 0x73,
	0x70, 0xfa, 0x83, 0x1e, 0x27, 0x71, 0x0f, 0x7b, 0x24, 0x64, 0x1c, 0x85, 0x3e, 0x66, 0x3a, 0x0c,
	0xfe, 0xa4, 0xf4, 0x36, 0xcd, 0x97, 0xea, 0x5a, 0xbe, 0x8a, 0xfa, 0xb8, 0x66, 0x54, 0x34, 0x56,
	0x8c, 0xda, 0x84, 0xb4, 0x4e, 0xe1, 0xfc, 0xa9, 0xbc, 0xf2, 0x15, 0x99, 0xf0, 0x37, 0x4d, 0xd0,
	0xe7, 0x13, 0xa9, 0x7f, 0x20, 0x10, 0xbe, 0xa7, 0x61, 0x75, 0x48, 0x71, 0x13, 0x96, 0x22, 0xde,
	0x35, 0x7e, 0x36, 0xda, 0x22, 0xe6, 0x25, 0xd5, 0xec, 0x0d, 0xdf, 0xfb, 0x4d, 0x06, 0x0a, 0xe3,
	0xff, 0xc8, 0xe0, 0x6c, 0xc0, 0x1b, 0xff, 0xb9, 0xa1, 0x70, 0xce, 0xb9, 0x0e, 0x97, 0x27, 0x38,
	0x76, 0x69, 0xd4, 0x57, 0xd5, 0x71, 0x21, 0x73, 0xaa, 0x0a, 0xc9, 0x20, 0x3d, 0x5b, 0x64, 0xd3,
	0xcb, 0x70, 0xf1, 0x54, 0x8e, 0x6a, 0xa5, 0x30, 0x75, 0xaa, 0x78, 0x03, 0xc7, 0xbd, 0xa1, 0x6e,
	0x60, 0x7a, 0xab, 0x02, 0x0b, 0x47, 0x78, 0xa8, 0x9c, 0xd0, 0xb9, 0x5a, 0x52, 0xff, 0x61, 0x53,
	0x32, 0x75, 0x41, 0x49, 0x3a, 0x96, 0x8e, 0x5c, 0xc5, 0xdf, 0xfd, 0xb3, 0x5c, 0x8a, 0x5b, 0x33,
	0x6d, 0xd4, 0x63, 0xb8, 0x31, 0x7f, 0x84, 0x87, 0x12, 0xdf, 0x6a, 0x82, 0xd3, 0x67, 0x9d, 0x38,
	0x8a, 0x7a, 0x1e, 0x8b, 0xda, 0x5c, 0x9d, 0x43, 0x3a, 0xd7, 0x27, 0xb4, 0xe9, 0xc8, 0x96, 0xd6,
	0x37, 0xb3, 0x95, 0xfd, 0xe0, 0x7e, 0xa3, 0xa0, 0x15, 0x34, 0xa3, 0x36, 0x97, 0xe7, 0x95, 0x5b,
	0x87, 0x23, 0xa5, 0x5d, 0x44, 0x83, 0xb7, 0x55, 0xfa, 0xef, 0x5a, 0xe9, 0xd4, 0x07, 0x4f, 0x1e,
	0x24, 0x5a, 0x9f, 0x21, 0x1a, 0x48, 0xad, 0x4f, 0xcf, 0x7f, 0xf3, 0xed, 0xb5, 0xcc, 0x3f, 0x7d,
	0x7b, 0x2d, 0xf3, 0xbb, 0x6f, 0xaf, 0x65, 0xfe, 0xe4, 0x3f, 0xae, 0x9d, 0x7b, 0x96, 0xf9, 0x32,
	0x73, 0xee, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x0e, 0x53, 0x2a, 0x75, 0x70, 0x34, 0x00, 0x00,
}
