// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gcsdk_gcmessages.proto

/*
	Package gcsdk_gcmessages is a generated protocol buffer package.

	It is generated from these files:
		gcsdk_gcmessages.proto

	It has these top-level messages:
		CMsgSOIDOwner
		CMsgSOSingleObject
		CMsgSOMultipleObjects
		CMsgSOCacheSubscribed
		CMsgSOCacheUnsubscribed
		CMsgSOCacheSubscriptionCheck
		CMsgSOCacheSubscriptionRefresh
		CMsgSOCacheVersion
		CMsgAccountDetails
		CMsgGCMultiplexMessage
		CMsgGCMultiplexMessage_Response
		CGCToGCMsgMasterAck
		CGCToGCMsgMasterAck_Response
		CGCToGCMsgMasterStartupComplete
		CGCToGCMsgRouted
		CGCToGCMsgRoutedReply
		CMsgGCUpdateSessionIP
		CMsgGCRequestSessionIP
		CMsgGCRequestSessionIPResponse
		CMsgSOCacheHaveVersion
		CMsgClientHello
		CMsgServerHello
		CMsgClientWelcome
		CMsgConnectionStatus
		CWorkshop_PopulateItemDescriptions_Request
		CWorkshop_GetContributors_Request
		CWorkshop_GetContributors_Response
		CWorkshop_SetItemPaymentRules_Request
		CWorkshop_SetItemPaymentRules_Response
*/
package gcsdk_gcmessages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "."

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GCConnectionStatus int32

const (
	GCConnectionStatus_GCConnectionStatus_HAVE_SESSION              GCConnectionStatus = 0
	GCConnectionStatus_GCConnectionStatus_GC_GOING_DOWN             GCConnectionStatus = 1
	GCConnectionStatus_GCConnectionStatus_NO_SESSION                GCConnectionStatus = 2
	GCConnectionStatus_GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE GCConnectionStatus = 3
	GCConnectionStatus_GCConnectionStatus_NO_STEAM                  GCConnectionStatus = 4
)

var GCConnectionStatus_name = map[int32]string{
	0: "GCConnectionStatus_HAVE_SESSION",
	1: "GCConnectionStatus_GC_GOING_DOWN",
	2: "GCConnectionStatus_NO_SESSION",
	3: "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE",
	4: "GCConnectionStatus_NO_STEAM",
}
var GCConnectionStatus_value = map[string]int32{
	"GCConnectionStatus_HAVE_SESSION":              0,
	"GCConnectionStatus_GC_GOING_DOWN":             1,
	"GCConnectionStatus_NO_SESSION":                2,
	"GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE": 3,
	"GCConnectionStatus_NO_STEAM":                  4,
}

func (x GCConnectionStatus) Enum() *GCConnectionStatus {
	p := new(GCConnectionStatus)
	*p = x
	return p
}
func (x GCConnectionStatus) String() string {
	return proto.EnumName(GCConnectionStatus_name, int32(x))
}
func (x *GCConnectionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GCConnectionStatus_value, data, "GCConnectionStatus")
	if err != nil {
		return err
	}
	*x = GCConnectionStatus(value)
	return nil
}
func (GCConnectionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{0}
}

type CMsgSOIDOwner struct {
	Type uint32 `protobuf:"varint,1,opt,name=type" json:"type"`
	Id   uint64 `protobuf:"varint,2,opt,name=id" json:"id"`
}

func (m *CMsgSOIDOwner) Reset()                    { *m = CMsgSOIDOwner{} }
func (m *CMsgSOIDOwner) String() string            { return proto.CompactTextString(m) }
func (*CMsgSOIDOwner) ProtoMessage()               {}
func (*CMsgSOIDOwner) Descriptor() ([]byte, []int) { return fileDescriptorGcsdkGcmessages, []int{0} }

func (m *CMsgSOIDOwner) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CMsgSOIDOwner) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type CMsgSOSingleObject struct {
	TypeId     int32          `protobuf:"varint,2,opt,name=type_id,json=typeId" json:"type_id"`
	ObjectData []byte         `protobuf:"bytes,3,opt,name=object_data,json=objectData" json:"object_data"`
	Version    uint64         `protobuf:"fixed64,4,opt,name=version" json:"version"`
	OwnerSoid  *CMsgSOIDOwner `protobuf:"bytes,5,opt,name=owner_soid,json=ownerSoid" json:"owner_soid,omitempty"`
}

func (m *CMsgSOSingleObject) Reset()         { *m = CMsgSOSingleObject{} }
func (m *CMsgSOSingleObject) String() string { return proto.CompactTextString(m) }
func (*CMsgSOSingleObject) ProtoMessage()    {}
func (*CMsgSOSingleObject) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{1}
}

func (m *CMsgSOSingleObject) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *CMsgSOSingleObject) GetObjectData() []byte {
	if m != nil {
		return m.ObjectData
	}
	return nil
}

func (m *CMsgSOSingleObject) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgSOSingleObject) GetOwnerSoid() *CMsgSOIDOwner {
	if m != nil {
		return m.OwnerSoid
	}
	return nil
}

type CMsgSOMultipleObjects struct {
	ObjectsModified []*CMsgSOMultipleObjects_SingleObject `protobuf:"bytes,2,rep,name=objects_modified,json=objectsModified" json:"objects_modified,omitempty"`
	Version         uint64                                `protobuf:"fixed64,3,opt,name=version" json:"version"`
	ObjectsAdded    []*CMsgSOMultipleObjects_SingleObject `protobuf:"bytes,4,rep,name=objects_added,json=objectsAdded" json:"objects_added,omitempty"`
	ObjectsRemoved  []*CMsgSOMultipleObjects_SingleObject `protobuf:"bytes,5,rep,name=objects_removed,json=objectsRemoved" json:"objects_removed,omitempty"`
	OwnerSoid       *CMsgSOIDOwner                        `protobuf:"bytes,6,opt,name=owner_soid,json=ownerSoid" json:"owner_soid,omitempty"`
}

func (m *CMsgSOMultipleObjects) Reset()         { *m = CMsgSOMultipleObjects{} }
func (m *CMsgSOMultipleObjects) String() string { return proto.CompactTextString(m) }
func (*CMsgSOMultipleObjects) ProtoMessage()    {}
func (*CMsgSOMultipleObjects) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{2}
}

func (m *CMsgSOMultipleObjects) GetObjectsModified() []*CMsgSOMultipleObjects_SingleObject {
	if m != nil {
		return m.ObjectsModified
	}
	return nil
}

func (m *CMsgSOMultipleObjects) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgSOMultipleObjects) GetObjectsAdded() []*CMsgSOMultipleObjects_SingleObject {
	if m != nil {
		return m.ObjectsAdded
	}
	return nil
}

func (m *CMsgSOMultipleObjects) GetObjectsRemoved() []*CMsgSOMultipleObjects_SingleObject {
	if m != nil {
		return m.ObjectsRemoved
	}
	return nil
}

func (m *CMsgSOMultipleObjects) GetOwnerSoid() *CMsgSOIDOwner {
	if m != nil {
		return m.OwnerSoid
	}
	return nil
}

type CMsgSOMultipleObjects_SingleObject struct {
	TypeId     int32  `protobuf:"varint,1,opt,name=type_id,json=typeId" json:"type_id"`
	ObjectData []byte `protobuf:"bytes,2,opt,name=object_data,json=objectData" json:"object_data"`
}

func (m *CMsgSOMultipleObjects_SingleObject) Reset()         { *m = CMsgSOMultipleObjects_SingleObject{} }
func (m *CMsgSOMultipleObjects_SingleObject) String() string { return proto.CompactTextString(m) }
func (*CMsgSOMultipleObjects_SingleObject) ProtoMessage()    {}
func (*CMsgSOMultipleObjects_SingleObject) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{2, 0}
}

func (m *CMsgSOMultipleObjects_SingleObject) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *CMsgSOMultipleObjects_SingleObject) GetObjectData() []byte {
	if m != nil {
		return m.ObjectData
	}
	return nil
}

type CMsgSOCacheSubscribed struct {
	Objects   []*CMsgSOCacheSubscribed_SubscribedType `protobuf:"bytes,2,rep,name=objects" json:"objects,omitempty"`
	Version   uint64                                  `protobuf:"fixed64,3,opt,name=version" json:"version"`
	OwnerSoid *CMsgSOIDOwner                          `protobuf:"bytes,4,opt,name=owner_soid,json=ownerSoid" json:"owner_soid,omitempty"`
}

func (m *CMsgSOCacheSubscribed) Reset()         { *m = CMsgSOCacheSubscribed{} }
func (m *CMsgSOCacheSubscribed) String() string { return proto.CompactTextString(m) }
func (*CMsgSOCacheSubscribed) ProtoMessage()    {}
func (*CMsgSOCacheSubscribed) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{3}
}

func (m *CMsgSOCacheSubscribed) GetObjects() []*CMsgSOCacheSubscribed_SubscribedType {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *CMsgSOCacheSubscribed) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgSOCacheSubscribed) GetOwnerSoid() *CMsgSOIDOwner {
	if m != nil {
		return m.OwnerSoid
	}
	return nil
}

type CMsgSOCacheSubscribed_SubscribedType struct {
	TypeId     int32    `protobuf:"varint,1,opt,name=type_id,json=typeId" json:"type_id"`
	ObjectData [][]byte `protobuf:"bytes,2,rep,name=object_data,json=objectData" json:"object_data,omitempty"`
}

func (m *CMsgSOCacheSubscribed_SubscribedType) Reset()         { *m = CMsgSOCacheSubscribed_SubscribedType{} }
func (m *CMsgSOCacheSubscribed_SubscribedType) String() string { return proto.CompactTextString(m) }
func (*CMsgSOCacheSubscribed_SubscribedType) ProtoMessage()    {}
func (*CMsgSOCacheSubscribed_SubscribedType) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{3, 0}
}

func (m *CMsgSOCacheSubscribed_SubscribedType) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *CMsgSOCacheSubscribed_SubscribedType) GetObjectData() [][]byte {
	if m != nil {
		return m.ObjectData
	}
	return nil
}

type CMsgSOCacheUnsubscribed struct {
	OwnerSoid *CMsgSOIDOwner `protobuf:"bytes,2,opt,name=owner_soid,json=ownerSoid" json:"owner_soid,omitempty"`
}

func (m *CMsgSOCacheUnsubscribed) Reset()         { *m = CMsgSOCacheUnsubscribed{} }
func (m *CMsgSOCacheUnsubscribed) String() string { return proto.CompactTextString(m) }
func (*CMsgSOCacheUnsubscribed) ProtoMessage()    {}
func (*CMsgSOCacheUnsubscribed) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{4}
}

func (m *CMsgSOCacheUnsubscribed) GetOwnerSoid() *CMsgSOIDOwner {
	if m != nil {
		return m.OwnerSoid
	}
	return nil
}

type CMsgSOCacheSubscriptionCheck struct {
	Version   uint64         `protobuf:"fixed64,2,opt,name=version" json:"version"`
	OwnerSoid *CMsgSOIDOwner `protobuf:"bytes,3,opt,name=owner_soid,json=ownerSoid" json:"owner_soid,omitempty"`
}

func (m *CMsgSOCacheSubscriptionCheck) Reset()         { *m = CMsgSOCacheSubscriptionCheck{} }
func (m *CMsgSOCacheSubscriptionCheck) String() string { return proto.CompactTextString(m) }
func (*CMsgSOCacheSubscriptionCheck) ProtoMessage()    {}
func (*CMsgSOCacheSubscriptionCheck) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{5}
}

func (m *CMsgSOCacheSubscriptionCheck) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgSOCacheSubscriptionCheck) GetOwnerSoid() *CMsgSOIDOwner {
	if m != nil {
		return m.OwnerSoid
	}
	return nil
}

type CMsgSOCacheSubscriptionRefresh struct {
	OwnerSoid *CMsgSOIDOwner `protobuf:"bytes,2,opt,name=owner_soid,json=ownerSoid" json:"owner_soid,omitempty"`
}

func (m *CMsgSOCacheSubscriptionRefresh) Reset()         { *m = CMsgSOCacheSubscriptionRefresh{} }
func (m *CMsgSOCacheSubscriptionRefresh) String() string { return proto.CompactTextString(m) }
func (*CMsgSOCacheSubscriptionRefresh) ProtoMessage()    {}
func (*CMsgSOCacheSubscriptionRefresh) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{6}
}

func (m *CMsgSOCacheSubscriptionRefresh) GetOwnerSoid() *CMsgSOIDOwner {
	if m != nil {
		return m.OwnerSoid
	}
	return nil
}

type CMsgSOCacheVersion struct {
	Version uint64 `protobuf:"fixed64,1,opt,name=version" json:"version"`
}

func (m *CMsgSOCacheVersion) Reset()         { *m = CMsgSOCacheVersion{} }
func (m *CMsgSOCacheVersion) String() string { return proto.CompactTextString(m) }
func (*CMsgSOCacheVersion) ProtoMessage()    {}
func (*CMsgSOCacheVersion) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{7}
}

func (m *CMsgSOCacheVersion) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type CMsgAccountDetails struct {
	Valid                      bool   `protobuf:"varint,1,opt,name=valid" json:"valid"`
	AccountName                string `protobuf:"bytes,2,opt,name=account_name,json=accountName" json:"account_name"`
	PublicProfile              bool   `protobuf:"varint,4,opt,name=public_profile,json=publicProfile" json:"public_profile"`
	PublicInventory            bool   `protobuf:"varint,5,opt,name=public_inventory,json=publicInventory" json:"public_inventory"`
	VacBanned                  bool   `protobuf:"varint,6,opt,name=vac_banned,json=vacBanned" json:"vac_banned"`
	CyberCafe                  bool   `protobuf:"varint,7,opt,name=cyber_cafe,json=cyberCafe" json:"cyber_cafe"`
	SchoolAccount              bool   `protobuf:"varint,8,opt,name=school_account,json=schoolAccount" json:"school_account"`
	FreeTrialAccount           bool   `protobuf:"varint,9,opt,name=free_trial_account,json=freeTrialAccount" json:"free_trial_account"`
	Subscribed                 bool   `protobuf:"varint,10,opt,name=subscribed" json:"subscribed"`
	LowViolence                bool   `protobuf:"varint,11,opt,name=low_violence,json=lowViolence" json:"low_violence"`
	Limited                    bool   `protobuf:"varint,12,opt,name=limited" json:"limited"`
	Trusted                    bool   `protobuf:"varint,13,opt,name=trusted" json:"trusted"`
	Package                    uint32 `protobuf:"varint,14,opt,name=package" json:"package"`
	TimeCached                 uint32 `protobuf:"fixed32,15,opt,name=time_cached,json=timeCached" json:"time_cached"`
	AccountLocked              bool   `protobuf:"varint,16,opt,name=account_locked,json=accountLocked" json:"account_locked"`
	CommunityBanned            bool   `protobuf:"varint,17,opt,name=community_banned,json=communityBanned" json:"community_banned"`
	TradeBanned                bool   `protobuf:"varint,18,opt,name=trade_banned,json=tradeBanned" json:"trade_banned"`
	EligibleForCommunityMarket bool   `protobuf:"varint,19,opt,name=eligible_for_community_market,json=eligibleForCommunityMarket" json:"eligible_for_community_market"`
}

func (m *CMsgAccountDetails) Reset()         { *m = CMsgAccountDetails{} }
func (m *CMsgAccountDetails) String() string { return proto.CompactTextString(m) }
func (*CMsgAccountDetails) ProtoMessage()    {}
func (*CMsgAccountDetails) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{8}
}

func (m *CMsgAccountDetails) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *CMsgAccountDetails) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *CMsgAccountDetails) GetPublicProfile() bool {
	if m != nil {
		return m.PublicProfile
	}
	return false
}

func (m *CMsgAccountDetails) GetPublicInventory() bool {
	if m != nil {
		return m.PublicInventory
	}
	return false
}

func (m *CMsgAccountDetails) GetVacBanned() bool {
	if m != nil {
		return m.VacBanned
	}
	return false
}

func (m *CMsgAccountDetails) GetCyberCafe() bool {
	if m != nil {
		return m.CyberCafe
	}
	return false
}

func (m *CMsgAccountDetails) GetSchoolAccount() bool {
	if m != nil {
		return m.SchoolAccount
	}
	return false
}

func (m *CMsgAccountDetails) GetFreeTrialAccount() bool {
	if m != nil {
		return m.FreeTrialAccount
	}
	return false
}

func (m *CMsgAccountDetails) GetSubscribed() bool {
	if m != nil {
		return m.Subscribed
	}
	return false
}

func (m *CMsgAccountDetails) GetLowViolence() bool {
	if m != nil {
		return m.LowViolence
	}
	return false
}

func (m *CMsgAccountDetails) GetLimited() bool {
	if m != nil {
		return m.Limited
	}
	return false
}

func (m *CMsgAccountDetails) GetTrusted() bool {
	if m != nil {
		return m.Trusted
	}
	return false
}

func (m *CMsgAccountDetails) GetPackage() uint32 {
	if m != nil {
		return m.Package
	}
	return 0
}

func (m *CMsgAccountDetails) GetTimeCached() uint32 {
	if m != nil {
		return m.TimeCached
	}
	return 0
}

func (m *CMsgAccountDetails) GetAccountLocked() bool {
	if m != nil {
		return m.AccountLocked
	}
	return false
}

func (m *CMsgAccountDetails) GetCommunityBanned() bool {
	if m != nil {
		return m.CommunityBanned
	}
	return false
}

func (m *CMsgAccountDetails) GetTradeBanned() bool {
	if m != nil {
		return m.TradeBanned
	}
	return false
}

func (m *CMsgAccountDetails) GetEligibleForCommunityMarket() bool {
	if m != nil {
		return m.EligibleForCommunityMarket
	}
	return false
}

type CMsgGCMultiplexMessage struct {
	Msgtype   uint32   `protobuf:"varint,1,opt,name=msgtype" json:"msgtype"`
	Payload   []byte   `protobuf:"bytes,2,opt,name=payload" json:"payload"`
	Steamids  []uint64 `protobuf:"fixed64,3,rep,name=steamids" json:"steamids,omitempty"`
	Replytogc bool     `protobuf:"varint,4,opt,name=replytogc" json:"replytogc"`
}

func (m *CMsgGCMultiplexMessage) Reset()         { *m = CMsgGCMultiplexMessage{} }
func (m *CMsgGCMultiplexMessage) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMultiplexMessage) ProtoMessage()    {}
func (*CMsgGCMultiplexMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{9}
}

func (m *CMsgGCMultiplexMessage) GetMsgtype() uint32 {
	if m != nil {
		return m.Msgtype
	}
	return 0
}

func (m *CMsgGCMultiplexMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CMsgGCMultiplexMessage) GetSteamids() []uint64 {
	if m != nil {
		return m.Steamids
	}
	return nil
}

func (m *CMsgGCMultiplexMessage) GetReplytogc() bool {
	if m != nil {
		return m.Replytogc
	}
	return false
}

type CMsgGCMultiplexMessage_Response struct {
	Msgtype uint32 `protobuf:"varint,1,opt,name=msgtype" json:"msgtype"`
}

func (m *CMsgGCMultiplexMessage_Response) Reset()         { *m = CMsgGCMultiplexMessage_Response{} }
func (m *CMsgGCMultiplexMessage_Response) String() string { return proto.CompactTextString(m) }
func (*CMsgGCMultiplexMessage_Response) ProtoMessage()    {}
func (*CMsgGCMultiplexMessage_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{10}
}

func (m *CMsgGCMultiplexMessage_Response) GetMsgtype() uint32 {
	if m != nil {
		return m.Msgtype
	}
	return 0
}

type CGCToGCMsgMasterAck struct {
	DirIndex uint32 `protobuf:"varint,1,opt,name=dir_index,json=dirIndex" json:"dir_index"`
	GcType   uint32 `protobuf:"varint,2,opt,name=gc_type,json=gcType" json:"gc_type"`
}

func (m *CGCToGCMsgMasterAck) Reset()         { *m = CGCToGCMsgMasterAck{} }
func (m *CGCToGCMsgMasterAck) String() string { return proto.CompactTextString(m) }
func (*CGCToGCMsgMasterAck) ProtoMessage()    {}
func (*CGCToGCMsgMasterAck) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{11}
}

func (m *CGCToGCMsgMasterAck) GetDirIndex() uint32 {
	if m != nil {
		return m.DirIndex
	}
	return 0
}

func (m *CGCToGCMsgMasterAck) GetGcType() uint32 {
	if m != nil {
		return m.GcType
	}
	return 0
}

type CGCToGCMsgMasterAck_Response struct {
	Eresult *int32 `protobuf:"varint,1,opt,name=eresult,def=2" json:"eresult,omitempty"`
}

func (m *CGCToGCMsgMasterAck_Response) Reset()         { *m = CGCToGCMsgMasterAck_Response{} }
func (m *CGCToGCMsgMasterAck_Response) String() string { return proto.CompactTextString(m) }
func (*CGCToGCMsgMasterAck_Response) ProtoMessage()    {}
func (*CGCToGCMsgMasterAck_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{12}
}

const Default_CGCToGCMsgMasterAck_Response_Eresult int32 = 2

func (m *CGCToGCMsgMasterAck_Response) GetEresult() int32 {
	if m != nil && m.Eresult != nil {
		return *m.Eresult
	}
	return Default_CGCToGCMsgMasterAck_Response_Eresult
}

type CGCToGCMsgMasterStartupComplete struct {
}

func (m *CGCToGCMsgMasterStartupComplete) Reset()         { *m = CGCToGCMsgMasterStartupComplete{} }
func (m *CGCToGCMsgMasterStartupComplete) String() string { return proto.CompactTextString(m) }
func (*CGCToGCMsgMasterStartupComplete) ProtoMessage()    {}
func (*CGCToGCMsgMasterStartupComplete) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{13}
}

type CGCToGCMsgRouted struct {
	MsgType    uint32 `protobuf:"varint,1,opt,name=msg_type,json=msgType" json:"msg_type"`
	SenderId   uint64 `protobuf:"fixed64,2,opt,name=sender_id,json=senderId" json:"sender_id"`
	NetMessage []byte `protobuf:"bytes,3,opt,name=net_message,json=netMessage" json:"net_message"`
}

func (m *CGCToGCMsgRouted) Reset()                    { *m = CGCToGCMsgRouted{} }
func (m *CGCToGCMsgRouted) String() string            { return proto.CompactTextString(m) }
func (*CGCToGCMsgRouted) ProtoMessage()               {}
func (*CGCToGCMsgRouted) Descriptor() ([]byte, []int) { return fileDescriptorGcsdkGcmessages, []int{14} }

func (m *CGCToGCMsgRouted) GetMsgType() uint32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *CGCToGCMsgRouted) GetSenderId() uint64 {
	if m != nil {
		return m.SenderId
	}
	return 0
}

func (m *CGCToGCMsgRouted) GetNetMessage() []byte {
	if m != nil {
		return m.NetMessage
	}
	return nil
}

type CGCToGCMsgRoutedReply struct {
	MsgType    uint32 `protobuf:"varint,1,opt,name=msg_type,json=msgType" json:"msg_type"`
	NetMessage []byte `protobuf:"bytes,2,opt,name=net_message,json=netMessage" json:"net_message"`
}

func (m *CGCToGCMsgRoutedReply) Reset()         { *m = CGCToGCMsgRoutedReply{} }
func (m *CGCToGCMsgRoutedReply) String() string { return proto.CompactTextString(m) }
func (*CGCToGCMsgRoutedReply) ProtoMessage()    {}
func (*CGCToGCMsgRoutedReply) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{15}
}

func (m *CGCToGCMsgRoutedReply) GetMsgType() uint32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *CGCToGCMsgRoutedReply) GetNetMessage() []byte {
	if m != nil {
		return m.NetMessage
	}
	return nil
}

type CMsgGCUpdateSessionIP struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
	Ip      uint32 `protobuf:"fixed32,2,opt,name=ip" json:"ip"`
}

func (m *CMsgGCUpdateSessionIP) Reset()         { *m = CMsgGCUpdateSessionIP{} }
func (m *CMsgGCUpdateSessionIP) String() string { return proto.CompactTextString(m) }
func (*CMsgGCUpdateSessionIP) ProtoMessage()    {}
func (*CMsgGCUpdateSessionIP) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{16}
}

func (m *CMsgGCUpdateSessionIP) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

func (m *CMsgGCUpdateSessionIP) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

type CMsgGCRequestSessionIP struct {
	Steamid uint64 `protobuf:"fixed64,1,opt,name=steamid" json:"steamid"`
}

func (m *CMsgGCRequestSessionIP) Reset()         { *m = CMsgGCRequestSessionIP{} }
func (m *CMsgGCRequestSessionIP) String() string { return proto.CompactTextString(m) }
func (*CMsgGCRequestSessionIP) ProtoMessage()    {}
func (*CMsgGCRequestSessionIP) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{17}
}

func (m *CMsgGCRequestSessionIP) GetSteamid() uint64 {
	if m != nil {
		return m.Steamid
	}
	return 0
}

type CMsgGCRequestSessionIPResponse struct {
	Ip uint32 `protobuf:"fixed32,1,opt,name=ip" json:"ip"`
}

func (m *CMsgGCRequestSessionIPResponse) Reset()         { *m = CMsgGCRequestSessionIPResponse{} }
func (m *CMsgGCRequestSessionIPResponse) String() string { return proto.CompactTextString(m) }
func (*CMsgGCRequestSessionIPResponse) ProtoMessage()    {}
func (*CMsgGCRequestSessionIPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{18}
}

func (m *CMsgGCRequestSessionIPResponse) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

type CMsgSOCacheHaveVersion struct {
	Soid    *CMsgSOIDOwner `protobuf:"bytes,1,opt,name=soid" json:"soid,omitempty"`
	Version uint64         `protobuf:"fixed64,2,opt,name=version" json:"version"`
}

func (m *CMsgSOCacheHaveVersion) Reset()         { *m = CMsgSOCacheHaveVersion{} }
func (m *CMsgSOCacheHaveVersion) String() string { return proto.CompactTextString(m) }
func (*CMsgSOCacheHaveVersion) ProtoMessage()    {}
func (*CMsgSOCacheHaveVersion) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{19}
}

func (m *CMsgSOCacheHaveVersion) GetSoid() *CMsgSOIDOwner {
	if m != nil {
		return m.Soid
	}
	return nil
}

func (m *CMsgSOCacheHaveVersion) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type CMsgClientHello struct {
	Version             uint32                    `protobuf:"varint,1,opt,name=version" json:"version"`
	SocacheHaveVersions []*CMsgSOCacheHaveVersion `protobuf:"bytes,2,rep,name=socache_have_versions,json=socacheHaveVersions" json:"socache_have_versions,omitempty"`
	ClientSessionNeed   uint32                    `protobuf:"varint,3,opt,name=client_session_need,json=clientSessionNeed" json:"client_session_need"`
	ClientLauncher      uint32                    `protobuf:"varint,4,opt,name=client_launcher,json=clientLauncher" json:"client_launcher"`
}

func (m *CMsgClientHello) Reset()                    { *m = CMsgClientHello{} }
func (m *CMsgClientHello) String() string            { return proto.CompactTextString(m) }
func (*CMsgClientHello) ProtoMessage()               {}
func (*CMsgClientHello) Descriptor() ([]byte, []int) { return fileDescriptorGcsdkGcmessages, []int{20} }

func (m *CMsgClientHello) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgClientHello) GetSocacheHaveVersions() []*CMsgSOCacheHaveVersion {
	if m != nil {
		return m.SocacheHaveVersions
	}
	return nil
}

func (m *CMsgClientHello) GetClientSessionNeed() uint32 {
	if m != nil {
		return m.ClientSessionNeed
	}
	return 0
}

func (m *CMsgClientHello) GetClientLauncher() uint32 {
	if m != nil {
		return m.ClientLauncher
	}
	return 0
}

type CMsgServerHello struct {
	Version                 uint32                    `protobuf:"varint,1,opt,name=version" json:"version"`
	SocacheHaveVersions     []*CMsgSOCacheHaveVersion `protobuf:"bytes,2,rep,name=socache_have_versions,json=socacheHaveVersions" json:"socache_have_versions,omitempty"`
	LegacyClientSessionNeed uint32                    `protobuf:"varint,3,opt,name=legacy_client_session_need,json=legacyClientSessionNeed" json:"legacy_client_session_need"`
	LegacyClientLauncher    uint32                    `protobuf:"varint,4,opt,name=legacy_client_launcher,json=legacyClientLauncher" json:"legacy_client_launcher"`
	SteamdatagramPort       uint32                    `protobuf:"varint,5,opt,name=steamdatagram_port,json=steamdatagramPort" json:"steamdatagram_port"`
}

func (m *CMsgServerHello) Reset()                    { *m = CMsgServerHello{} }
func (m *CMsgServerHello) String() string            { return proto.CompactTextString(m) }
func (*CMsgServerHello) ProtoMessage()               {}
func (*CMsgServerHello) Descriptor() ([]byte, []int) { return fileDescriptorGcsdkGcmessages, []int{21} }

func (m *CMsgServerHello) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgServerHello) GetSocacheHaveVersions() []*CMsgSOCacheHaveVersion {
	if m != nil {
		return m.SocacheHaveVersions
	}
	return nil
}

func (m *CMsgServerHello) GetLegacyClientSessionNeed() uint32 {
	if m != nil {
		return m.LegacyClientSessionNeed
	}
	return 0
}

func (m *CMsgServerHello) GetLegacyClientLauncher() uint32 {
	if m != nil {
		return m.LegacyClientLauncher
	}
	return 0
}

func (m *CMsgServerHello) GetSteamdatagramPort() uint32 {
	if m != nil {
		return m.SteamdatagramPort
	}
	return 0
}

type CMsgClientWelcome struct {
	Version                   uint32                          `protobuf:"varint,1,opt,name=version" json:"version"`
	GameData                  []byte                          `protobuf:"bytes,2,opt,name=game_data,json=gameData" json:"game_data"`
	OutofdateSubscribedCaches []*CMsgSOCacheSubscribed        `protobuf:"bytes,3,rep,name=outofdate_subscribed_caches,json=outofdateSubscribedCaches" json:"outofdate_subscribed_caches,omitempty"`
	UptodateSubscribedCaches  []*CMsgSOCacheSubscriptionCheck `protobuf:"bytes,4,rep,name=uptodate_subscribed_caches,json=uptodateSubscribedCaches" json:"uptodate_subscribed_caches,omitempty"`
	Location                  *CMsgClientWelcome_Location     `protobuf:"bytes,5,opt,name=location" json:"location,omitempty"`
	GameData2                 []byte                          `protobuf:"bytes,6,opt,name=game_data2,json=gameData2" json:"game_data2"`
	Rtime32GcWelcomeTimestamp uint32                          `protobuf:"varint,7,opt,name=rtime32_gc_welcome_timestamp,json=rtime32GcWelcomeTimestamp" json:"rtime32_gc_welcome_timestamp"`
	Currency                  uint32                          `protobuf:"varint,8,opt,name=currency" json:"currency"`
}

func (m *CMsgClientWelcome) Reset()         { *m = CMsgClientWelcome{} }
func (m *CMsgClientWelcome) String() string { return proto.CompactTextString(m) }
func (*CMsgClientWelcome) ProtoMessage()    {}
func (*CMsgClientWelcome) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{22}
}

func (m *CMsgClientWelcome) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CMsgClientWelcome) GetGameData() []byte {
	if m != nil {
		return m.GameData
	}
	return nil
}

func (m *CMsgClientWelcome) GetOutofdateSubscribedCaches() []*CMsgSOCacheSubscribed {
	if m != nil {
		return m.OutofdateSubscribedCaches
	}
	return nil
}

func (m *CMsgClientWelcome) GetUptodateSubscribedCaches() []*CMsgSOCacheSubscriptionCheck {
	if m != nil {
		return m.UptodateSubscribedCaches
	}
	return nil
}

func (m *CMsgClientWelcome) GetLocation() *CMsgClientWelcome_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *CMsgClientWelcome) GetGameData2() []byte {
	if m != nil {
		return m.GameData2
	}
	return nil
}

func (m *CMsgClientWelcome) GetRtime32GcWelcomeTimestamp() uint32 {
	if m != nil {
		return m.Rtime32GcWelcomeTimestamp
	}
	return 0
}

func (m *CMsgClientWelcome) GetCurrency() uint32 {
	if m != nil {
		return m.Currency
	}
	return 0
}

type CMsgClientWelcome_Location struct {
	Latitude  float32 `protobuf:"fixed32,1,opt,name=latitude" json:"latitude"`
	Longitude float32 `protobuf:"fixed32,2,opt,name=longitude" json:"longitude"`
	Country   string  `protobuf:"bytes,3,opt,name=country" json:"country"`
}

func (m *CMsgClientWelcome_Location) Reset()         { *m = CMsgClientWelcome_Location{} }
func (m *CMsgClientWelcome_Location) String() string { return proto.CompactTextString(m) }
func (*CMsgClientWelcome_Location) ProtoMessage()    {}
func (*CMsgClientWelcome_Location) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{22, 0}
}

func (m *CMsgClientWelcome_Location) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *CMsgClientWelcome_Location) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *CMsgClientWelcome_Location) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

type CMsgConnectionStatus struct {
	Status                        *GCConnectionStatus `protobuf:"varint,1,opt,name=status,enum=GCConnectionStatus,def=0" json:"status,omitempty"`
	ClientSessionNeed             uint32              `protobuf:"varint,2,opt,name=client_session_need,json=clientSessionNeed" json:"client_session_need"`
	QueuePosition                 int32               `protobuf:"varint,3,opt,name=queue_position,json=queuePosition" json:"queue_position"`
	QueueSize                     int32               `protobuf:"varint,4,opt,name=queue_size,json=queueSize" json:"queue_size"`
	WaitSeconds                   int32               `protobuf:"varint,5,opt,name=wait_seconds,json=waitSeconds" json:"wait_seconds"`
	EstimatedWaitSecondsRemaining int32               `protobuf:"varint,6,opt,name=estimated_wait_seconds_remaining,json=estimatedWaitSecondsRemaining" json:"estimated_wait_seconds_remaining"`
}

func (m *CMsgConnectionStatus) Reset()         { *m = CMsgConnectionStatus{} }
func (m *CMsgConnectionStatus) String() string { return proto.CompactTextString(m) }
func (*CMsgConnectionStatus) ProtoMessage()    {}
func (*CMsgConnectionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{23}
}

const Default_CMsgConnectionStatus_Status GCConnectionStatus = GCConnectionStatus_GCConnectionStatus_HAVE_SESSION

func (m *CMsgConnectionStatus) GetStatus() GCConnectionStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_CMsgConnectionStatus_Status
}

func (m *CMsgConnectionStatus) GetClientSessionNeed() uint32 {
	if m != nil {
		return m.ClientSessionNeed
	}
	return 0
}

func (m *CMsgConnectionStatus) GetQueuePosition() int32 {
	if m != nil {
		return m.QueuePosition
	}
	return 0
}

func (m *CMsgConnectionStatus) GetQueueSize() int32 {
	if m != nil {
		return m.QueueSize
	}
	return 0
}

func (m *CMsgConnectionStatus) GetWaitSeconds() int32 {
	if m != nil {
		return m.WaitSeconds
	}
	return 0
}

func (m *CMsgConnectionStatus) GetEstimatedWaitSecondsRemaining() int32 {
	if m != nil {
		return m.EstimatedWaitSecondsRemaining
	}
	return 0
}

type CWorkshop_PopulateItemDescriptions_Request struct {
	Appid     uint32                                                                      `protobuf:"varint,1,opt,name=appid" json:"appid"`
	Languages []*CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock `protobuf:"bytes,2,rep,name=languages" json:"languages,omitempty"`
}

func (m *CWorkshop_PopulateItemDescriptions_Request) Reset() {
	*m = CWorkshop_PopulateItemDescriptions_Request{}
}
func (m *CWorkshop_PopulateItemDescriptions_Request) String() string {
	return proto.CompactTextString(m)
}
func (*CWorkshop_PopulateItemDescriptions_Request) ProtoMessage() {}
func (*CWorkshop_PopulateItemDescriptions_Request) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{24}
}

func (m *CWorkshop_PopulateItemDescriptions_Request) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CWorkshop_PopulateItemDescriptions_Request) GetLanguages() []*CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
	if m != nil {
		return m.Languages
	}
	return nil
}

type CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription struct {
	Gameitemid      uint32 `protobuf:"varint,1,opt,name=gameitemid" json:"gameitemid"`
	ItemDescription string `protobuf:"bytes,2,opt,name=item_description,json=itemDescription" json:"item_description"`
	OnePerAccount   bool   `protobuf:"varint,3,opt,name=one_per_account,json=onePerAccount" json:"one_per_account"`
}

func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) Reset() {
	*m = CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription{}
}
func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) String() string {
	return proto.CompactTextString(m)
}
func (*CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) ProtoMessage() {}
func (*CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{24, 0}
}

func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) GetGameitemid() uint32 {
	if m != nil {
		return m.Gameitemid
	}
	return 0
}

func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) GetItemDescription() string {
	if m != nil {
		return m.ItemDescription
	}
	return ""
}

func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) GetOnePerAccount() bool {
	if m != nil {
		return m.OnePerAccount
	}
	return false
}

type CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock struct {
	Language     string                                                              `protobuf:"bytes,1,opt,name=language" json:"language"`
	Descriptions []*CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription `protobuf:"bytes,2,rep,name=descriptions" json:"descriptions,omitempty"`
}

func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) Reset() {
	*m = CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock{}
}
func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) String() string {
	return proto.CompactTextString(m)
}
func (*CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) ProtoMessage() {}
func (*CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{24, 1}
}

func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) GetDescriptions() []*CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
	if m != nil {
		return m.Descriptions
	}
	return nil
}

type CWorkshop_GetContributors_Request struct {
	Appid      uint32 `protobuf:"varint,1,opt,name=appid" json:"appid"`
	Gameitemid uint32 `protobuf:"varint,2,opt,name=gameitemid" json:"gameitemid"`
}

func (m *CWorkshop_GetContributors_Request) Reset()         { *m = CWorkshop_GetContributors_Request{} }
func (m *CWorkshop_GetContributors_Request) String() string { return proto.CompactTextString(m) }
func (*CWorkshop_GetContributors_Request) ProtoMessage()    {}
func (*CWorkshop_GetContributors_Request) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{25}
}

func (m *CWorkshop_GetContributors_Request) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CWorkshop_GetContributors_Request) GetGameitemid() uint32 {
	if m != nil {
		return m.Gameitemid
	}
	return 0
}

type CWorkshop_GetContributors_Response struct {
	Contributors []uint64 `protobuf:"fixed64,1,rep,name=contributors" json:"contributors,omitempty"`
}

func (m *CWorkshop_GetContributors_Response) Reset()         { *m = CWorkshop_GetContributors_Response{} }
func (m *CWorkshop_GetContributors_Response) String() string { return proto.CompactTextString(m) }
func (*CWorkshop_GetContributors_Response) ProtoMessage()    {}
func (*CWorkshop_GetContributors_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{26}
}

func (m *CWorkshop_GetContributors_Response) GetContributors() []uint64 {
	if m != nil {
		return m.Contributors
	}
	return nil
}

type CWorkshop_SetItemPaymentRules_Request struct {
	Appid                   uint32                                                           `protobuf:"varint,1,opt,name=appid" json:"appid"`
	Gameitemid              uint32                                                           `protobuf:"varint,2,opt,name=gameitemid" json:"gameitemid"`
	AssociatedWorkshopFiles []*CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule `protobuf:"bytes,3,rep,name=associated_workshop_files,json=associatedWorkshopFiles" json:"associated_workshop_files,omitempty"`
	PartnerAccounts         []*CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule  `protobuf:"bytes,4,rep,name=partner_accounts,json=partnerAccounts" json:"partner_accounts,omitempty"`
}

func (m *CWorkshop_SetItemPaymentRules_Request) Reset()         { *m = CWorkshop_SetItemPaymentRules_Request{} }
func (m *CWorkshop_SetItemPaymentRules_Request) String() string { return proto.CompactTextString(m) }
func (*CWorkshop_SetItemPaymentRules_Request) ProtoMessage()    {}
func (*CWorkshop_SetItemPaymentRules_Request) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{27}
}

func (m *CWorkshop_SetItemPaymentRules_Request) GetAppid() uint32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *CWorkshop_SetItemPaymentRules_Request) GetGameitemid() uint32 {
	if m != nil {
		return m.Gameitemid
	}
	return 0
}

func (m *CWorkshop_SetItemPaymentRules_Request) GetAssociatedWorkshopFiles() []*CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
	if m != nil {
		return m.AssociatedWorkshopFiles
	}
	return nil
}

func (m *CWorkshop_SetItemPaymentRules_Request) GetPartnerAccounts() []*CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
	if m != nil {
		return m.PartnerAccounts
	}
	return nil
}

type CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule struct {
	WorkshopFileId    uint64  `protobuf:"varint,1,opt,name=workshop_file_id,json=workshopFileId" json:"workshop_file_id"`
	RevenuePercentage float32 `protobuf:"fixed32,2,opt,name=revenue_percentage,json=revenuePercentage" json:"revenue_percentage"`
	RuleDescription   string  `protobuf:"bytes,3,opt,name=rule_description,json=ruleDescription" json:"rule_description"`
}

func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) Reset() {
	*m = CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule{}
}
func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) String() string {
	return proto.CompactTextString(m)
}
func (*CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) ProtoMessage() {}
func (*CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{27, 0}
}

func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) GetWorkshopFileId() uint64 {
	if m != nil {
		return m.WorkshopFileId
	}
	return 0
}

func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) GetRevenuePercentage() float32 {
	if m != nil {
		return m.RevenuePercentage
	}
	return 0
}

func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) GetRuleDescription() string {
	if m != nil {
		return m.RuleDescription
	}
	return ""
}

type CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule struct {
	AccountId         uint32  `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	RevenuePercentage float32 `protobuf:"fixed32,2,opt,name=revenue_percentage,json=revenuePercentage" json:"revenue_percentage"`
	RuleDescription   string  `protobuf:"bytes,3,opt,name=rule_description,json=ruleDescription" json:"rule_description"`
}

func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) Reset() {
	*m = CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule{}
}
func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) String() string {
	return proto.CompactTextString(m)
}
func (*CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) ProtoMessage() {}
func (*CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{27, 1}
}

func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) GetRevenuePercentage() float32 {
	if m != nil {
		return m.RevenuePercentage
	}
	return 0
}

func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) GetRuleDescription() string {
	if m != nil {
		return m.RuleDescription
	}
	return ""
}

type CWorkshop_SetItemPaymentRules_Response struct {
}

func (m *CWorkshop_SetItemPaymentRules_Response) Reset() {
	*m = CWorkshop_SetItemPaymentRules_Response{}
}
func (m *CWorkshop_SetItemPaymentRules_Response) String() string { return proto.CompactTextString(m) }
func (*CWorkshop_SetItemPaymentRules_Response) ProtoMessage()    {}
func (*CWorkshop_SetItemPaymentRules_Response) Descriptor() ([]byte, []int) {
	return fileDescriptorGcsdkGcmessages, []int{28}
}

func init() {
	proto.RegisterType((*CMsgSOIDOwner)(nil), "CMsgSOIDOwner")
	proto.RegisterType((*CMsgSOSingleObject)(nil), "CMsgSOSingleObject")
	proto.RegisterType((*CMsgSOMultipleObjects)(nil), "CMsgSOMultipleObjects")
	proto.RegisterType((*CMsgSOMultipleObjects_SingleObject)(nil), "CMsgSOMultipleObjects.SingleObject")
	proto.RegisterType((*CMsgSOCacheSubscribed)(nil), "CMsgSOCacheSubscribed")
	proto.RegisterType((*CMsgSOCacheSubscribed_SubscribedType)(nil), "CMsgSOCacheSubscribed.SubscribedType")
	proto.RegisterType((*CMsgSOCacheUnsubscribed)(nil), "CMsgSOCacheUnsubscribed")
	proto.RegisterType((*CMsgSOCacheSubscriptionCheck)(nil), "CMsgSOCacheSubscriptionCheck")
	proto.RegisterType((*CMsgSOCacheSubscriptionRefresh)(nil), "CMsgSOCacheSubscriptionRefresh")
	proto.RegisterType((*CMsgSOCacheVersion)(nil), "CMsgSOCacheVersion")
	proto.RegisterType((*CMsgAccountDetails)(nil), "CMsgAccountDetails")
	proto.RegisterType((*CMsgGCMultiplexMessage)(nil), "CMsgGCMultiplexMessage")
	proto.RegisterType((*CMsgGCMultiplexMessage_Response)(nil), "CMsgGCMultiplexMessage_Response")
	proto.RegisterType((*CGCToGCMsgMasterAck)(nil), "CGCToGCMsgMasterAck")
	proto.RegisterType((*CGCToGCMsgMasterAck_Response)(nil), "CGCToGCMsgMasterAck_Response")
	proto.RegisterType((*CGCToGCMsgMasterStartupComplete)(nil), "CGCToGCMsgMasterStartupComplete")
	proto.RegisterType((*CGCToGCMsgRouted)(nil), "CGCToGCMsgRouted")
	proto.RegisterType((*CGCToGCMsgRoutedReply)(nil), "CGCToGCMsgRoutedReply")
	proto.RegisterType((*CMsgGCUpdateSessionIP)(nil), "CMsgGCUpdateSessionIP")
	proto.RegisterType((*CMsgGCRequestSessionIP)(nil), "CMsgGCRequestSessionIP")
	proto.RegisterType((*CMsgGCRequestSessionIPResponse)(nil), "CMsgGCRequestSessionIPResponse")
	proto.RegisterType((*CMsgSOCacheHaveVersion)(nil), "CMsgSOCacheHaveVersion")
	proto.RegisterType((*CMsgClientHello)(nil), "CMsgClientHello")
	proto.RegisterType((*CMsgServerHello)(nil), "CMsgServerHello")
	proto.RegisterType((*CMsgClientWelcome)(nil), "CMsgClientWelcome")
	proto.RegisterType((*CMsgClientWelcome_Location)(nil), "CMsgClientWelcome.Location")
	proto.RegisterType((*CMsgConnectionStatus)(nil), "CMsgConnectionStatus")
	proto.RegisterType((*CWorkshop_PopulateItemDescriptions_Request)(nil), "CWorkshop_PopulateItemDescriptions_Request")
	proto.RegisterType((*CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription)(nil), "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription")
	proto.RegisterType((*CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock)(nil), "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock")
	proto.RegisterType((*CWorkshop_GetContributors_Request)(nil), "CWorkshop_GetContributors_Request")
	proto.RegisterType((*CWorkshop_GetContributors_Response)(nil), "CWorkshop_GetContributors_Response")
	proto.RegisterType((*CWorkshop_SetItemPaymentRules_Request)(nil), "CWorkshop_SetItemPaymentRules_Request")
	proto.RegisterType((*CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule)(nil), "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule")
	proto.RegisterType((*CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule)(nil), "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule")
	proto.RegisterType((*CWorkshop_SetItemPaymentRules_Response)(nil), "CWorkshop_SetItemPaymentRules_Response")
	proto.RegisterEnum("GCConnectionStatus", GCConnectionStatus_name, GCConnectionStatus_value)
}
func (m *CMsgSOIDOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOIDOwner) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Id))
	return i, nil
}

func (m *CMsgSOSingleObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOSingleObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x10
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.TypeId))
	if m.ObjectData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.ObjectData)))
		i += copy(dAtA[i:], m.ObjectData)
	}
	dAtA[i] = 0x21
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Version))
	if m.OwnerSoid != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.OwnerSoid.Size()))
		n1, err := m.OwnerSoid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *CMsgSOMultipleObjects) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOMultipleObjects) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjectsModified) > 0 {
		for _, msg := range m.ObjectsModified {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x19
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Version))
	if len(m.ObjectsAdded) > 0 {
		for _, msg := range m.ObjectsAdded {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ObjectsRemoved) > 0 {
		for _, msg := range m.ObjectsRemoved {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OwnerSoid != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.OwnerSoid.Size()))
		n2, err := m.OwnerSoid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *CMsgSOMultipleObjects_SingleObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOMultipleObjects_SingleObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.TypeId))
	if m.ObjectData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.ObjectData)))
		i += copy(dAtA[i:], m.ObjectData)
	}
	return i, nil
}

func (m *CMsgSOCacheSubscribed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOCacheSubscribed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x19
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Version))
	if m.OwnerSoid != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.OwnerSoid.Size()))
		n3, err := m.OwnerSoid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *CMsgSOCacheSubscribed_SubscribedType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOCacheSubscribed_SubscribedType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.TypeId))
	if len(m.ObjectData) > 0 {
		for _, b := range m.ObjectData {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *CMsgSOCacheUnsubscribed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOCacheUnsubscribed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerSoid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.OwnerSoid.Size()))
		n4, err := m.OwnerSoid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *CMsgSOCacheSubscriptionCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOCacheSubscriptionCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x11
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Version))
	if m.OwnerSoid != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.OwnerSoid.Size()))
		n5, err := m.OwnerSoid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CMsgSOCacheSubscriptionRefresh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOCacheSubscriptionRefresh) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OwnerSoid != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.OwnerSoid.Size()))
		n6, err := m.OwnerSoid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CMsgSOCacheVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOCacheVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Version))
	return i, nil
}

func (m *CMsgAccountDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgAccountDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Valid {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x12
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.AccountName)))
	i += copy(dAtA[i:], m.AccountName)
	dAtA[i] = 0x20
	i++
	if m.PublicProfile {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.PublicInventory {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	if m.VacBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.CyberCafe {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.SchoolAccount {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x48
	i++
	if m.FreeTrialAccount {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x50
	i++
	if m.Subscribed {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x58
	i++
	if m.LowViolence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x60
	i++
	if m.Limited {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x68
	i++
	if m.Trusted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x70
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Package))
	dAtA[i] = 0x7d
	i++
	i = encodeFixed32GcsdkGcmessages(dAtA, i, uint32(m.TimeCached))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	if m.AccountLocked {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	if m.CommunityBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	if m.TradeBanned {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	if m.EligibleForCommunityMarket {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCMultiplexMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMultiplexMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Msgtype))
	if m.Payload != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if len(m.Steamids) > 0 {
		for _, num := range m.Steamids {
			dAtA[i] = 0x19
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	dAtA[i] = 0x20
	i++
	if m.Replytogc {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CMsgGCMultiplexMessage_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCMultiplexMessage_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Msgtype))
	return i, nil
}

func (m *CGCToGCMsgMasterAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCToGCMsgMasterAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.DirIndex))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.GcType))
	return i, nil
}

func (m *CGCToGCMsgMasterAck_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCToGCMsgMasterAck_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Eresult != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(*m.Eresult))
	}
	return i, nil
}

func (m *CGCToGCMsgMasterStartupComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCToGCMsgMasterStartupComplete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CGCToGCMsgRouted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCToGCMsgRouted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.MsgType))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.SenderId))
	if m.NetMessage != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.NetMessage)))
		i += copy(dAtA[i:], m.NetMessage)
	}
	return i, nil
}

func (m *CGCToGCMsgRoutedReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CGCToGCMsgRoutedReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.MsgType))
	if m.NetMessage != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.NetMessage)))
		i += copy(dAtA[i:], m.NetMessage)
	}
	return i, nil
}

func (m *CMsgGCUpdateSessionIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCUpdateSessionIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Steamid))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32GcsdkGcmessages(dAtA, i, uint32(m.Ip))
	return i, nil
}

func (m *CMsgGCRequestSessionIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCRequestSessionIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Steamid))
	return i, nil
}

func (m *CMsgGCRequestSessionIPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgGCRequestSessionIPResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32GcsdkGcmessages(dAtA, i, uint32(m.Ip))
	return i, nil
}

func (m *CMsgSOCacheHaveVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgSOCacheHaveVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Soid != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Soid.Size()))
		n7, err := m.Soid.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	dAtA[i] = 0x11
	i++
	i = encodeFixed64GcsdkGcmessages(dAtA, i, uint64(m.Version))
	return i, nil
}

func (m *CMsgClientHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgClientHello) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Version))
	if len(m.SocacheHaveVersions) > 0 {
		for _, msg := range m.SocacheHaveVersions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.ClientSessionNeed))
	dAtA[i] = 0x20
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.ClientLauncher))
	return i, nil
}

func (m *CMsgServerHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgServerHello) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Version))
	if len(m.SocacheHaveVersions) > 0 {
		for _, msg := range m.SocacheHaveVersions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.LegacyClientSessionNeed))
	dAtA[i] = 0x20
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.LegacyClientLauncher))
	dAtA[i] = 0x28
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.SteamdatagramPort))
	return i, nil
}

func (m *CMsgClientWelcome) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgClientWelcome) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Version))
	if m.GameData != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.GameData)))
		i += copy(dAtA[i:], m.GameData)
	}
	if len(m.OutofdateSubscribedCaches) > 0 {
		for _, msg := range m.OutofdateSubscribedCaches {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UptodateSubscribedCaches) > 0 {
		for _, msg := range m.UptodateSubscribedCaches {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Location != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Location.Size()))
		n8, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.GameData2 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.GameData2)))
		i += copy(dAtA[i:], m.GameData2)
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Rtime32GcWelcomeTimestamp))
	dAtA[i] = 0x40
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Currency))
	return i, nil
}

func (m *CMsgClientWelcome_Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgClientWelcome_Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xd
	i++
	i = encodeFixed32GcsdkGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.Latitude))))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32GcsdkGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.Longitude))))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.Country)))
	i += copy(dAtA[i:], m.Country)
	return i, nil
}

func (m *CMsgConnectionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CMsgConnectionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(*m.Status))
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.ClientSessionNeed))
	dAtA[i] = 0x18
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.QueuePosition))
	dAtA[i] = 0x20
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.QueueSize))
	dAtA[i] = 0x28
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.WaitSeconds))
	dAtA[i] = 0x30
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.EstimatedWaitSecondsRemaining))
	return i, nil
}

func (m *CWorkshop_PopulateItemDescriptions_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_PopulateItemDescriptions_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Appid))
	if len(m.Languages) > 0 {
		for _, msg := range m.Languages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Gameitemid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.ItemDescription)))
	i += copy(dAtA[i:], m.ItemDescription)
	dAtA[i] = 0x18
	i++
	if m.OnePerAccount {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.Language)))
	i += copy(dAtA[i:], m.Language)
	if len(m.Descriptions) > 0 {
		for _, msg := range m.Descriptions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CWorkshop_GetContributors_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_GetContributors_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Appid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Gameitemid))
	return i, nil
}

func (m *CWorkshop_GetContributors_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_GetContributors_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Contributors) > 0 {
		for _, num := range m.Contributors {
			dAtA[i] = 0x9
			i++
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	return i, nil
}

func (m *CWorkshop_SetItemPaymentRules_Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_SetItemPaymentRules_Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Appid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.Gameitemid))
	if len(m.AssociatedWorkshopFiles) > 0 {
		for _, msg := range m.AssociatedWorkshopFiles {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PartnerAccounts) > 0 {
		for _, msg := range m.PartnerAccounts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.WorkshopFileId))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32GcsdkGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.RevenuePercentage))))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.RuleDescription)))
	i += copy(dAtA[i:], m.RuleDescription)
	return i, nil
}

func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x15
	i++
	i = encodeFixed32GcsdkGcmessages(dAtA, i, uint32(math.Float32bits(float32(m.RevenuePercentage))))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintGcsdkGcmessages(dAtA, i, uint64(len(m.RuleDescription)))
	i += copy(dAtA[i:], m.RuleDescription)
	return i, nil
}

func (m *CWorkshop_SetItemPaymentRules_Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CWorkshop_SetItemPaymentRules_Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64GcsdkGcmessages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32GcsdkGcmessages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGcsdkGcmessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CMsgSOIDOwner) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Type))
	n += 1 + sovGcsdkGcmessages(uint64(m.Id))
	return n
}

func (m *CMsgSOSingleObject) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.TypeId))
	if m.ObjectData != nil {
		l = len(m.ObjectData)
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	n += 9
	if m.OwnerSoid != nil {
		l = m.OwnerSoid.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgSOMultipleObjects) Size() (n int) {
	var l int
	_ = l
	if len(m.ObjectsModified) > 0 {
		for _, e := range m.ObjectsModified {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	n += 9
	if len(m.ObjectsAdded) > 0 {
		for _, e := range m.ObjectsAdded {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	if len(m.ObjectsRemoved) > 0 {
		for _, e := range m.ObjectsRemoved {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	if m.OwnerSoid != nil {
		l = m.OwnerSoid.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgSOMultipleObjects_SingleObject) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.TypeId))
	if m.ObjectData != nil {
		l = len(m.ObjectData)
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgSOCacheSubscribed) Size() (n int) {
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	n += 9
	if m.OwnerSoid != nil {
		l = m.OwnerSoid.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgSOCacheSubscribed_SubscribedType) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.TypeId))
	if len(m.ObjectData) > 0 {
		for _, b := range m.ObjectData {
			l = len(b)
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CMsgSOCacheUnsubscribed) Size() (n int) {
	var l int
	_ = l
	if m.OwnerSoid != nil {
		l = m.OwnerSoid.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgSOCacheSubscriptionCheck) Size() (n int) {
	var l int
	_ = l
	n += 9
	if m.OwnerSoid != nil {
		l = m.OwnerSoid.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgSOCacheSubscriptionRefresh) Size() (n int) {
	var l int
	_ = l
	if m.OwnerSoid != nil {
		l = m.OwnerSoid.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgSOCacheVersion) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgAccountDetails) Size() (n int) {
	var l int
	_ = l
	n += 2
	l = len(m.AccountName)
	n += 1 + l + sovGcsdkGcmessages(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 1 + sovGcsdkGcmessages(uint64(m.Package))
	n += 5
	n += 3
	n += 3
	n += 3
	n += 3
	return n
}

func (m *CMsgGCMultiplexMessage) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Msgtype))
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	if len(m.Steamids) > 0 {
		n += 9 * len(m.Steamids)
	}
	n += 2
	return n
}

func (m *CMsgGCMultiplexMessage_Response) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Msgtype))
	return n
}

func (m *CGCToGCMsgMasterAck) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.DirIndex))
	n += 1 + sovGcsdkGcmessages(uint64(m.GcType))
	return n
}

func (m *CGCToGCMsgMasterAck_Response) Size() (n int) {
	var l int
	_ = l
	if m.Eresult != nil {
		n += 1 + sovGcsdkGcmessages(uint64(*m.Eresult))
	}
	return n
}

func (m *CGCToGCMsgMasterStartupComplete) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CGCToGCMsgRouted) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.MsgType))
	n += 9
	if m.NetMessage != nil {
		l = len(m.NetMessage)
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CGCToGCMsgRoutedReply) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.MsgType))
	if m.NetMessage != nil {
		l = len(m.NetMessage)
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	return n
}

func (m *CMsgGCUpdateSessionIP) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 5
	return n
}

func (m *CMsgGCRequestSessionIP) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *CMsgGCRequestSessionIPResponse) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}

func (m *CMsgSOCacheHaveVersion) Size() (n int) {
	var l int
	_ = l
	if m.Soid != nil {
		l = m.Soid.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	n += 9
	return n
}

func (m *CMsgClientHello) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Version))
	if len(m.SocacheHaveVersions) > 0 {
		for _, e := range m.SocacheHaveVersions {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	n += 1 + sovGcsdkGcmessages(uint64(m.ClientSessionNeed))
	n += 1 + sovGcsdkGcmessages(uint64(m.ClientLauncher))
	return n
}

func (m *CMsgServerHello) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Version))
	if len(m.SocacheHaveVersions) > 0 {
		for _, e := range m.SocacheHaveVersions {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	n += 1 + sovGcsdkGcmessages(uint64(m.LegacyClientSessionNeed))
	n += 1 + sovGcsdkGcmessages(uint64(m.LegacyClientLauncher))
	n += 1 + sovGcsdkGcmessages(uint64(m.SteamdatagramPort))
	return n
}

func (m *CMsgClientWelcome) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Version))
	if m.GameData != nil {
		l = len(m.GameData)
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	if len(m.OutofdateSubscribedCaches) > 0 {
		for _, e := range m.OutofdateSubscribedCaches {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	if len(m.UptodateSubscribedCaches) > 0 {
		for _, e := range m.UptodateSubscribedCaches {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	if m.GameData2 != nil {
		l = len(m.GameData2)
		n += 1 + l + sovGcsdkGcmessages(uint64(l))
	}
	n += 1 + sovGcsdkGcmessages(uint64(m.Rtime32GcWelcomeTimestamp))
	n += 1 + sovGcsdkGcmessages(uint64(m.Currency))
	return n
}

func (m *CMsgClientWelcome_Location) Size() (n int) {
	var l int
	_ = l
	n += 5
	n += 5
	l = len(m.Country)
	n += 1 + l + sovGcsdkGcmessages(uint64(l))
	return n
}

func (m *CMsgConnectionStatus) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovGcsdkGcmessages(uint64(*m.Status))
	}
	n += 1 + sovGcsdkGcmessages(uint64(m.ClientSessionNeed))
	n += 1 + sovGcsdkGcmessages(uint64(m.QueuePosition))
	n += 1 + sovGcsdkGcmessages(uint64(m.QueueSize))
	n += 1 + sovGcsdkGcmessages(uint64(m.WaitSeconds))
	n += 1 + sovGcsdkGcmessages(uint64(m.EstimatedWaitSecondsRemaining))
	return n
}

func (m *CWorkshop_PopulateItemDescriptions_Request) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Appid))
	if len(m.Languages) > 0 {
		for _, e := range m.Languages {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Gameitemid))
	l = len(m.ItemDescription)
	n += 1 + l + sovGcsdkGcmessages(uint64(l))
	n += 2
	return n
}

func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) Size() (n int) {
	var l int
	_ = l
	l = len(m.Language)
	n += 1 + l + sovGcsdkGcmessages(uint64(l))
	if len(m.Descriptions) > 0 {
		for _, e := range m.Descriptions {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CWorkshop_GetContributors_Request) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Appid))
	n += 1 + sovGcsdkGcmessages(uint64(m.Gameitemid))
	return n
}

func (m *CWorkshop_GetContributors_Response) Size() (n int) {
	var l int
	_ = l
	if len(m.Contributors) > 0 {
		n += 9 * len(m.Contributors)
	}
	return n
}

func (m *CWorkshop_SetItemPaymentRules_Request) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.Appid))
	n += 1 + sovGcsdkGcmessages(uint64(m.Gameitemid))
	if len(m.AssociatedWorkshopFiles) > 0 {
		for _, e := range m.AssociatedWorkshopFiles {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	if len(m.PartnerAccounts) > 0 {
		for _, e := range m.PartnerAccounts {
			l = e.Size()
			n += 1 + l + sovGcsdkGcmessages(uint64(l))
		}
	}
	return n
}

func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.WorkshopFileId))
	n += 5
	l = len(m.RuleDescription)
	n += 1 + l + sovGcsdkGcmessages(uint64(l))
	return n
}

func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovGcsdkGcmessages(uint64(m.AccountId))
	n += 5
	l = len(m.RuleDescription)
	n += 1 + l + sovGcsdkGcmessages(uint64(l))
	return n
}

func (m *CWorkshop_SetItemPaymentRules_Response) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovGcsdkGcmessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGcsdkGcmessages(x uint64) (n int) {
	return sovGcsdkGcmessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CMsgSOIDOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOIDOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOIDOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOSingleObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOSingleObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOSingleObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectData = append(m.ObjectData[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjectData == nil {
				m.ObjectData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Version = uint64(dAtA[iNdEx-8])
			m.Version |= uint64(dAtA[iNdEx-7]) << 8
			m.Version |= uint64(dAtA[iNdEx-6]) << 16
			m.Version |= uint64(dAtA[iNdEx-5]) << 24
			m.Version |= uint64(dAtA[iNdEx-4]) << 32
			m.Version |= uint64(dAtA[iNdEx-3]) << 40
			m.Version |= uint64(dAtA[iNdEx-2]) << 48
			m.Version |= uint64(dAtA[iNdEx-1]) << 56
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerSoid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerSoid == nil {
				m.OwnerSoid = &CMsgSOIDOwner{}
			}
			if err := m.OwnerSoid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOMultipleObjects) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOMultipleObjects: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOMultipleObjects: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectsModified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectsModified = append(m.ObjectsModified, &CMsgSOMultipleObjects_SingleObject{})
			if err := m.ObjectsModified[len(m.ObjectsModified)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Version = uint64(dAtA[iNdEx-8])
			m.Version |= uint64(dAtA[iNdEx-7]) << 8
			m.Version |= uint64(dAtA[iNdEx-6]) << 16
			m.Version |= uint64(dAtA[iNdEx-5]) << 24
			m.Version |= uint64(dAtA[iNdEx-4]) << 32
			m.Version |= uint64(dAtA[iNdEx-3]) << 40
			m.Version |= uint64(dAtA[iNdEx-2]) << 48
			m.Version |= uint64(dAtA[iNdEx-1]) << 56
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectsAdded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectsAdded = append(m.ObjectsAdded, &CMsgSOMultipleObjects_SingleObject{})
			if err := m.ObjectsAdded[len(m.ObjectsAdded)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectsRemoved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectsRemoved = append(m.ObjectsRemoved, &CMsgSOMultipleObjects_SingleObject{})
			if err := m.ObjectsRemoved[len(m.ObjectsRemoved)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerSoid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerSoid == nil {
				m.OwnerSoid = &CMsgSOIDOwner{}
			}
			if err := m.OwnerSoid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOMultipleObjects_SingleObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectData = append(m.ObjectData[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjectData == nil {
				m.ObjectData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOCacheSubscribed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOCacheSubscribed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOCacheSubscribed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &CMsgSOCacheSubscribed_SubscribedType{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Version = uint64(dAtA[iNdEx-8])
			m.Version |= uint64(dAtA[iNdEx-7]) << 8
			m.Version |= uint64(dAtA[iNdEx-6]) << 16
			m.Version |= uint64(dAtA[iNdEx-5]) << 24
			m.Version |= uint64(dAtA[iNdEx-4]) << 32
			m.Version |= uint64(dAtA[iNdEx-3]) << 40
			m.Version |= uint64(dAtA[iNdEx-2]) << 48
			m.Version |= uint64(dAtA[iNdEx-1]) << 56
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerSoid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerSoid == nil {
				m.OwnerSoid = &CMsgSOIDOwner{}
			}
			if err := m.OwnerSoid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOCacheSubscribed_SubscribedType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribedType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribedType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectData = append(m.ObjectData, make([]byte, postIndex-iNdEx))
			copy(m.ObjectData[len(m.ObjectData)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOCacheUnsubscribed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOCacheUnsubscribed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOCacheUnsubscribed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerSoid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerSoid == nil {
				m.OwnerSoid = &CMsgSOIDOwner{}
			}
			if err := m.OwnerSoid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOCacheSubscriptionCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOCacheSubscriptionCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOCacheSubscriptionCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Version = uint64(dAtA[iNdEx-8])
			m.Version |= uint64(dAtA[iNdEx-7]) << 8
			m.Version |= uint64(dAtA[iNdEx-6]) << 16
			m.Version |= uint64(dAtA[iNdEx-5]) << 24
			m.Version |= uint64(dAtA[iNdEx-4]) << 32
			m.Version |= uint64(dAtA[iNdEx-3]) << 40
			m.Version |= uint64(dAtA[iNdEx-2]) << 48
			m.Version |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerSoid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerSoid == nil {
				m.OwnerSoid = &CMsgSOIDOwner{}
			}
			if err := m.OwnerSoid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOCacheSubscriptionRefresh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOCacheSubscriptionRefresh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOCacheSubscriptionRefresh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerSoid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerSoid == nil {
				m.OwnerSoid = &CMsgSOIDOwner{}
			}
			if err := m.OwnerSoid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOCacheVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOCacheVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOCacheVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Version = uint64(dAtA[iNdEx-8])
			m.Version |= uint64(dAtA[iNdEx-7]) << 8
			m.Version |= uint64(dAtA[iNdEx-6]) << 16
			m.Version |= uint64(dAtA[iNdEx-5]) << 24
			m.Version |= uint64(dAtA[iNdEx-4]) << 32
			m.Version |= uint64(dAtA[iNdEx-3]) << 40
			m.Version |= uint64(dAtA[iNdEx-2]) << 48
			m.Version |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgAccountDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgAccountDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgAccountDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicProfile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublicProfile = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicInventory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublicInventory = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VacBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VacBanned = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CyberCafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CyberCafe = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchoolAccount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SchoolAccount = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTrialAccount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FreeTrialAccount = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribed = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowViolence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowViolence = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Limited = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trusted = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			m.Package = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Package |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCached", wireType)
			}
			m.TimeCached = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.TimeCached = uint32(dAtA[iNdEx-4])
			m.TimeCached |= uint32(dAtA[iNdEx-3]) << 8
			m.TimeCached |= uint32(dAtA[iNdEx-2]) << 16
			m.TimeCached |= uint32(dAtA[iNdEx-1]) << 24
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccountLocked = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CommunityBanned = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TradeBanned = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleForCommunityMarket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EligibleForCommunityMarket = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMultiplexMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMultiplexMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMultiplexMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgtype", wireType)
			}
			m.Msgtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.Steamids = append(m.Steamids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGcsdkGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGcsdkGcmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.Steamids = append(m.Steamids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamids", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replytogc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replytogc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCMultiplexMessage_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCMultiplexMessage_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCMultiplexMessage_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgtype", wireType)
			}
			m.Msgtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCToGCMsgMasterAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCToGCMsgMasterAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCToGCMsgMasterAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirIndex", wireType)
			}
			m.DirIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcType", wireType)
			}
			m.GcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCToGCMsgMasterAck_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCToGCMsgMasterAck_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCToGCMsgMasterAck_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eresult", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eresult = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCToGCMsgMasterStartupComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCToGCMsgMasterStartupComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCToGCMsgMasterStartupComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCToGCMsgRouted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCToGCMsgRouted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCToGCMsgRouted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			m.SenderId = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SenderId = uint64(dAtA[iNdEx-8])
			m.SenderId |= uint64(dAtA[iNdEx-7]) << 8
			m.SenderId |= uint64(dAtA[iNdEx-6]) << 16
			m.SenderId |= uint64(dAtA[iNdEx-5]) << 24
			m.SenderId |= uint64(dAtA[iNdEx-4]) << 32
			m.SenderId |= uint64(dAtA[iNdEx-3]) << 40
			m.SenderId |= uint64(dAtA[iNdEx-2]) << 48
			m.SenderId |= uint64(dAtA[iNdEx-1]) << 56
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetMessage = append(m.NetMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.NetMessage == nil {
				m.NetMessage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CGCToGCMsgRoutedReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CGCToGCMsgRoutedReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CGCToGCMsgRoutedReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetMessage = append(m.NetMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.NetMessage == nil {
				m.NetMessage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCUpdateSessionIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCUpdateSessionIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCUpdateSessionIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Ip = uint32(dAtA[iNdEx-4])
			m.Ip |= uint32(dAtA[iNdEx-3]) << 8
			m.Ip |= uint32(dAtA[iNdEx-2]) << 16
			m.Ip |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCRequestSessionIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCRequestSessionIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCRequestSessionIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steamid", wireType)
			}
			m.Steamid = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Steamid = uint64(dAtA[iNdEx-8])
			m.Steamid |= uint64(dAtA[iNdEx-7]) << 8
			m.Steamid |= uint64(dAtA[iNdEx-6]) << 16
			m.Steamid |= uint64(dAtA[iNdEx-5]) << 24
			m.Steamid |= uint64(dAtA[iNdEx-4]) << 32
			m.Steamid |= uint64(dAtA[iNdEx-3]) << 40
			m.Steamid |= uint64(dAtA[iNdEx-2]) << 48
			m.Steamid |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgGCRequestSessionIPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgGCRequestSessionIPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgGCRequestSessionIPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.Ip = uint32(dAtA[iNdEx-4])
			m.Ip |= uint32(dAtA[iNdEx-3]) << 8
			m.Ip |= uint32(dAtA[iNdEx-2]) << 16
			m.Ip |= uint32(dAtA[iNdEx-1]) << 24
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgSOCacheHaveVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgSOCacheHaveVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgSOCacheHaveVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Soid == nil {
				m.Soid = &CMsgSOIDOwner{}
			}
			if err := m.Soid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.Version = uint64(dAtA[iNdEx-8])
			m.Version |= uint64(dAtA[iNdEx-7]) << 8
			m.Version |= uint64(dAtA[iNdEx-6]) << 16
			m.Version |= uint64(dAtA[iNdEx-5]) << 24
			m.Version |= uint64(dAtA[iNdEx-4]) << 32
			m.Version |= uint64(dAtA[iNdEx-3]) << 40
			m.Version |= uint64(dAtA[iNdEx-2]) << 48
			m.Version |= uint64(dAtA[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgClientHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgClientHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgClientHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocacheHaveVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocacheHaveVersions = append(m.SocacheHaveVersions, &CMsgSOCacheHaveVersion{})
			if err := m.SocacheHaveVersions[len(m.SocacheHaveVersions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSessionNeed", wireType)
			}
			m.ClientSessionNeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSessionNeed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLauncher", wireType)
			}
			m.ClientLauncher = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientLauncher |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgServerHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgServerHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgServerHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocacheHaveVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocacheHaveVersions = append(m.SocacheHaveVersions, &CMsgSOCacheHaveVersion{})
			if err := m.SocacheHaveVersions[len(m.SocacheHaveVersions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyClientSessionNeed", wireType)
			}
			m.LegacyClientSessionNeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LegacyClientSessionNeed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyClientLauncher", wireType)
			}
			m.LegacyClientLauncher = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LegacyClientLauncher |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamdatagramPort", wireType)
			}
			m.SteamdatagramPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SteamdatagramPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgClientWelcome) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgClientWelcome: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgClientWelcome: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameData = append(m.GameData[:0], dAtA[iNdEx:postIndex]...)
			if m.GameData == nil {
				m.GameData = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutofdateSubscribedCaches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutofdateSubscribedCaches = append(m.OutofdateSubscribedCaches, &CMsgSOCacheSubscribed{})
			if err := m.OutofdateSubscribedCaches[len(m.OutofdateSubscribedCaches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UptodateSubscribedCaches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UptodateSubscribedCaches = append(m.UptodateSubscribedCaches, &CMsgSOCacheSubscriptionCheck{})
			if err := m.UptodateSubscribedCaches[len(m.UptodateSubscribedCaches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &CMsgClientWelcome_Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameData2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameData2 = append(m.GameData2[:0], dAtA[iNdEx:postIndex]...)
			if m.GameData2 == nil {
				m.GameData2 = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtime32GcWelcomeTimestamp", wireType)
			}
			m.Rtime32GcWelcomeTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtime32GcWelcomeTimestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			m.Currency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currency |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgClientWelcome_Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Latitude = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Longitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CMsgConnectionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CMsgConnectionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CMsgConnectionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v GCConnectionStatus
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (GCConnectionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSessionNeed", wireType)
			}
			m.ClientSessionNeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientSessionNeed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueuePosition", wireType)
			}
			m.QueuePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueuePosition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueSize", wireType)
			}
			m.QueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitSeconds", wireType)
			}
			m.WaitSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedWaitSecondsRemaining", wireType)
			}
			m.EstimatedWaitSecondsRemaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedWaitSecondsRemaining |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_PopulateItemDescriptions_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CWorkshop_PopulateItemDescriptions_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CWorkshop_PopulateItemDescriptions_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, &CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock{})
			if err := m.Languages[len(m.Languages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleItemDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleItemDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gameitemid", wireType)
			}
			m.Gameitemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gameitemid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnePerAccount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnePerAccount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemDescriptionsLanguageBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemDescriptionsLanguageBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptions = append(m.Descriptions, &CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription{})
			if err := m.Descriptions[len(m.Descriptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_GetContributors_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CWorkshop_GetContributors_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CWorkshop_GetContributors_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gameitemid", wireType)
			}
			m.Gameitemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gameitemid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_GetContributors_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CWorkshop_GetContributors_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CWorkshop_GetContributors_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.Contributors = append(m.Contributors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGcsdkGcmessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGcsdkGcmessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.Contributors = append(m.Contributors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Contributors", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_SetItemPaymentRules_Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CWorkshop_SetItemPaymentRules_Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CWorkshop_SetItemPaymentRules_Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gameitemid", wireType)
			}
			m.Gameitemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gameitemid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociatedWorkshopFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociatedWorkshopFiles = append(m.AssociatedWorkshopFiles, &CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule{})
			if err := m.AssociatedWorkshopFiles[len(m.AssociatedWorkshopFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartnerAccounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartnerAccounts = append(m.PartnerAccounts, &CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule{})
			if err := m.PartnerAccounts[len(m.PartnerAccounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkshopItemPaymentRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkshopItemPaymentRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkshopFileId", wireType)
			}
			m.WorkshopFileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkshopFileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevenuePercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.RevenuePercentage = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartnerItemPaymentRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartnerItemPaymentRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevenuePercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.RevenuePercentage = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CWorkshop_SetItemPaymentRules_Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CWorkshop_SetItemPaymentRules_Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CWorkshop_SetItemPaymentRules_Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGcsdkGcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcsdkGcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGcsdkGcmessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGcsdkGcmessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcsdkGcmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGcsdkGcmessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGcsdkGcmessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGcsdkGcmessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGcsdkGcmessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGcsdkGcmessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("gcsdk_gcmessages.proto", fileDescriptorGcsdkGcmessages) }

var fileDescriptorGcsdkGcmessages = []byte{
	// 2132 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4b, 0x6f, 0x23, 0x59,
	0xf5, 0xef, 0x72, 0xd2, 0x49, 0x7c, 0xf2, 0x72, 0x57, 0xa6, 0xbb, 0xdd, 0xee, 0xce, 0xab, 0x7a,
	0xfa, 0x3f, 0xd1, 0xcc, 0xfc, 0x0d, 0xca, 0x8c, 0x00, 0x35, 0x82, 0x51, 0xda, 0x9d, 0x71, 0x2c,
	0xf2, 0xa2, 0xdc, 0x8f, 0x05, 0x48, 0x97, 0x9b, 0xaa, 0x13, 0xa7, 0x48, 0x55, 0xdd, 0x9a, 0xaa,
	0x5b, 0xce, 0xb8, 0x25, 0xa4, 0x5e, 0xce, 0x92, 0x25, 0x0b, 0x76, 0x48, 0x03, 0xac, 0x40, 0x7c,
	0x06, 0x16, 0xb3, 0x64, 0xc3, 0x16, 0xa1, 0x1e, 0xbe, 0x04, 0x62, 0x83, 0xee, 0xcb, 0x2e, 0x3b,
	0x4e, 0x3b, 0x23, 0x21, 0xd8, 0x39, 0xbf, 0xf3, 0x3b, 0x8f, 0x7b, 0xce, 0xa9, 0x7b, 0xce, 0x0d,
	0xdc, 0xe9, 0x78, 0x99, 0x7f, 0x4e, 0x3a, 0x5e, 0x84, 0x59, 0x46, 0x3b, 0x98, 0xd5, 0x93, 0x94,
	0x71, 0x56, 0x5b, 0xc9, 0x38, 0xd2, 0x68, 0x18, 0x74, 0x3e, 0x81, 0xc5, 0xc6, 0x41, 0xd6, 0x69,
	0x1f, 0xb5, 0x9e, 0x1e, 0x5d, 0xc4, 0x98, 0xda, 0x55, 0x98, 0xe6, 0xbd, 0x04, 0xab, 0xd6, 0x86,
	0xb5, 0xb5, 0xf8, 0x64, 0xfa, 0xab, 0xbf, 0xad, 0xdf, 0x70, 0x25, 0x62, 0xbf, 0x03, 0xa5, 0xc0,
	0xaf, 0x96, 0x36, 0xac, 0xad, 0x69, 0x8d, 0x97, 0x02, 0xdf, 0xf9, 0xbd, 0x05, 0xb6, 0xb2, 0xd0,
	0x0e, 0xe2, 0x4e, 0x88, 0x47, 0x27, 0x3f, 0x47, 0x8f, 0xdb, 0xab, 0x30, 0x2b, 0x94, 0x88, 0xd6,
	0xb8, 0xa9, 0x35, 0x66, 0x04, 0xd8, 0xf2, 0xed, 0x47, 0x30, 0xcf, 0x24, 0x91, 0xf8, 0x94, 0xd3,
	0xea, 0xd4, 0x86, 0xb5, 0xb5, 0xa0, 0x29, 0xa0, 0x04, 0x4f, 0x29, 0xa7, 0xf6, 0x1a, 0xcc, 0x76,
	0x31, 0xcd, 0x02, 0x16, 0x57, 0xa7, 0x37, 0xac, 0xad, 0x19, 0x4d, 0x31, 0xa0, 0xfd, 0xff, 0x00,
	0x4c, 0x44, 0x4d, 0x32, 0x16, 0xf8, 0xd5, 0x9b, 0x1b, 0xd6, 0xd6, 0xfc, 0xf6, 0x52, 0x7d, 0xe8,
	0x40, 0x6e, 0x59, 0x32, 0xda, 0x2c, 0xf0, 0x9d, 0x3f, 0x4e, 0xc1, 0x6d, 0x25, 0x3c, 0xc8, 0x43,
	0x1e, 0x24, 0x26, 0xda, 0xcc, 0x3e, 0x84, 0x8a, 0x72, 0x9b, 0x91, 0x88, 0xf9, 0xc1, 0x69, 0x80,
	0x22, 0xee, 0xa9, 0xad, 0xf9, 0xed, 0x87, 0xf5, 0xb1, 0x1a, 0xf5, 0xe2, 0x69, 0xdd, 0x65, 0xad,
	0x7c, 0xa0, 0x75, 0x8b, 0x81, 0x4f, 0x8d, 0x0b, 0x7c, 0x0f, 0x16, 0x8d, 0x3f, 0xea, 0xfb, 0xe8,
	0x57, 0xa7, 0xaf, 0xef, 0x6c, 0x41, 0x6b, 0xee, 0x08, 0x45, 0x7b, 0x1f, 0x8c, 0x73, 0x92, 0x62,
	0xc4, 0xba, 0x28, 0xf2, 0x70, 0x6d, 0x5b, 0x4b, 0x5a, 0xd7, 0x55, 0xaa, 0x23, 0x09, 0x9d, 0x99,
	0x90, 0xd0, 0xda, 0xcf, 0x60, 0xe1, 0xaa, 0xaa, 0x5b, 0x93, 0xab, 0x5e, 0x1a, 0x5f, 0xf5, 0xc7,
	0xf0, 0xfa, 0xcb, 0xd5, 0xd7, 0xa5, 0x2f, 0xbe, 0x5c, 0x7d, 0x3d, 0xe7, 0xfc, 0xd3, 0x32, 0x25,
	0x6b, 0x50, 0xef, 0x0c, 0xdb, 0xf9, 0x49, 0xe6, 0xa5, 0xc1, 0x09, 0xfa, 0xf6, 0x27, 0x30, 0xab,
	0x83, 0xd7, 0x95, 0x7a, 0x54, 0x1f, 0x4b, 0xac, 0x0f, 0x7e, 0x3e, 0xeb, 0x25, 0xe8, 0x1a, 0xad,
	0x89, 0x35, 0x1a, 0xce, 0xc5, 0xf4, 0xa4, 0x5c, 0x1c, 0xc3, 0xd2, 0xb0, 0xa7, 0x49, 0xd9, 0x58,
	0x1f, 0xcd, 0xc6, 0xd4, 0xd6, 0x42, 0x31, 0x0f, 0xce, 0x1e, 0xdc, 0x2d, 0x9c, 0xe8, 0x79, 0x9c,
	0x0d, 0x0e, 0x3f, 0x1c, 0x5b, 0x69, 0x52, 0xe3, 0x47, 0xf0, 0xe0, 0x72, 0x6e, 0x12, 0x1e, 0xb0,
	0xb8, 0x71, 0x86, 0xde, 0x79, 0x31, 0x15, 0xa5, 0xc9, 0xa9, 0x98, 0x9a, 0xe4, 0xee, 0x08, 0xd6,
	0xae, 0x70, 0xe7, 0xe2, 0x69, 0x8a, 0xd9, 0xd9, 0x37, 0x8d, 0xff, 0x63, 0x73, 0xc7, 0x48, 0x83,
	0x2f, 0x74, 0x54, 0x85, 0xa8, 0xad, 0x31, 0x51, 0x3b, 0x5f, 0xcc, 0x28, 0xb5, 0x1d, 0xcf, 0x63,
	0x79, 0xcc, 0x9f, 0x22, 0xa7, 0x41, 0x98, 0xd9, 0x35, 0xb8, 0xd9, 0xa5, 0xa1, 0x2e, 0xca, 0x9c,
	0x56, 0x52, 0x90, 0xfd, 0x1e, 0x2c, 0x50, 0xc5, 0x26, 0x31, 0x8d, 0x50, 0x46, 0x56, 0xd6, 0x94,
	0x79, 0x2d, 0x39, 0xa4, 0x11, 0xda, 0x1f, 0xc0, 0x52, 0x92, 0x9f, 0x84, 0x81, 0x47, 0x92, 0x94,
	0x9d, 0x06, 0x21, 0xca, 0x06, 0x31, 0xd6, 0x16, 0x95, 0xec, 0x58, 0x89, 0xec, 0x6f, 0x41, 0x45,
	0x93, 0x83, 0xb8, 0x8b, 0x31, 0x67, 0x69, 0x4f, 0x5e, 0x56, 0x86, 0xbe, 0xac, 0xa4, 0x2d, 0x23,
	0xb4, 0x1f, 0x02, 0x74, 0xa9, 0x47, 0x4e, 0x68, 0x1c, 0xa3, 0xfa, 0x0c, 0x0d, 0xb5, 0xdc, 0xa5,
	0xde, 0x13, 0x09, 0x0b, 0x92, 0xd7, 0x3b, 0xc1, 0x94, 0x78, 0xf4, 0x14, 0xab, 0xb3, 0x45, 0x92,
	0xc4, 0x1b, 0xf4, 0x54, 0xc6, 0x99, 0x79, 0x67, 0x8c, 0x85, 0x44, 0x47, 0x5f, 0x9d, 0x2b, 0xc6,
	0xa9, 0x64, 0x3a, 0x41, 0xf6, 0x36, 0xd8, 0xa7, 0x29, 0x22, 0xe1, 0x69, 0x40, 0x07, 0x0a, 0xe5,
	0x82, 0x42, 0x45, 0xc8, 0x9f, 0x09, 0xb1, 0xd1, 0x79, 0x17, 0x60, 0xd0, 0x97, 0x55, 0x28, 0x70,
	0x0b, 0xb8, 0xc8, 0x6b, 0xc8, 0x2e, 0x48, 0x37, 0x60, 0x21, 0xc6, 0x1e, 0x56, 0xe7, 0x0b, 0xbc,
	0xf9, 0x90, 0x5d, 0xbc, 0xd0, 0x02, 0x51, 0xd3, 0x30, 0x88, 0x02, 0x8e, 0x7e, 0x75, 0xa1, 0xc0,
	0x31, 0xa0, 0x90, 0xf3, 0x34, 0xcf, 0x84, 0x7c, 0xb1, 0x28, 0xd7, 0xa0, 0x90, 0x27, 0xd4, 0x3b,
	0xa7, 0x1d, 0xac, 0x2e, 0x15, 0x26, 0x98, 0x01, 0xc5, 0x15, 0xc4, 0x83, 0x08, 0x89, 0x27, 0x1a,
	0xc9, 0xaf, 0x2e, 0x6f, 0x58, 0x5b, 0xb3, 0x26, 0x5e, 0x21, 0x90, 0x0d, 0xe6, 0x8b, 0xb4, 0x99,
	0x3e, 0x08, 0x99, 0x77, 0x8e, 0x7e, 0xb5, 0x52, 0x4c, 0x9b, 0x96, 0xed, 0x4b, 0x91, 0x28, 0xaf,
	0xc7, 0xa2, 0x28, 0x8f, 0x03, 0xde, 0x33, 0x35, 0xbb, 0x55, 0x2c, 0x6f, 0x5f, 0xaa, 0x2b, 0xf7,
	0x1e, 0x2c, 0xf0, 0x94, 0xfa, 0x68, 0xc8, 0x76, 0x31, 0x1b, 0x52, 0xa2, 0x89, 0x4d, 0x58, 0xc5,
	0x30, 0xe8, 0x04, 0x27, 0x21, 0x92, 0x53, 0x96, 0x92, 0x81, 0x9b, 0x88, 0xa6, 0xe7, 0xc8, 0xab,
	0x2b, 0x05, 0xcd, 0x9a, 0xa1, 0x7e, 0xca, 0xd2, 0x86, 0x21, 0x1e, 0x48, 0x9e, 0xf3, 0x2b, 0x0b,
	0xee, 0x88, 0x4f, 0xa1, 0xd9, 0x30, 0xe3, 0xe0, 0xf3, 0x03, 0xb5, 0x08, 0x88, 0x8c, 0x45, 0x59,
	0xe7, 0xd2, 0xcc, 0x37, 0xa0, 0xca, 0x68, 0x2f, 0x64, 0xd4, 0x1f, 0xba, 0xb0, 0x0d, 0x68, 0xd7,
	0x60, 0x4e, 0x2e, 0x16, 0x81, 0x9f, 0x55, 0xa7, 0x36, 0xa6, 0xb6, 0x66, 0xdc, 0xfe, 0xdf, 0xb6,
	0x03, 0xe5, 0x14, 0x93, 0xb0, 0xc7, 0x59, 0xc7, 0x1b, 0xfa, 0x40, 0x06, 0xb0, 0xb3, 0x03, 0xeb,
	0xe3, 0x23, 0x23, 0x2e, 0x66, 0x09, 0x8b, 0xb3, 0x89, 0x21, 0x3a, 0x2f, 0x61, 0xa5, 0xd1, 0x6c,
	0x3c, 0x63, 0x4d, 0x61, 0xe8, 0x80, 0x66, 0x1c, 0xd3, 0x1d, 0xef, 0xdc, 0xde, 0x84, 0xb2, 0x1f,
	0xa4, 0x24, 0x88, 0x7d, 0xfc, 0x7c, 0x48, 0x71, 0xce, 0x0f, 0xd2, 0x96, 0x40, 0xc5, 0x15, 0xdd,
	0xf1, 0x88, 0xb4, 0x5c, 0x2a, 0x10, 0x66, 0x3a, 0x9e, 0xb8, 0xc1, 0x9d, 0xef, 0xc3, 0x83, 0x31,
	0x86, 0x07, 0x81, 0xdd, 0x87, 0x59, 0x4c, 0x31, 0xcb, 0x43, 0xae, 0x6e, 0xf8, 0xc7, 0xd6, 0xb6,
	0x6b, 0x10, 0x67, 0x13, 0xd6, 0x47, 0x95, 0xdb, 0x9c, 0xa6, 0x3c, 0x4f, 0x1a, 0x2c, 0x4a, 0x42,
	0xe4, 0xe8, 0xfc, 0x02, 0x2a, 0x03, 0x8a, 0xcb, 0x72, 0xd1, 0xc1, 0xeb, 0x30, 0x17, 0x65, 0x1d,
	0x32, 0xf6, 0xb4, 0x72, 0xac, 0x6c, 0x42, 0x39, 0xc3, 0xd8, 0xc7, 0xd4, 0x2c, 0x57, 0xe6, 0xe2,
	0x9b, 0x53, 0xb0, 0x1a, 0xb4, 0x31, 0x72, 0xa2, 0x77, 0xbd, 0xe1, 0xf5, 0x2a, 0x46, 0xae, 0x13,
	0xec, 0x10, 0xb8, 0x3d, 0xea, 0xde, 0x15, 0x75, 0x99, 0x1c, 0xc3, 0x88, 0x83, 0xd2, 0x15, 0x0e,
	0x0e, 0xd4, 0xf0, 0x6e, 0x36, 0x9e, 0x27, 0x3e, 0xe5, 0xd8, 0xc6, 0x4c, 0x5c, 0xcc, 0xad, 0x63,
	0x51, 0x51, 0xdd, 0x24, 0xc3, 0x57, 0xb7, 0x06, 0xe5, 0xae, 0x99, 0x48, 0xb3, 0xb3, 0xfd, 0x5d,
	0x33, 0x71, 0xbe, 0x67, 0x9a, 0xd8, 0xc5, 0xcf, 0x72, 0xcc, 0xf8, 0xb5, 0xed, 0x39, 0xdf, 0x51,
	0x13, 0xe9, 0xb2, 0x66, 0xbf, 0x94, 0xca, 0xa3, 0x35, 0xe2, 0xf1, 0xa7, 0xca, 0xa3, 0x1e, 0x3c,
	0x7b, 0xb4, 0xdb, 0x1f, 0x3e, 0x0e, 0x4c, 0xcb, 0xd9, 0x65, 0x8d, 0x9d, 0x5d, 0x52, 0x36, 0x69,
	0xac, 0x3a, 0x5f, 0x5b, 0xb0, 0x2c, 0xf4, 0x1a, 0x61, 0x80, 0x31, 0xdf, 0xc3, 0x30, 0x64, 0xa3,
	0x43, 0x6d, 0x71, 0x74, 0x14, 0xff, 0x08, 0x6e, 0x67, 0x4c, 0xde, 0x5e, 0xe4, 0x8c, 0x76, 0x91,
	0x68, 0xdc, 0x2c, 0x41, 0x77, 0xeb, 0xe3, 0xe3, 0x75, 0x57, 0xb4, 0x56, 0x01, 0xcb, 0xec, 0x8f,
	0x61, 0xc5, 0x93, 0xbe, 0x49, 0xa6, 0x12, 0x42, 0x62, 0x44, 0x35, 0xe0, 0x8d, 0xe3, 0x5b, 0x8a,
	0xa0, 0x13, 0x76, 0x88, 0x72, 0xf9, 0x58, 0xd6, 0x5a, 0x21, 0xcd, 0x63, 0xef, 0x0c, 0x53, 0xf9,
	0x6d, 0x1b, 0x8d, 0x25, 0x25, 0xdc, 0xd7, 0x32, 0xe7, 0x4f, 0x25, 0x75, 0xca, 0x36, 0xa6, 0x5d,
	0x4c, 0xff, 0x07, 0xa7, 0xdc, 0x81, 0x5a, 0x88, 0x1d, 0xea, 0xf5, 0xc8, 0xa4, 0xc3, 0xde, 0x55,
	0xbc, 0xc6, 0xa5, 0x23, 0x3f, 0x86, 0x3b, 0xc3, 0x26, 0xc6, 0x9e, 0xfc, 0x9d, 0xa2, 0xba, 0x39,
	0xbf, 0xfd, 0x11, 0xd8, 0xb2, 0x0d, 0xc5, 0x96, 0xd7, 0x49, 0x69, 0x44, 0x12, 0x96, 0x72, 0x39,
	0xff, 0xfb, 0x39, 0x1e, 0x92, 0x1f, 0xb3, 0x94, 0x3b, 0x7f, 0x9e, 0x86, 0x5b, 0x83, 0xd6, 0x78,
	0x89, 0xa1, 0xc7, 0x22, 0x9c, 0x98, 0xb6, 0x4d, 0x28, 0x77, 0x68, 0x84, 0x97, 0xd7, 0xeb, 0x39,
	0x01, 0xcb, 0x27, 0xd5, 0x0b, 0xb8, 0xcf, 0x72, 0xce, 0x4e, 0xc5, 0xf7, 0x48, 0x06, 0x13, 0x5a,
	0x0d, 0x44, 0x75, 0x83, 0xcf, 0x6f, 0xdf, 0x19, 0xbf, 0x4a, 0xbb, 0xf7, 0xfa, 0xaa, 0x03, 0x50,
	0x72, 0x32, 0xfb, 0x27, 0x50, 0xcb, 0x13, 0xce, 0xae, 0x30, 0xab, 0x9e, 0x37, 0xab, 0xf5, 0xb7,
	0x6d, 0xa1, 0x6e, 0xd5, 0x18, 0xb8, 0x64, 0xfc, 0xbb, 0x30, 0x17, 0x32, 0x8f, 0x0a, 0xaa, 0x7e,
	0xe5, 0xdd, 0xaf, 0x5f, 0xca, 0x4e, 0x7d, 0x5f, 0x53, 0xdc, 0x3e, 0x59, 0xec, 0x48, 0xfd, 0x84,
	0x6c, 0xcb, 0x45, 0xca, 0x64, 0xa4, 0x6c, 0x32, 0xb2, 0x6d, 0xef, 0xc2, 0x83, 0x54, 0xcc, 0xfe,
	0x8f, 0xb6, 0x49, 0xc7, 0x23, 0x17, 0xca, 0x1a, 0x11, 0x48, 0xc6, 0x69, 0x94, 0xc8, 0xd5, 0xca,
	0xa4, 0xfa, 0x9e, 0x66, 0x36, 0x3d, 0xed, 0xf5, 0x99, 0xa1, 0xd9, 0x1b, 0x30, 0xe7, 0xe5, 0x69,
	0x8a, 0xb1, 0xd7, 0x93, 0x4b, 0x56, 0x7f, 0xda, 0x18, 0xb4, 0x96, 0xc0, 0x9c, 0x89, 0x51, 0xb0,
	0x43, 0xca, 0x03, 0x9e, 0xfb, 0xea, 0x8a, 0x2d, 0x19, 0xb6, 0x41, 0xc5, 0xf0, 0x0c, 0x59, 0xdc,
	0x51, 0x94, 0x52, 0x81, 0x32, 0x80, 0x45, 0x43, 0xc8, 0x4d, 0x24, 0xed, 0xc9, 0x3e, 0x36, 0xab,
	0xaa, 0x01, 0x9d, 0x7f, 0x94, 0xe0, 0x1d, 0x99, 0x28, 0x16, 0xc7, 0xe8, 0x09, 0xc7, 0x6d, 0x4e,
	0x79, 0x9e, 0xd9, 0xfb, 0x30, 0x93, 0xc9, 0x5f, 0xd2, 0xf9, 0xd2, 0xf6, 0x4a, 0xbd, 0xd9, 0x18,
	0x25, 0x3d, 0x5e, 0xbf, 0x8c, 0x91, 0xbd, 0x9d, 0x17, 0xbb, 0xa4, 0xbd, 0xdb, 0x6e, 0xb7, 0x8e,
	0x0e, 0x5d, 0x6d, 0xe3, 0xaa, 0x7b, 0xa4, 0xf4, 0xf6, 0x7b, 0xe4, 0x03, 0x58, 0xfa, 0x2c, 0xc7,
	0x1c, 0x49, 0xc2, 0xb2, 0x80, 0x9b, 0x77, 0x98, 0x79, 0x26, 0x2d, 0x4a, 0xd9, 0xb1, 0x16, 0x89,
	0x4a, 0x2a, 0x72, 0x16, 0xbc, 0x52, 0xcb, 0xb6, 0x21, 0x96, 0x25, 0xde, 0x0e, 0x5e, 0xa1, 0x58,
	0xac, 0x2e, 0x68, 0x20, 0xa2, 0xf0, 0x58, 0xec, 0x67, 0xb2, 0x57, 0x0c, 0x6d, 0x5e, 0x48, 0xda,
	0x4a, 0x60, 0x1f, 0xc0, 0x06, 0x66, 0x3c, 0x88, 0x28, 0x47, 0x9f, 0x14, 0x55, 0xc4, 0x23, 0x9a,
	0x06, 0x71, 0x10, 0x77, 0x64, 0xb7, 0x18, 0xe5, 0xd5, 0x3e, 0xfb, 0xe5, 0xc0, 0x8a, 0x6b, 0xa8,
	0xce, 0xbf, 0xa6, 0xe0, 0xfd, 0xc6, 0x4b, 0x96, 0x9e, 0x67, 0x67, 0x2c, 0x21, 0xc7, 0x2c, 0xc9,
	0x43, 0xca, 0xb1, 0xc5, 0x31, 0x7a, 0x8a, 0xfd, 0x26, 0xcf, 0x88, 0x1e, 0x3e, 0xe2, 0x05, 0x42,
	0x93, 0x44, 0x0f, 0x0f, 0x93, 0x20, 0x05, 0xd9, 0x1d, 0x28, 0x87, 0x34, 0xee, 0xe4, 0xb4, 0x83,
	0xe6, 0xb6, 0x6b, 0xd5, 0xaf, 0x6f, 0xbb, 0x3e, 0x2a, 0xd8, 0xd7, 0xc6, 0x9e, 0x88, 0x3d, 0xd6,
	0x1d, 0xd8, 0xae, 0xfd, 0xda, 0x82, 0xdb, 0xea, 0xf1, 0x3e, 0xa2, 0x22, 0x56, 0x7a, 0xf1, 0x71,
	0x04, 0x1c, 0xa3, 0x91, 0x18, 0x0b, 0xb8, 0xd8, 0x7a, 0xc5, 0x2f, 0xe2, 0x0f, 0x34, 0x87, 0x9e,
	0x4b, 0xcb, 0xc1, 0x88, 0xd9, 0x0f, 0x61, 0x99, 0xc5, 0x48, 0x12, 0x4c, 0xfb, 0x4f, 0x8b, 0xa9,
	0xe2, 0x52, 0xcd, 0x62, 0x3c, 0x16, 0xfb, 0x95, 0x14, 0xd5, 0x7e, 0x67, 0xc1, 0xea, 0x5b, 0xcf,
	0xa2, 0xbe, 0x20, 0x05, 0xc8, 0x20, 0xcb, 0x83, 0x2f, 0x48, 0xa1, 0x36, 0xc2, 0x42, 0x21, 0x3a,
	0x93, 0xce, 0x9d, 0x6f, 0x92, 0xce, 0xb1, 0x19, 0x72, 0x87, 0xcc, 0x3a, 0x08, 0x9b, 0x03, 0x8b,
	0x4d, 0xe4, 0x0d, 0x16, 0xf3, 0x34, 0x38, 0xc9, 0x39, 0x4b, 0xaf, 0x57, 0xf3, 0xe1, 0x84, 0x97,
	0xc6, 0x27, 0xdc, 0xd9, 0x03, 0xe7, 0x6d, 0x6e, 0xf4, 0x1e, 0xe3, 0xc0, 0x82, 0x57, 0x10, 0x54,
	0x2d, 0xb9, 0x92, 0x0f, 0x61, 0xce, 0x6f, 0x6f, 0xc2, 0xa3, 0x81, 0xa9, 0x36, 0x72, 0x71, 0xbe,
	0x63, 0xda, 0x8b, 0x30, 0xe6, 0x6e, 0x1e, 0xe2, 0x7f, 0x30, 0x6a, 0xfb, 0x15, 0xdc, 0xa3, 0x59,
	0xc6, 0xbc, 0x40, 0x7d, 0x6a, 0xc6, 0xa9, 0x78, 0x17, 0x9b, 0x69, 0xf3, 0xc3, 0xfa, 0xb5, 0x82,
	0xa9, 0x1b, 0xd2, 0x08, 0xc1, 0xbd, 0x3b, 0x70, 0x60, 0x28, 0x9f, 0x0a, 0xf3, 0xf6, 0x19, 0x54,
	0x12, 0x9a, 0xf2, 0x78, 0xd0, 0x71, 0x66, 0x12, 0xfd, 0xe0, 0x9a, 0x2e, 0x8f, 0x95, 0xfa, 0xa8,
	0xc7, 0x65, 0x6d, 0x56, 0x37, 0x6b, 0x56, 0xfb, 0x83, 0x05, 0x77, 0xaf, 0x08, 0xcf, 0xae, 0x43,
	0x65, 0xe8, 0xd8, 0xe6, 0xff, 0x41, 0xe6, 0xbf, 0xa8, 0x4b, 0x17, 0x85, 0xa0, 0x5b, 0xbe, 0xd8,
	0x17, 0x52, 0xec, 0x62, 0x9c, 0xcb, 0x6f, 0xc5, 0xc3, 0x98, 0x9b, 0x15, 0xdb, 0x0c, 0x80, 0x5b,
	0x5a, 0x7e, 0xdc, 0x17, 0x8b, 0xaf, 0x31, 0xcd, 0x43, 0x1c, 0xfa, 0x1a, 0x8b, 0x13, 0x61, 0x59,
	0x48, 0x0b, 0x2d, 0x5c, 0xfb, 0x8d, 0x05, 0x77, 0xc6, 0x9f, 0x4e, 0x5c, 0xb5, 0xe6, 0xf1, 0x3b,
	0x52, 0xf9, 0xb2, 0xc6, 0xff, 0x5b, 0x51, 0x3a, 0x5b, 0xf0, 0x7f, 0x93, 0x0a, 0xa5, 0xfa, 0xfe,
	0xfd, 0xbf, 0x5a, 0x60, 0x5f, 0x1e, 0x57, 0xf6, 0x43, 0x98, 0x34, 0xc4, 0x2a, 0x37, 0xec, 0x77,
	0x61, 0x63, 0x0c, 0xa9, 0xd9, 0x20, 0xcd, 0xa3, 0xd6, 0x61, 0x93, 0x3c, 0x3d, 0x7a, 0x79, 0x58,
	0xb1, 0xec, 0x4d, 0x58, 0x1d, 0xc3, 0x3a, 0x3c, 0xea, 0x1b, 0x2a, 0xd9, 0xdf, 0x86, 0x0f, 0xdf,
	0x4a, 0x21, 0xad, 0x43, 0xb2, 0x7f, 0xd4, 0x3c, 0x3a, 0x24, 0x3f, 0x7e, 0xbe, 0xfb, 0x7c, 0xb7,
	0x32, 0x65, 0xaf, 0xc3, 0xfd, 0x2b, 0x34, 0x9e, 0xed, 0xee, 0x1c, 0x54, 0xa6, 0x9f, 0xdc, 0xfe,
	0xea, 0xcd, 0x9a, 0xf5, 0x97, 0x37, 0x6b, 0xd6, 0xdf, 0xdf, 0xac, 0x59, 0xbf, 0xfc, 0x7a, 0xed,
	0xc6, 0x9e, 0xf5, 0xda, 0xba, 0xf1, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x26, 0x92, 0xae, 0x4d,
	0xe5, 0x17, 0x00, 0x00,
}
