// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fatdemo.proto

/*
	Package fatdemo is a generated protocol buffer package.

	It is generated from these files:
		fatdemo.proto

	It has these top-level messages:
		MLDict
		MLEvent
		MLMatchState
		MLRoundState
		MLWeaponState
		MLPlayerState
		MLGameState
		MLDemoHeader
		MLTick
*/
package fatdemo

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import netmessages "."

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EHitGroup int32

const (
	EHitGroup_EHG_Generic  EHitGroup = 0
	EHitGroup_EHG_Head     EHitGroup = 1
	EHitGroup_EHG_Chest    EHitGroup = 2
	EHitGroup_EHG_Stomach  EHitGroup = 3
	EHitGroup_EHG_LeftArm  EHitGroup = 4
	EHitGroup_EHG_RightArm EHitGroup = 5
	EHitGroup_EHG_LeftLeg  EHitGroup = 6
	EHitGroup_EHG_RightLeg EHitGroup = 7
	EHitGroup_EHG_Gear     EHitGroup = 8
	EHitGroup_EHG_Miss     EHitGroup = 9
)

var EHitGroup_name = map[int32]string{
	0: "EHG_Generic",
	1: "EHG_Head",
	2: "EHG_Chest",
	3: "EHG_Stomach",
	4: "EHG_LeftArm",
	5: "EHG_RightArm",
	6: "EHG_LeftLeg",
	7: "EHG_RightLeg",
	8: "EHG_Gear",
	9: "EHG_Miss",
}
var EHitGroup_value = map[string]int32{
	"EHG_Generic":  0,
	"EHG_Head":     1,
	"EHG_Chest":    2,
	"EHG_Stomach":  3,
	"EHG_LeftArm":  4,
	"EHG_RightArm": 5,
	"EHG_LeftLeg":  6,
	"EHG_RightLeg": 7,
	"EHG_Gear":     8,
	"EHG_Miss":     9,
}

func (x EHitGroup) Enum() *EHitGroup {
	p := new(EHitGroup)
	*p = x
	return p
}
func (x EHitGroup) String() string {
	return proto.EnumName(EHitGroup_name, int32(x))
}
func (x *EHitGroup) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EHitGroup_value, data, "EHitGroup")
	if err != nil {
		return err
	}
	*x = EHitGroup(value)
	return nil
}
func (EHitGroup) EnumDescriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{0} }

type ETeam int32

const (
	ETeam_ET_Unknown   ETeam = 0
	ETeam_ET_Spectator ETeam = 1
	ETeam_ET_Terrorist ETeam = 2
	ETeam_ET_CT        ETeam = 3
)

var ETeam_name = map[int32]string{
	0: "ET_Unknown",
	1: "ET_Spectator",
	2: "ET_Terrorist",
	3: "ET_CT",
}
var ETeam_value = map[string]int32{
	"ET_Unknown":   0,
	"ET_Spectator": 1,
	"ET_Terrorist": 2,
	"ET_CT":        3,
}

func (x ETeam) Enum() *ETeam {
	p := new(ETeam)
	*p = x
	return p
}
func (x ETeam) String() string {
	return proto.EnumName(ETeam_name, int32(x))
}
func (x *ETeam) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ETeam_value, data, "ETeam")
	if err != nil {
		return err
	}
	*x = ETeam(value)
	return nil
}
func (ETeam) EnumDescriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{1} }

type EWeaponType int32

const (
	EWeaponType_EWT_Knife         EWeaponType = 0
	EWeaponType_EWT_Pistol        EWeaponType = 1
	EWeaponType_EWT_SubMachineGun EWeaponType = 2
	EWeaponType_EWT_Rifle         EWeaponType = 3
	EWeaponType_EWT_Shotgun       EWeaponType = 4
	EWeaponType_EWT_SniperRifle   EWeaponType = 5
	EWeaponType_EWT_MachineGun    EWeaponType = 6
	EWeaponType_EWT_C4            EWeaponType = 7
	EWeaponType_EWT_Grenade       EWeaponType = 8
	EWeaponType_EWT_Equipment     EWeaponType = 9
	EWeaponType_EWT_StackableItem EWeaponType = 10
	EWeaponType_EWT_Unknown       EWeaponType = 11
)

var EWeaponType_name = map[int32]string{
	0:  "EWT_Knife",
	1:  "EWT_Pistol",
	2:  "EWT_SubMachineGun",
	3:  "EWT_Rifle",
	4:  "EWT_Shotgun",
	5:  "EWT_SniperRifle",
	6:  "EWT_MachineGun",
	7:  "EWT_C4",
	8:  "EWT_Grenade",
	9:  "EWT_Equipment",
	10: "EWT_StackableItem",
	11: "EWT_Unknown",
}
var EWeaponType_value = map[string]int32{
	"EWT_Knife":         0,
	"EWT_Pistol":        1,
	"EWT_SubMachineGun": 2,
	"EWT_Rifle":         3,
	"EWT_Shotgun":       4,
	"EWT_SniperRifle":   5,
	"EWT_MachineGun":    6,
	"EWT_C4":            7,
	"EWT_Grenade":       8,
	"EWT_Equipment":     9,
	"EWT_StackableItem": 10,
	"EWT_Unknown":       11,
}

func (x EWeaponType) Enum() *EWeaponType {
	p := new(EWeaponType)
	*p = x
	return p
}
func (x EWeaponType) String() string {
	return proto.EnumName(EWeaponType_name, int32(x))
}
func (x *EWeaponType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EWeaponType_value, data, "EWeaponType")
	if err != nil {
		return err
	}
	*x = EWeaponType(value)
	return nil
}
func (EWeaponType) EnumDescriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{2} }

type MLDict struct {
	Key       string  `protobuf:"bytes,1,opt,name=key" json:"key"`
	ValString string  `protobuf:"bytes,2,opt,name=val_string,json=valString" json:"val_string"`
	ValInt    int32   `protobuf:"varint,3,opt,name=val_int,json=valInt" json:"val_int"`
	ValFloat  float32 `protobuf:"fixed32,4,opt,name=val_float,json=valFloat" json:"val_float"`
}

func (m *MLDict) Reset()                    { *m = MLDict{} }
func (m *MLDict) String() string            { return proto.CompactTextString(m) }
func (*MLDict) ProtoMessage()               {}
func (*MLDict) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{0} }

func (m *MLDict) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *MLDict) GetValString() string {
	if m != nil {
		return m.ValString
	}
	return ""
}

func (m *MLDict) GetValInt() int32 {
	if m != nil {
		return m.ValInt
	}
	return 0
}

func (m *MLDict) GetValFloat() float32 {
	if m != nil {
		return m.ValFloat
	}
	return 0
}

type MLEvent struct {
	EventName string    `protobuf:"bytes,1,opt,name=event_name,json=eventName" json:"event_name"`
	Data      []*MLDict `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
}

func (m *MLEvent) Reset()                    { *m = MLEvent{} }
func (m *MLEvent) String() string            { return proto.CompactTextString(m) }
func (*MLEvent) ProtoMessage()               {}
func (*MLEvent) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{1} }

func (m *MLEvent) GetEventName() string {
	if m != nil {
		return m.EventName
	}
	return ""
}

func (m *MLEvent) GetData() []*MLDict {
	if m != nil {
		return m.Data
	}
	return nil
}

type MLMatchState struct {
	GameMode string `protobuf:"bytes,1,opt,name=game_mode,json=gameMode" json:"game_mode"`
	Phase    string `protobuf:"bytes,2,opt,name=phase" json:"phase"`
	Round    int32  `protobuf:"varint,3,opt,name=round" json:"round"`
	ScoreCt  int32  `protobuf:"varint,4,opt,name=score_ct,json=scoreCt" json:"score_ct"`
	ScoreT   int32  `protobuf:"varint,5,opt,name=score_t,json=scoreT" json:"score_t"`
}

func (m *MLMatchState) Reset()                    { *m = MLMatchState{} }
func (m *MLMatchState) String() string            { return proto.CompactTextString(m) }
func (*MLMatchState) ProtoMessage()               {}
func (*MLMatchState) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{2} }

func (m *MLMatchState) GetGameMode() string {
	if m != nil {
		return m.GameMode
	}
	return ""
}

func (m *MLMatchState) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *MLMatchState) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *MLMatchState) GetScoreCt() int32 {
	if m != nil {
		return m.ScoreCt
	}
	return 0
}

func (m *MLMatchState) GetScoreT() int32 {
	if m != nil {
		return m.ScoreT
	}
	return 0
}

type MLRoundState struct {
	Phase     string `protobuf:"bytes,1,opt,name=phase" json:"phase"`
	WinTeam   *ETeam `protobuf:"varint,2,opt,name=win_team,json=winTeam,enum=ETeam,def=0" json:"win_team,omitempty"`
	BombState string `protobuf:"bytes,3,opt,name=bomb_state,json=bombState" json:"bomb_state"`
}

func (m *MLRoundState) Reset()                    { *m = MLRoundState{} }
func (m *MLRoundState) String() string            { return proto.CompactTextString(m) }
func (*MLRoundState) ProtoMessage()               {}
func (*MLRoundState) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{3} }

const Default_MLRoundState_WinTeam ETeam = ETeam_ET_Unknown

func (m *MLRoundState) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *MLRoundState) GetWinTeam() ETeam {
	if m != nil && m.WinTeam != nil {
		return *m.WinTeam
	}
	return Default_MLRoundState_WinTeam
}

func (m *MLRoundState) GetBombState() string {
	if m != nil {
		return m.BombState
	}
	return ""
}

type MLWeaponState struct {
	Index       int32        `protobuf:"varint,1,opt,name=index" json:"index"`
	Name        string       `protobuf:"bytes,2,opt,name=name" json:"name"`
	Type        *EWeaponType `protobuf:"varint,3,opt,name=type,enum=EWeaponType,def=0" json:"type,omitempty"`
	AmmoClip    int32        `protobuf:"varint,4,opt,name=ammo_clip,json=ammoClip" json:"ammo_clip"`
	AmmoClipMax int32        `protobuf:"varint,5,opt,name=ammo_clip_max,json=ammoClipMax" json:"ammo_clip_max"`
	AmmoReserve int32        `protobuf:"varint,6,opt,name=ammo_reserve,json=ammoReserve" json:"ammo_reserve"`
	State       string       `protobuf:"bytes,7,opt,name=state" json:"state"`
	RecoilIndex float32      `protobuf:"fixed32,8,opt,name=recoil_index,json=recoilIndex" json:"recoil_index"`
}

func (m *MLWeaponState) Reset()                    { *m = MLWeaponState{} }
func (m *MLWeaponState) String() string            { return proto.CompactTextString(m) }
func (*MLWeaponState) ProtoMessage()               {}
func (*MLWeaponState) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{4} }

const Default_MLWeaponState_Type EWeaponType = EWeaponType_EWT_Knife

func (m *MLWeaponState) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MLWeaponState) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MLWeaponState) GetType() EWeaponType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_MLWeaponState_Type
}

func (m *MLWeaponState) GetAmmoClip() int32 {
	if m != nil {
		return m.AmmoClip
	}
	return 0
}

func (m *MLWeaponState) GetAmmoClipMax() int32 {
	if m != nil {
		return m.AmmoClipMax
	}
	return 0
}

func (m *MLWeaponState) GetAmmoReserve() int32 {
	if m != nil {
		return m.AmmoReserve
	}
	return 0
}

func (m *MLWeaponState) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *MLWeaponState) GetRecoilIndex() float32 {
	if m != nil {
		return m.RecoilIndex
	}
	return 0
}

type MLPlayerState struct {
	AccountId   int32                   `protobuf:"varint,1,opt,name=account_id,json=accountId" json:"account_id"`
	UserId      int32                   `protobuf:"varint,2,opt,name=user_id,json=userId" json:"user_id"`
	Entindex    int32                   `protobuf:"varint,3,opt,name=entindex" json:"entindex"`
	Name        string                  `protobuf:"bytes,4,opt,name=name" json:"name"`
	Clan        string                  `protobuf:"bytes,5,opt,name=clan" json:"clan"`
	Team        *ETeam                  `protobuf:"varint,6,opt,name=team,enum=ETeam,def=0" json:"team,omitempty"`
	Abspos      *netmessages.CMsgVector `protobuf:"bytes,7,opt,name=abspos" json:"abspos,omitempty"`
	Eyeangle    *netmessages.CMsgQAngle `protobuf:"bytes,8,opt,name=eyeangle" json:"eyeangle,omitempty"`
	EyeangleFwd *netmessages.CMsgVector `protobuf:"bytes,9,opt,name=eyeangle_fwd,json=eyeangleFwd" json:"eyeangle_fwd,omitempty"`
	Health      int32                   `protobuf:"varint,10,opt,name=health" json:"health"`
	Armor       int32                   `protobuf:"varint,11,opt,name=armor" json:"armor"`
	Flashed     float32                 `protobuf:"fixed32,12,opt,name=flashed" json:"flashed"`
	Smoked      float32                 `protobuf:"fixed32,13,opt,name=smoked" json:"smoked"`
	Money       int32                   `protobuf:"varint,14,opt,name=money" json:"money"`
	RoundKills  int32                   `protobuf:"varint,15,opt,name=round_kills,json=roundKills" json:"round_kills"`
	RoundKillhs int32                   `protobuf:"varint,16,opt,name=round_killhs,json=roundKillhs" json:"round_killhs"`
	Burning     float32                 `protobuf:"fixed32,17,opt,name=burning" json:"burning"`
	Helmet      bool                    `protobuf:"varint,18,opt,name=helmet" json:"helmet"`
	DefuseKit   bool                    `protobuf:"varint,19,opt,name=defuse_kit,json=defuseKit" json:"defuse_kit"`
	Weapons     []*MLWeaponState        `protobuf:"bytes,20,rep,name=weapons" json:"weapons,omitempty"`
}

func (m *MLPlayerState) Reset()                    { *m = MLPlayerState{} }
func (m *MLPlayerState) String() string            { return proto.CompactTextString(m) }
func (*MLPlayerState) ProtoMessage()               {}
func (*MLPlayerState) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{5} }

const Default_MLPlayerState_Team ETeam = ETeam_ET_Unknown

func (m *MLPlayerState) GetAccountId() int32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *MLPlayerState) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MLPlayerState) GetEntindex() int32 {
	if m != nil {
		return m.Entindex
	}
	return 0
}

func (m *MLPlayerState) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MLPlayerState) GetClan() string {
	if m != nil {
		return m.Clan
	}
	return ""
}

func (m *MLPlayerState) GetTeam() ETeam {
	if m != nil && m.Team != nil {
		return *m.Team
	}
	return Default_MLPlayerState_Team
}

func (m *MLPlayerState) GetAbspos() *netmessages.CMsgVector {
	if m != nil {
		return m.Abspos
	}
	return nil
}

func (m *MLPlayerState) GetEyeangle() *netmessages.CMsgQAngle {
	if m != nil {
		return m.Eyeangle
	}
	return nil
}

func (m *MLPlayerState) GetEyeangleFwd() *netmessages.CMsgVector {
	if m != nil {
		return m.EyeangleFwd
	}
	return nil
}

func (m *MLPlayerState) GetHealth() int32 {
	if m != nil {
		return m.Health
	}
	return 0
}

func (m *MLPlayerState) GetArmor() int32 {
	if m != nil {
		return m.Armor
	}
	return 0
}

func (m *MLPlayerState) GetFlashed() float32 {
	if m != nil {
		return m.Flashed
	}
	return 0
}

func (m *MLPlayerState) GetSmoked() float32 {
	if m != nil {
		return m.Smoked
	}
	return 0
}

func (m *MLPlayerState) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *MLPlayerState) GetRoundKills() int32 {
	if m != nil {
		return m.RoundKills
	}
	return 0
}

func (m *MLPlayerState) GetRoundKillhs() int32 {
	if m != nil {
		return m.RoundKillhs
	}
	return 0
}

func (m *MLPlayerState) GetBurning() float32 {
	if m != nil {
		return m.Burning
	}
	return 0
}

func (m *MLPlayerState) GetHelmet() bool {
	if m != nil {
		return m.Helmet
	}
	return false
}

func (m *MLPlayerState) GetDefuseKit() bool {
	if m != nil {
		return m.DefuseKit
	}
	return false
}

func (m *MLPlayerState) GetWeapons() []*MLWeaponState {
	if m != nil {
		return m.Weapons
	}
	return nil
}

type MLGameState struct {
	Match   *MLMatchState    `protobuf:"bytes,1,opt,name=match" json:"match,omitempty"`
	Round   *MLRoundState    `protobuf:"bytes,2,opt,name=round" json:"round,omitempty"`
	Players []*MLPlayerState `protobuf:"bytes,3,rep,name=players" json:"players,omitempty"`
}

func (m *MLGameState) Reset()                    { *m = MLGameState{} }
func (m *MLGameState) String() string            { return proto.CompactTextString(m) }
func (*MLGameState) ProtoMessage()               {}
func (*MLGameState) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{6} }

func (m *MLGameState) GetMatch() *MLMatchState {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *MLGameState) GetRound() *MLRoundState {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *MLGameState) GetPlayers() []*MLPlayerState {
	if m != nil {
		return m.Players
	}
	return nil
}

type MLDemoHeader struct {
	MapName       string `protobuf:"bytes,1,opt,name=map_name,json=mapName" json:"map_name"`
	TickRate      int32  `protobuf:"varint,2,opt,name=tick_rate,json=tickRate" json:"tick_rate"`
	Version       uint32 `protobuf:"varint,3,opt,name=version" json:"version"`
	SteamUniverse uint32 `protobuf:"varint,4,opt,name=steam_universe,json=steamUniverse" json:"steam_universe"`
}

func (m *MLDemoHeader) Reset()                    { *m = MLDemoHeader{} }
func (m *MLDemoHeader) String() string            { return proto.CompactTextString(m) }
func (*MLDemoHeader) ProtoMessage()               {}
func (*MLDemoHeader) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{7} }

func (m *MLDemoHeader) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

func (m *MLDemoHeader) GetTickRate() int32 {
	if m != nil {
		return m.TickRate
	}
	return 0
}

func (m *MLDemoHeader) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *MLDemoHeader) GetSteamUniverse() uint32 {
	if m != nil {
		return m.SteamUniverse
	}
	return 0
}

type MLTick struct {
	TickCount int32        `protobuf:"varint,1,opt,name=tick_count,json=tickCount" json:"tick_count"`
	State     *MLGameState `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	Events    []*MLEvent   `protobuf:"bytes,3,rep,name=events" json:"events,omitempty"`
}

func (m *MLTick) Reset()                    { *m = MLTick{} }
func (m *MLTick) String() string            { return proto.CompactTextString(m) }
func (*MLTick) ProtoMessage()               {}
func (*MLTick) Descriptor() ([]byte, []int) { return fileDescriptorFatdemo, []int{8} }

func (m *MLTick) GetTickCount() int32 {
	if m != nil {
		return m.TickCount
	}
	return 0
}

func (m *MLTick) GetState() *MLGameState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *MLTick) GetEvents() []*MLEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func init() {
	proto.RegisterType((*MLDict)(nil), "MLDict")
	proto.RegisterType((*MLEvent)(nil), "MLEvent")
	proto.RegisterType((*MLMatchState)(nil), "MLMatchState")
	proto.RegisterType((*MLRoundState)(nil), "MLRoundState")
	proto.RegisterType((*MLWeaponState)(nil), "MLWeaponState")
	proto.RegisterType((*MLPlayerState)(nil), "MLPlayerState")
	proto.RegisterType((*MLGameState)(nil), "MLGameState")
	proto.RegisterType((*MLDemoHeader)(nil), "MLDemoHeader")
	proto.RegisterType((*MLTick)(nil), "MLTick")
	proto.RegisterEnum("EHitGroup", EHitGroup_name, EHitGroup_value)
	proto.RegisterEnum("ETeam", ETeam_name, ETeam_value)
	proto.RegisterEnum("EWeaponType", EWeaponType_name, EWeaponType_value)
}
func (m *MLDict) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLDict) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.Key)))
	i += copy(dAtA[i:], m.Key)
	dAtA[i] = 0x12
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.ValString)))
	i += copy(dAtA[i:], m.ValString)
	dAtA[i] = 0x18
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.ValInt))
	dAtA[i] = 0x25
	i++
	i = encodeFixed32Fatdemo(dAtA, i, uint32(math.Float32bits(float32(m.ValFloat))))
	return i, nil
}

func (m *MLEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.EventName)))
	i += copy(dAtA[i:], m.EventName)
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFatdemo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MLMatchState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLMatchState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.GameMode)))
	i += copy(dAtA[i:], m.GameMode)
	dAtA[i] = 0x12
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.Phase)))
	i += copy(dAtA[i:], m.Phase)
	dAtA[i] = 0x18
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.Round))
	dAtA[i] = 0x20
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.ScoreCt))
	dAtA[i] = 0x28
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.ScoreT))
	return i, nil
}

func (m *MLRoundState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLRoundState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.Phase)))
	i += copy(dAtA[i:], m.Phase)
	if m.WinTeam != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(*m.WinTeam))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.BombState)))
	i += copy(dAtA[i:], m.BombState)
	return i, nil
}

func (m *MLWeaponState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLWeaponState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x12
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Type != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(*m.Type))
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.AmmoClip))
	dAtA[i] = 0x28
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.AmmoClipMax))
	dAtA[i] = 0x30
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.AmmoReserve))
	dAtA[i] = 0x3a
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.State)))
	i += copy(dAtA[i:], m.State)
	dAtA[i] = 0x45
	i++
	i = encodeFixed32Fatdemo(dAtA, i, uint32(math.Float32bits(float32(m.RecoilIndex))))
	return i, nil
}

func (m *MLPlayerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLPlayerState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.AccountId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.UserId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.Entindex))
	dAtA[i] = 0x22
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.Clan)))
	i += copy(dAtA[i:], m.Clan)
	if m.Team != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(*m.Team))
	}
	if m.Abspos != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(m.Abspos.Size()))
		n1, err := m.Abspos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Eyeangle != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(m.Eyeangle.Size()))
		n2, err := m.Eyeangle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.EyeangleFwd != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(m.EyeangleFwd.Size()))
		n3, err := m.EyeangleFwd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	dAtA[i] = 0x50
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.Health))
	dAtA[i] = 0x58
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.Armor))
	dAtA[i] = 0x65
	i++
	i = encodeFixed32Fatdemo(dAtA, i, uint32(math.Float32bits(float32(m.Flashed))))
	dAtA[i] = 0x6d
	i++
	i = encodeFixed32Fatdemo(dAtA, i, uint32(math.Float32bits(float32(m.Smoked))))
	dAtA[i] = 0x70
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.Money))
	dAtA[i] = 0x78
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.RoundKills))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.RoundKillhs))
	dAtA[i] = 0x8d
	i++
	dAtA[i] = 0x1
	i++
	i = encodeFixed32Fatdemo(dAtA, i, uint32(math.Float32bits(float32(m.Burning))))
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	if m.Helmet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	if m.DefuseKit {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Weapons) > 0 {
		for _, msg := range m.Weapons {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintFatdemo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MLGameState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLGameState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Match != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(m.Match.Size()))
		n4, err := m.Match.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Round != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(m.Round.Size()))
		n5, err := m.Round.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintFatdemo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MLDemoHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLDemoHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(len(m.MapName)))
	i += copy(dAtA[i:], m.MapName)
	dAtA[i] = 0x10
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.TickRate))
	dAtA[i] = 0x18
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.Version))
	dAtA[i] = 0x20
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.SteamUniverse))
	return i, nil
}

func (m *MLTick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLTick) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintFatdemo(dAtA, i, uint64(m.TickCount))
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFatdemo(dAtA, i, uint64(m.State.Size()))
		n6, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintFatdemo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Fatdemo(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Fatdemo(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFatdemo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MLDict) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovFatdemo(uint64(l))
	l = len(m.ValString)
	n += 1 + l + sovFatdemo(uint64(l))
	n += 1 + sovFatdemo(uint64(m.ValInt))
	n += 5
	return n
}

func (m *MLEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventName)
	n += 1 + l + sovFatdemo(uint64(l))
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovFatdemo(uint64(l))
		}
	}
	return n
}

func (m *MLMatchState) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameMode)
	n += 1 + l + sovFatdemo(uint64(l))
	l = len(m.Phase)
	n += 1 + l + sovFatdemo(uint64(l))
	n += 1 + sovFatdemo(uint64(m.Round))
	n += 1 + sovFatdemo(uint64(m.ScoreCt))
	n += 1 + sovFatdemo(uint64(m.ScoreT))
	return n
}

func (m *MLRoundState) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	n += 1 + l + sovFatdemo(uint64(l))
	if m.WinTeam != nil {
		n += 1 + sovFatdemo(uint64(*m.WinTeam))
	}
	l = len(m.BombState)
	n += 1 + l + sovFatdemo(uint64(l))
	return n
}

func (m *MLWeaponState) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovFatdemo(uint64(m.Index))
	l = len(m.Name)
	n += 1 + l + sovFatdemo(uint64(l))
	if m.Type != nil {
		n += 1 + sovFatdemo(uint64(*m.Type))
	}
	n += 1 + sovFatdemo(uint64(m.AmmoClip))
	n += 1 + sovFatdemo(uint64(m.AmmoClipMax))
	n += 1 + sovFatdemo(uint64(m.AmmoReserve))
	l = len(m.State)
	n += 1 + l + sovFatdemo(uint64(l))
	n += 5
	return n
}

func (m *MLPlayerState) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovFatdemo(uint64(m.AccountId))
	n += 1 + sovFatdemo(uint64(m.UserId))
	n += 1 + sovFatdemo(uint64(m.Entindex))
	l = len(m.Name)
	n += 1 + l + sovFatdemo(uint64(l))
	l = len(m.Clan)
	n += 1 + l + sovFatdemo(uint64(l))
	if m.Team != nil {
		n += 1 + sovFatdemo(uint64(*m.Team))
	}
	if m.Abspos != nil {
		l = m.Abspos.Size()
		n += 1 + l + sovFatdemo(uint64(l))
	}
	if m.Eyeangle != nil {
		l = m.Eyeangle.Size()
		n += 1 + l + sovFatdemo(uint64(l))
	}
	if m.EyeangleFwd != nil {
		l = m.EyeangleFwd.Size()
		n += 1 + l + sovFatdemo(uint64(l))
	}
	n += 1 + sovFatdemo(uint64(m.Health))
	n += 1 + sovFatdemo(uint64(m.Armor))
	n += 5
	n += 5
	n += 1 + sovFatdemo(uint64(m.Money))
	n += 1 + sovFatdemo(uint64(m.RoundKills))
	n += 2 + sovFatdemo(uint64(m.RoundKillhs))
	n += 6
	n += 3
	n += 3
	if len(m.Weapons) > 0 {
		for _, e := range m.Weapons {
			l = e.Size()
			n += 2 + l + sovFatdemo(uint64(l))
		}
	}
	return n
}

func (m *MLGameState) Size() (n int) {
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovFatdemo(uint64(l))
	}
	if m.Round != nil {
		l = m.Round.Size()
		n += 1 + l + sovFatdemo(uint64(l))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovFatdemo(uint64(l))
		}
	}
	return n
}

func (m *MLDemoHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.MapName)
	n += 1 + l + sovFatdemo(uint64(l))
	n += 1 + sovFatdemo(uint64(m.TickRate))
	n += 1 + sovFatdemo(uint64(m.Version))
	n += 1 + sovFatdemo(uint64(m.SteamUniverse))
	return n
}

func (m *MLTick) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovFatdemo(uint64(m.TickCount))
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovFatdemo(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovFatdemo(uint64(l))
		}
	}
	return n
}

func sovFatdemo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFatdemo(x uint64) (n int) {
	return sovFatdemo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MLDict) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLDict: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLDict: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValInt", wireType)
			}
			m.ValInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValInt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ValFloat = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &MLDict{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLMatchState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLMatchState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLMatchState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreCt", wireType)
			}
			m.ScoreCt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreCt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreT", wireType)
			}
			m.ScoreT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreT |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLRoundState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLRoundState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLRoundState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinTeam", wireType)
			}
			var v ETeam
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ETeam(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WinTeam = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BombState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BombState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLWeaponState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLWeaponState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLWeaponState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v EWeaponType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (EWeaponType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmmoClip", wireType)
			}
			m.AmmoClip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmmoClip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmmoClipMax", wireType)
			}
			m.AmmoClipMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmmoClipMax |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmmoReserve", wireType)
			}
			m.AmmoReserve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmmoReserve |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoilIndex", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.RecoilIndex = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLPlayerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLPlayerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLPlayerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entindex", wireType)
			}
			m.Entindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Entindex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var v ETeam
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ETeam(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Team = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abspos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Abspos == nil {
				m.Abspos = &netmessages.CMsgVector{}
			}
			if err := m.Abspos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eyeangle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Eyeangle == nil {
				m.Eyeangle = &netmessages.CMsgQAngle{}
			}
			if err := m.Eyeangle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EyeangleFwd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EyeangleFwd == nil {
				m.EyeangleFwd = &netmessages.CMsgVector{}
			}
			if err := m.EyeangleFwd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Health |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Armor", wireType)
			}
			m.Armor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Armor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flashed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Flashed = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Smoked", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Smoked = float32(math.Float32frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundKills", wireType)
			}
			m.RoundKills = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundKills |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundKillhs", wireType)
			}
			m.RoundKillhs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundKillhs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burning", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Burning = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Helmet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Helmet = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefuseKit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefuseKit = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weapons = append(m.Weapons, &MLWeaponState{})
			if err := m.Weapons[len(m.Weapons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLGameState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLGameState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLGameState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MLMatchState{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Round == nil {
				m.Round = &MLRoundState{}
			}
			if err := m.Round.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &MLPlayerState{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLDemoHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLDemoHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLDemoHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickRate", wireType)
			}
			m.TickRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SteamUniverse", wireType)
			}
			m.SteamUniverse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SteamUniverse |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MLTick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLTick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLTick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickCount", wireType)
			}
			m.TickCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MLGameState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFatdemo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &MLEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFatdemo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFatdemo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFatdemo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFatdemo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFatdemo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFatdemo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFatdemo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFatdemo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFatdemo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFatdemo   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("fatdemo.proto", fileDescriptorFatdemo) }

var fileDescriptorFatdemo = []byte{
	// 1236 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x95, 0xcf, 0x8e, 0xdb, 0x46,
	0x12, 0xc6, 0x87, 0x1a, 0xfd, 0xa1, 0x9a, 0x92, 0xcc, 0x69, 0xef, 0x2e, 0x08, 0xef, 0xee, 0x58,
	0x96, 0x91, 0x58, 0xb0, 0x11, 0x1d, 0x06, 0x39, 0xf9, 0x66, 0xcb, 0xb2, 0x3c, 0x18, 0x29, 0x70,
	0x38, 0x72, 0x7c, 0x24, 0x7a, 0xc8, 0x92, 0xd4, 0x10, 0xd9, 0xcd, 0xb0, 0x5b, 0x1a, 0xcf, 0x25,
	0x40, 0x4e, 0xb9, 0xe6, 0x0d, 0x72, 0x0e, 0x90, 0xbc, 0x43, 0x8e, 0x3e, 0xe6, 0x09, 0x82, 0xc0,
	0xc9, 0x83, 0x04, 0xd5, 0x14, 0x69, 0x2a, 0x83, 0xdc, 0xa4, 0x5f, 0x7d, 0xac, 0xae, 0xfe, 0x58,
	0x55, 0x24, 0xdd, 0x25, 0xd3, 0x11, 0x24, 0x72, 0x94, 0x66, 0x52, 0xcb, 0x7b, 0x27, 0x02, 0x74,
	0x02, 0x4a, 0xb1, 0x15, 0xa8, 0x1c, 0x0d, 0xbe, 0xb3, 0x48, 0x73, 0x3e, 0x7b, 0xc1, 0x43, 0x4d,
	0xff, 0x43, 0x8e, 0x37, 0x70, 0xe3, 0x59, 0x7d, 0x6b, 0xd8, 0x7e, 0x5e, 0x7f, 0xff, 0xdb, 0xfd,
	0x23, 0x1f, 0x01, 0x7d, 0x48, 0xc8, 0x8e, 0xc5, 0x81, 0xd2, 0x19, 0x17, 0x2b, 0xaf, 0x56, 0x09,
	0xb7, 0x77, 0x2c, 0xbe, 0x34, 0x98, 0xfe, 0x9f, 0xb4, 0x50, 0xc4, 0x85, 0xf6, 0x8e, 0xfb, 0xd6,
	0xb0, 0xb1, 0x57, 0x34, 0x77, 0x2c, 0x3e, 0x17, 0x9a, 0x3e, 0x20, 0xa8, 0x0d, 0x96, 0xb1, 0x64,
	0xda, 0xab, 0xf7, 0xad, 0x61, 0x6d, 0x2f, 0xb0, 0x77, 0x2c, 0x7e, 0x89, 0x74, 0x70, 0x41, 0x5a,
	0xf3, 0xd9, 0x64, 0x07, 0x42, 0xe3, 0x89, 0x80, 0x3f, 0x02, 0xc1, 0x12, 0x38, 0x28, 0xa8, 0x6d,
	0xf8, 0x17, 0x2c, 0x01, 0xfa, 0x5f, 0x52, 0x8f, 0x98, 0x66, 0x5e, 0xad, 0x7f, 0x3c, 0x74, 0xce,
	0x5a, 0xa3, 0xfc, 0x16, 0xbe, 0x81, 0x83, 0x1f, 0x2d, 0xd2, 0x99, 0xcf, 0xe6, 0x4c, 0x87, 0xeb,
	0x4b, 0xcd, 0x34, 0x60, 0x01, 0x2b, 0x96, 0x40, 0x90, 0xc8, 0xe8, 0x30, 0xa3, 0x8d, 0x78, 0x2e,
	0x23, 0xa0, 0xf7, 0x48, 0x23, 0x5d, 0x33, 0x05, 0x07, 0x57, 0xcc, 0x11, 0xc6, 0x32, 0xb9, 0x15,
	0xd1, 0xc1, 0xe5, 0x72, 0x44, 0xef, 0x13, 0x5b, 0x85, 0x32, 0x83, 0x20, 0xcc, 0xaf, 0x56, 0x84,
	0x5b, 0x86, 0x8e, 0x35, 0x7a, 0x93, 0x0b, 0xb4, 0xd7, 0xa8, 0x7a, 0x63, 0xe0, 0x62, 0xf0, 0x0d,
	0x96, 0xea, 0x63, 0xaa, 0xbc, 0xd4, 0xb2, 0x0e, 0xeb, 0x76, 0x1d, 0x9f, 0x11, 0xfb, 0x9a, 0x8b,
	0x40, 0x03, 0x4b, 0x4c, 0x99, 0xbd, 0xb3, 0xe6, 0x68, 0xb2, 0x00, 0x96, 0x3c, 0x25, 0x93, 0x45,
	0xf0, 0x46, 0x6c, 0x84, 0xbc, 0x16, 0x7e, 0xeb, 0x9a, 0x0b, 0x84, 0x68, 0xe4, 0x95, 0x4c, 0xae,
	0x02, 0x85, 0x89, 0x4d, 0xed, 0xa5, 0x91, 0xc8, 0xcd, 0x79, 0x83, 0x9f, 0x6b, 0xa4, 0x3b, 0x9f,
	0xbd, 0x05, 0x96, 0x4a, 0x51, 0x56, 0xc0, 0x45, 0x04, 0xef, 0x4c, 0x05, 0xe5, 0x6d, 0x0d, 0xa2,
	0x1e, 0xa9, 0x9b, 0xb7, 0x52, 0x35, 0xc9, 0x10, 0xfa, 0x84, 0xd4, 0xf5, 0x4d, 0x9a, 0x1f, 0xd3,
	0x3b, 0xeb, 0x8c, 0x26, 0x79, 0xca, 0xc5, 0x4d, 0x0a, 0x4f, 0xdb, 0x93, 0xb7, 0x8b, 0xe0, 0x42,
	0xf0, 0x25, 0xf8, 0x46, 0x84, 0xef, 0x83, 0x25, 0x89, 0x0c, 0xc2, 0x98, 0xa7, 0x07, 0xae, 0xd9,
	0x88, 0xc7, 0x31, 0x4f, 0xe9, 0x90, 0x74, 0x4b, 0x49, 0x90, 0xb0, 0x77, 0x07, 0xe6, 0x39, 0x85,
	0x6c, 0xce, 0xde, 0xd1, 0x47, 0xa4, 0x63, 0x94, 0x19, 0x28, 0xc8, 0x76, 0xe0, 0x35, 0xff, 0x2e,
	0xf4, 0xf3, 0x00, 0x5e, 0x2c, 0xb7, 0xa2, 0x55, 0xb5, 0xd6, 0x20, 0x4c, 0x92, 0x41, 0x28, 0x39,
	0x36, 0x31, 0xde, 0xdd, 0xae, 0x74, 0xa9, 0x93, 0x47, 0xce, 0x31, 0x30, 0xf8, 0xa5, 0x81, 0x7e,
	0xbd, 0x8e, 0xd9, 0x0d, 0x64, 0xb9, 0x5f, 0x0f, 0x09, 0x61, 0x61, 0x28, 0xb7, 0x42, 0x07, 0x3c,
	0x3a, 0x30, 0xad, 0xbd, 0xe7, 0xe7, 0x11, 0x76, 0xc1, 0x56, 0x41, 0x86, 0x8a, 0x5a, 0xb5, 0x0b,
	0x10, 0x9e, 0x47, 0xb4, 0x4f, 0x6c, 0x10, 0x3a, 0x3f, 0xba, 0xda, 0x64, 0x25, 0x2d, 0x9d, 0xaf,
	0xdf, 0x72, 0xde, 0x23, 0xf5, 0x30, 0x66, 0xc2, 0x18, 0x54, 0x46, 0x90, 0xd0, 0x4f, 0x49, 0xdd,
	0xf4, 0x4a, 0xf3, 0x1f, 0x7b, 0xc5, 0xc4, 0xe9, 0x43, 0xd2, 0x64, 0x57, 0x2a, 0x95, 0xca, 0x38,
	0xe3, 0x9c, 0x39, 0xa3, 0xf1, 0x5c, 0xad, 0xbe, 0x82, 0x50, 0xcb, 0xcc, 0xdf, 0x87, 0xe8, 0x23,
	0x62, 0xc3, 0x0d, 0x30, 0xb1, 0x8a, 0xc1, 0xb8, 0x53, 0xc8, 0xbe, 0x7c, 0x86, 0xc8, 0x2f, 0x83,
	0x74, 0x44, 0x3a, 0xc5, 0xef, 0x60, 0x79, 0x1d, 0x79, 0xed, 0xdb, 0x39, 0x9d, 0x42, 0xf0, 0xf2,
	0x3a, 0xa2, 0xff, 0x23, 0xcd, 0x35, 0xb0, 0x58, 0xaf, 0x3d, 0x52, 0x75, 0x26, 0x67, 0xf8, 0xd2,
	0x58, 0x96, 0xc8, 0xcc, 0x73, 0xaa, 0xdd, 0x68, 0x10, 0x3d, 0x25, 0xad, 0x65, 0xcc, 0xd4, 0x1a,
	0x22, 0xaf, 0x53, 0x79, 0x5f, 0x05, 0xc4, 0xcc, 0x2a, 0x91, 0x1b, 0x88, 0xbc, 0x6e, 0x25, 0xbc,
	0x67, 0x98, 0x39, 0x91, 0x02, 0x6e, 0xbc, 0x5e, 0x35, 0xb3, 0x41, 0xf4, 0x13, 0xe2, 0x98, 0xf1,
	0x0e, 0x36, 0x3c, 0x8e, 0x95, 0x77, 0xa7, 0xa2, 0x20, 0x26, 0x70, 0x81, 0xdc, 0x74, 0x4d, 0x29,
	0x5b, 0x2b, 0xcf, 0xad, 0xb6, 0x5e, 0xa9, 0x5b, 0x2b, 0xac, 0xf4, 0x6a, 0x9b, 0x09, 0x5c, 0xa1,
	0x27, 0xd5, 0x4a, 0xf7, 0x30, 0xf7, 0x20, 0x4e, 0x40, 0x7b, 0xb4, 0x6f, 0x0d, 0xed, 0x8f, 0x1e,
	0x20, 0xc3, 0x0e, 0x8b, 0x60, 0xb9, 0x55, 0x10, 0x6c, 0xb8, 0xf6, 0xee, 0x56, 0x14, 0xed, 0x9c,
	0x5f, 0x70, 0x4d, 0x87, 0xa4, 0x75, 0x6d, 0x46, 0x4e, 0x79, 0xff, 0x32, 0x4b, 0xb1, 0x37, 0x3a,
	0x98, 0x6b, 0xbf, 0x08, 0x0f, 0xbe, 0xb5, 0x88, 0x33, 0x9f, 0x4d, 0x59, 0x02, 0x45, 0x03, 0x37,
	0x12, 0xdc, 0x95, 0xa6, 0x77, 0x9d, 0xb3, 0xee, 0xa8, 0xba, 0x3b, 0xfd, 0x3c, 0x86, 0xa2, 0x7c,
	0x07, 0xd6, 0x4a, 0xd1, 0xc7, 0xad, 0x55, 0x2c, 0xc3, 0x21, 0x69, 0xa5, 0x66, 0x32, 0x94, 0x77,
	0x5c, 0xd6, 0x50, 0x99, 0x15, 0xbf, 0x08, 0x0f, 0x7e, 0x30, 0x2b, 0xfa, 0x05, 0x24, 0xf2, 0x15,
	0xb0, 0x08, 0x32, 0xdc, 0xa3, 0x09, 0x4b, 0x6f, 0xef, 0xfc, 0x56, 0xc2, 0x52, 0xb3, 0xf1, 0x1f,
	0x90, 0xb6, 0xe6, 0xe1, 0x26, 0xc8, 0x70, 0x82, 0xab, 0x33, 0x64, 0x23, 0xf6, 0xf1, 0x22, 0xa7,
	0xa4, 0xb5, 0x83, 0x4c, 0x71, 0x29, 0xcc, 0x10, 0x75, 0x8b, 0x14, 0x7b, 0x48, 0x9f, 0x90, 0x9e,
	0xc2, 0x86, 0x0f, 0xb6, 0x82, 0x23, 0xcb, 0xa7, 0xa9, 0x90, 0x75, 0x4d, 0xec, 0xcd, 0x3e, 0x34,
	0x50, 0xf8, 0x69, 0x5c, 0xf0, 0x70, 0x83, 0xf6, 0x9b, 0x93, 0xcd, 0x2c, 0x1f, 0x0e, 0x38, 0xf2,
	0x31, 0x62, 0x3a, 0x28, 0x96, 0x4b, 0xee, 0x4f, 0x67, 0x54, 0x71, 0xb8, 0x58, 0x32, 0x7d, 0xd2,
	0x34, 0x5f, 0xb0, 0xc2, 0x1d, 0x7b, 0xb4, 0xff, 0xe6, 0xf9, 0x7b, 0xfe, 0xf8, 0x27, 0x8b, 0xb4,
	0x27, 0xaf, 0xb8, 0x9e, 0x66, 0x72, 0x9b, 0xd2, 0x3b, 0xc4, 0x99, 0xbc, 0x9a, 0x06, 0x53, 0x10,
	0x90, 0xf1, 0xd0, 0x3d, 0xa2, 0x1d, 0x62, 0x23, 0x40, 0xcb, 0x5c, 0x8b, 0x76, 0x51, 0x3b, 0x0d,
	0xc6, 0x6b, 0x50, 0xda, 0xad, 0x15, 0xea, 0x4b, 0x2d, 0x13, 0x16, 0xae, 0xdd, 0xe3, 0x02, 0xcc,
	0x60, 0xa9, 0x9f, 0x65, 0x89, 0x5b, 0xa7, 0x2e, 0xe9, 0x20, 0xf0, 0xf9, 0x6a, 0x6d, 0x48, 0xa3,
	0x2a, 0x99, 0xc1, 0xca, 0x6d, 0x1e, 0x48, 0x90, 0xb4, 0x8a, 0x33, 0xa7, 0xc0, 0x32, 0xd7, 0x2e,
	0xfe, 0xcd, 0xb9, 0x52, 0x6e, 0xfb, 0xf1, 0x4b, 0xd2, 0x30, 0x3b, 0x85, 0xf6, 0x48, 0x65, 0xab,
	0xb8, 0x47, 0x26, 0xcd, 0x22, 0xb8, 0x4c, 0x21, 0xd4, 0x4c, 0xcb, 0xcc, 0xb5, 0xf6, 0x64, 0x01,
	0x59, 0x26, 0x33, 0x6e, 0xea, 0x6d, 0xe3, 0xc3, 0xc1, 0x78, 0xe1, 0x1e, 0x3f, 0xfe, 0xd3, 0x22,
	0x4e, 0xe5, 0x83, 0x61, 0x6e, 0x56, 0x7c, 0x32, 0xdc, 0x23, 0x93, 0xfd, 0xed, 0x22, 0x78, 0xcd,
	0x95, 0x96, 0xb1, 0x6b, 0xd1, 0x7f, 0x93, 0x13, 0xfc, 0x7f, 0xb9, 0xbd, 0x9a, 0xb3, 0x70, 0xcd,
	0x05, 0x4c, 0xb7, 0xc2, 0xad, 0x15, 0x4f, 0xf9, 0x7c, 0x19, 0xc3, 0xfe, 0xfa, 0xa8, 0x5a, 0x4b,
	0xbd, 0xda, 0x0a, 0xb7, 0x4e, 0xef, 0x92, 0x3b, 0x06, 0x08, 0x9e, 0x42, 0x96, 0xab, 0x1a, 0x94,
	0x92, 0x1e, 0xc2, 0x4a, 0xa2, 0x26, 0x25, 0xa4, 0x89, 0x6c, 0xfc, 0xb9, 0xdb, 0x2a, 0xb2, 0x4c,
	0x33, 0x10, 0x2c, 0x02, 0xd7, 0xa6, 0x27, 0xa4, 0x8b, 0x60, 0xf2, 0xf5, 0x96, 0xa7, 0x09, 0x08,
	0xed, 0xb6, 0xcb, 0x7a, 0x34, 0x0b, 0x37, 0xec, 0x2a, 0x86, 0x73, 0x0d, 0x89, 0x4b, 0x8a, 0x47,
	0x0b, 0x57, 0x9c, 0xe7, 0xee, 0xfb, 0x0f, 0xa7, 0xd6, 0xaf, 0x1f, 0x4e, 0xad, 0xdf, 0x3f, 0x9c,
	0x5a, 0xdf, 0xff, 0x71, 0x7a, 0xf4, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x90, 0x60, 0x32,
	0xa3, 0x09, 0x00, 0x00,
}
